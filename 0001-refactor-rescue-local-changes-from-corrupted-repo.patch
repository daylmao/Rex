From 9090122aaed7b3e7fa9693a53ba22aa5ae7994b9 Mon Sep 17 00:00:00 2001
From: Dayron <dayronbp06@gmail.com>
Date: Sat, 1 Nov 2025 00:10:58 -0400
Subject: [PATCH] refactor: rescue local changes from corrupted repo

---
 .env.template                                 |   16 +
 .gitignore                                    |  366 +++++
 Readme.md                                     |  209 +++
 .../Abstractions/Messages/ICommand.cs         |   10 +
 .../Abstractions/Messages/ICommandHandler.cs  |   12 +
 .../Abstractions/Messages/IQuery.cs           |    6 +
 .../Abstractions/Messages/IQueryHandler.cs    |    8 +
 .../Behavior/ValidationBehavior.cs            |   32 +
 .../DTOs/Challenge/ChallengeDetailsDto.cs     |   10 +
 .../Challenge/ChallengeGroupDetailsDto.cs     |   12 +
 .../DTOs/Challenge/ChallengeUserDetailsDto.cs |   14 +
 .../DTOs/Challenge/CreateChallengeDto.cs      |   11 +
 .../DTOs/Challenge/UpdateChallengeDto.cs      |   11 +
 Rex.Application/DTOs/Chat/ChatDto.cs          |    8 +
 .../DTOs/Chat/ChatLastMessageDto.cs           |   11 +
 Rex.Application/DTOs/Code/CodeDto.cs          |   10 +
 .../DTOs/Code/ConfirmAccountDto.cs            |    3 +
 .../DTOs/Code/ConfirmEmailCodeDto.cs          |    3 +
 .../DTOs/Comment/CommentDetailsDto.cs         |   17 +
 Rex.Application/DTOs/Comment/CommentDto.cs    |   13 +
 .../DTOs/Comment/CommentUpdatedDto.cs         |   11 +
 .../DTOs/Comment/CreateCommentDto.cs          |    9 +
 .../DTOs/Comment/CreateCommentReplyDto.cs     |   10 +
 Rex.Application/DTOs/Comment/PinCommentDto.cs |    7 +
 Rex.Application/DTOs/Configs/EmailDto.cs      |    7 +
 .../DTOs/Configs/ProblemDetailsDto.cs         |   12 +
 Rex.Application/DTOs/File/FileDetailDto.cs    |    3 +
 .../DTOs/Friendship/FriendshipRequestDto.cs   |   10 +
 .../Friendship/UpdateFriendshipStatusDto.cs   |    7 +
 Rex.Application/DTOs/Group/CreateGroupDto.cs  |   12 +
 .../DTOs/Group/GetGroupMembersRequestDto.cs   |    6 +
 Rex.Application/DTOs/Group/GroupDetailsDto.cs |   12 +
 .../DTOs/Group/GroupUserModerationDto.cs      |    5 +
 .../DTOs/Group/ManageRequestStatusDto.cs      |    7 +
 Rex.Application/DTOs/Group/UpdateGroupDto.cs  |   12 +
 .../DTOs/Group/UpdateRoleMemberdto.cs         |    5 +
 Rex.Application/DTOs/JWT/GithubResponseDto.cs |    7 +
 Rex.Application/DTOs/JWT/RefreshTokenDto.cs   |    3 +
 Rex.Application/DTOs/JWT/ResponseDto.cs       |    3 +
 Rex.Application/DTOs/JWT/TokenResponseDto.cs  |    6 +
 .../DTOs/Message/LastMessageDto.cs            |   10 +
 Rex.Application/DTOs/Message/MessageDto.cs    |   14 +
 .../DTOs/Message/SendFileMessageDto.cs        |    9 +
 .../DTOs/Notification/NotificationDto.cs      |   13 +
 Rex.Application/DTOs/Post/CreatePostDto.cs    |   11 +
 Rex.Application/DTOs/Post/PostDetailsDto.cs   |   19 +
 .../DTOs/Reaction/LikeChangedDto.cs           |    8 +
 Rex.Application/DTOs/Reply/ReplyDto.cs        |   14 +
 Rex.Application/DTOs/User/RegisterUserDto.cs  |   14 +
 Rex.Application/DTOs/User/UpdateEmailDto.cs   |    3 +
 .../DTOs/User/UpdatePasswordDto.cs            |    6 +
 .../DTOs/User/UpdateUserInformationDto.cs     |   10 +
 .../DTOs/User/UpdateUsernameDto.cs            |    3 +
 .../DTOs/User/UserCommentDetailsDto.cs        |    8 +
 .../DTOs/User/UserGroupDetailsDto.cs          |    9 +
 .../DTOs/User/UserGroupRequestDto.cs          |    9 +
 Rex.Application/DTOs/User/UserProfileDto.cs   |   18 +
 Rex.Application/DependecyInjection.cs         |   37 +
 .../Helpers/InactivityThresholds.cs           |    7 +
 Rex.Application/Helpers/ProcessFiles.cs       |   81 ++
 .../Repository/IChallengeRepository.cs        |   77 +
 .../Interfaces/Repository/IChatRepository.cs  |   32 +
 .../Interfaces/Repository/ICodeRepository.cs  |   56 +
 .../Repository/ICommentRepository.cs          |   48 +
 .../Repository/IEntityFileRepository.cs       |   32 +
 .../Interfaces/Repository/IFileRepository.cs  |   46 +
 .../Repository/IFriendShipRepository.cs       |   38 +
 .../Repository/IGenericRepository.cs          |   56 +
 .../Interfaces/Repository/IGroupRepository.cs |   25 +
 .../Repository/IGroupRoleRepository.cs        |    8 +
 .../Repository/IMessageRepository.cs          |   22 +
 .../Repository/INotificationRepository.cs     |   22 +
 .../Interfaces/Repository/IPostRepository.cs  |   22 +
 .../Repository/IReactionRepository.cs         |   21 +
 .../Repository/IRefreshTokenRepository.cs     |   51 +
 .../Repository/IUserChallengeRepository.cs    |   22 +
 .../Repository/IUserChatRepository.cs         |   25 +
 .../Repository/IUserGroupRepository.cs        |   46 +
 .../Interfaces/Repository/IUserRepository.cs  |  131 ++
 .../Repository/IUserRoleRepository.cs         |   10 +
 .../Services/IAuthenticationService.cs        |   18 +
 .../Services/IChallengeExpirationService.cs   |    9 +
 .../Interfaces/Services/ICloudinaryService.cs |    9 +
 .../Interfaces/Services/ICodeService.cs       |   36 +
 .../Interfaces/Services/IEmailService.cs      |   14 +
 .../Interfaces/Services/IGithubAuthService.cs |   10 +
 .../Interfaces/Services/IMessageService.cs    |   16 +
 .../Interfaces/Services/IRemoveUserService.cs |   10 +
 .../Interfaces/Services/IUserClaimService.cs  |    8 +
 .../Services/IUserInGroupService.cs           |    8 +
 .../Interfaces/Services/IUserRoleService.cs   |   12 +
 .../Interfaces/Services/IWarnUserService.cs   |    9 +
 .../Services/SignalR/IAppConnectionService.cs |    9 +
 .../Interfaces/Services/SignalR/IAppHub.cs    |   24 +
 .../Services/SignalR/IChallengeNotifier.cs    |    8 +
 .../Services/SignalR/IChatNotifier.cs         |   10 +
 .../Services/SignalR/ICommentsNotifier.cs     |    9 +
 .../Services/SignalR/IFriendshipNotifier.cs   |    9 +
 .../Services/SignalR/IInactiveUserNotifier.cs |    9 +
 .../Services/SignalR/IReactionNotifier.cs     |   11 +
 .../CreateChallenge/CreateChallengeCommand.cs |   14 +
 .../CreateChallengeCommandHandler.cs          |  124 ++
 .../DeleteChallenge/DeleteChallengeCommand.cs |   10 +
 .../DeleteChallengeCommandHandler.cs          |   89 ++
 .../JoinChallenge/JoinChallengeCommand.cs     |    9 +
 .../JoinChallengeCommandHandler.cs            |   72 +
 .../UpdateChallenge/UpdateChallengeCommand.cs |   14 +
 .../UpdateChallengeCommandHandler.cs          |   64 +
 .../GetChallengeById/GetChallengeByIdQuery.cs |   10 +
 .../GetChallengeByIdQueryHandler.cs           |   73 +
 .../GetChallengesByStatusQuery.cs             |   13 +
 .../GetChallengesByStatusQueryHandler.cs      |   95 ++
 .../GetChallengesByUserQuery.cs               |   13 +
 .../GetChallengesByUserQueryHandler.cs        |   95 ++
 .../CreatePrivateChatCommand.cs               |    9 +
 .../CreatePrivateChatCommandHandler.cs        |   94 ++
 .../GetChatsByUserId/GetChatsByUserIdQuery.cs |   12 +
 .../GetChatsByUserIdQueryHandler.cs           |  110 ++
 .../CreateComment/CreateCommentCommand.cs     |   12 +
 .../CreateCommentCommandHandler.cs            |  103 ++
 .../CreateCommentReplyCommand.cs              |   13 +
 .../CreateCommentReplyCommandHandler.cs       |  152 ++
 .../Commands/PinComment/PinCommentCommand.cs  |   11 +
 .../PinComment/PinCommentCommandHandler.cs    |   93 ++
 .../UpdateComment/UpdateCommentCommand.cs     |   12 +
 .../UpdateCommentCommandHandler.cs            |   81 ++
 .../GetCommentRepliesQuery.cs                 |   12 +
 .../GetCommentRepliesQueryHandler.cs          |  101 ++
 .../GetCommentsByPostIdQuery.cs               |   11 +
 .../GetCommentsByPostIdQueryHandler.cs        |   91 ++
 .../CreateFriendshipRequestCommand.cs         |    9 +
 .../CreateFriendshipRequestCommandHandler.cs  |  110 ++
 .../DeleteFriendshipCommand.cs                |    9 +
 .../DeleteFriendshipCommandHandler.cs         |   79 +
 .../ManageFriendshipRequestCommand.cs         |   11 +
 .../ManageFriendshipRequestCommandHandler.cs  |   99 ++
 .../GetFriendshipsRequestQuery.cs             |   11 +
 .../GetFriendshipsRequestQueryHandler.cs      |   79 +
 .../CreateGroup/CreateGroupCommand.cs         |   15 +
 .../CreateGroup/CreateGroupCommandHandler.cs  |   95 ++
 .../DeleteGroup/DeleteGroupCommand.cs         |   10 +
 .../DeleteGroup/DeleteGroupCommandHandler.cs  |   62 +
 .../GroupUserModerationCommand.cs             |   11 +
 .../GroupUserModerationCommandHandler.cs      |   65 +
 .../ManageRequest/ManageRequestCommand.cs     |   11 +
 .../ManageRequestCommandHandler.cs            |   76 +
 .../RequestToJoinGroupCommand.cs              |    9 +
 .../RequestToJoinGroupCommandHandler.cs       |  101 ++
 .../UpdateGroup/UpdateGroupCommand.cs         |   15 +
 .../UpdateGroup/UpdateGroupCommandHandler.cs  |   68 +
 .../UpdateGroupRoleMemberCommand.cs           |   11 +
 .../UpdateGroupRoleMemberCommandHandler.cs    |   64 +
 .../GetGroupByGroupIdQuery.cs                 |    9 +
 .../GetGroupByGroupIdQueryHandler.cs          |   98 ++
 .../GetGroupJoinRequestsCommand.cs            |   12 +
 .../GetGroupJoinRequestsCommandHandler.cs     |   88 ++
 .../GetGroupMembers/GetGroupMembersQuery.cs   |   14 +
 .../GetGroupMembersQueryHandler.cs            |   79 +
 .../GetGroupsByUserIdQuery.cs                 |   11 +
 .../GetGroupsByUserIdQueryHandler.cs          |   84 ++
 .../GetGroupsPaginatedQuery.cs                |   12 +
 .../GetGroupsPaginatedQueryHandler.cs         |   78 +
 .../SendFileMessage/SendFileMessageCommand.cs |   12 +
 .../SendFileMessageCommandHandler.cs          |   22 +
 .../SendMessage/SendMessageCommand.cs         |   10 +
 .../SendMessage/SendMessageCommandHandler.cs  |   19 +
 .../GetMessagesByChatIdQuery.cs               |   11 +
 .../GetMessagesByChatIdQueryHandler.cs        |   81 ++
 .../MarkNotificationAsReadCommand.cs          |    6 +
 .../MarkNotificationAsReadCommandHandler.cs   |   45 +
 .../GetNotificationsByUserIdCommand.cs        |   11 +
 .../GetNotificationsByUserIdCommandHandler.cs |   71 +
 .../Commands/CreatePost/CreatePostCommand.cs  |   14 +
 .../CreatePost/CreatePostCommandHandler.cs    |  141 ++
 .../Commands/DeletePost/DeletePostCommand.cs  |   10 +
 .../DeletePost/DeletePostCommandHandler.cs    |   82 ++
 .../GetPostsByGroupIdQuery.cs                 |   12 +
 .../GetPostsByGroupIdQueryHandler.cs          |  117 ++
 .../Commands/AddLike/AddLikeCommand.cs        |   11 +
 .../Commands/AddLike/AddLikeCommandHandler.cs |  141 ++
 .../Commands/RemoveLike/RemoveLikeCommand.cs  |   11 +
 .../RemoveLike/RemoveLikeCommandHandler.cs    |   48 +
 .../ConfirmAccount/ConfirmAccountCommand.cs   |    9 +
 .../ConfirmAccountCommandHandler.cs           |   42 +
 .../ConfirmAccountValidation.cs               |   15 +
 .../ConfirmEmailChangeCommand.cs              |    9 +
 .../ConfirmEmailChangeCommandHandler.cs       |   46 +
 .../ConfirmPasswordChangeByEmailCommand.cs    |   10 +
 ...firmPasswordChangeByEmailCommandHandler.cs |   47 +
 .../InactiveAccount/InactiveAccountCommand.cs |    8 +
 .../InactiveAccountCommandHandler.cs          |   41 +
 .../Users/Commands/Login/LoginCommand.cs      |    9 +
 .../Commands/Login/LoginCommandHandler.cs     |   73 +
 .../Users/Commands/Login/LoginValidation.cs   |   17 +
 .../RegisterUser/RegisterUserCommand.cs       |   19 +
 .../RegisterUserCommandHandler.cs             |   99 ++
 .../RegisterUser/RegisterUserValidation.cs    |   36 +
 .../Commands/ResendCode/ResendCodeCommand.cs  |    8 +
 .../ResendCode/ResendCodeCommandHandler.cs    |   61 +
 .../ResendCode/ResendCodeValidation.cs        |   13 +
 .../UpdateEmail/UpdateEmailCommand.cs         |   10 +
 .../UpdateEmail/UpdateEmailCommandHandler.cs  |   80 ++
 .../UpdatePassword/UpdatePasswordCommand.cs   |   10 +
 .../UpdatePasswordCommandHandler.cs           |   43 +
 .../UpdatePasswordByEmailCommand.cs           |    8 +
 .../UpdatePasswordByEmailCommandHandler.cs    |   54 +
 .../UpdateUserInformationCommand.cs           |   13 +
 .../UpdateUserInformationCommandHandler.cs    |   54 +
 .../UpdateUsername/UpdateUsernameCommand.cs   |    9 +
 .../UpdateUsernameCommandHandler.cs           |   49 +
 .../GetUserDetails/GetUserDetailsByIdQuery.cs |    8 +
 .../GetUserDetailsByIdQueryHandler.cs         |   62 +
 Rex.Application/Pagination/PagedResult.cs     |   24 +
 Rex.Application/Rex.Application.csproj        |   31 +
 .../Services/ChallengeExpirationService.cs    |   39 +
 Rex.Application/Services/CodeService.cs       |  172 +++
 Rex.Application/Services/MessageService.cs    |   87 ++
 Rex.Application/Services/RemoveUserService.cs |   76 +
 .../Services/UserInGroupService.cs            |   56 +
 Rex.Application/Services/WarnUserService.cs   |   74 +
 Rex.Application/Utilities/CodeGenerator.cs    |   30 +
 Rex.Application/Utilities/DistributedCache.cs |   84 ++
 Rex.Application/Utilities/EmailTemplate.cs    |  556 +++++++
 Rex.Application/Utilities/Error.cs            |   76 +
 Rex.Application/Utilities/Result.cs           |  120 ++
 .../Configurations/CloudinaryConfiguration.cs |    6 +
 .../Configurations/EmailConfiguration.cs      |   15 +
 .../Configurations/GithubConfiguration.cs     |    7 +
 Rex.Domain/Configurations/JWTConfiguration.cs |   10 +
 Rex.Domain/Enum/ChallengeStatus.cs            |    7 +
 Rex.Domain/Enum/ChatType.cs                   |    7 +
 Rex.Domain/Enum/CodeType.cs                   |    8 +
 Rex.Domain/Enum/ErrorType.cs                  |   10 +
 Rex.Domain/Enum/FileType.cs                   |    8 +
 Rex.Domain/Enum/Gender.cs                     |    8 +
 Rex.Domain/Enum/GroupRole.cs                  |    9 +
 Rex.Domain/Enum/GroupUserModerationStatus.cs  |    7 +
 Rex.Domain/Enum/GroupVisibility.cs            |    7 +
 Rex.Domain/Enum/ManageRequestStatus.cs        |    7 +
 Rex.Domain/Enum/ReactionTargetType.cs         |    7 +
 Rex.Domain/Enum/RequestStatus.cs              |    9 +
 Rex.Domain/Enum/TargetType.cs                 |   11 +
 Rex.Domain/Enum/UserChallengeStatus.cs        |    7 +
 Rex.Domain/Enum/UserRole.cs                   |    7 +
 Rex.Domain/Enum/UserStatus.cs                 |    7 +
 Rex.Domain/Models/AuditableEntity.cs          |    9 +
 Rex.Domain/Models/Challenge.cs                |   18 +
 Rex.Domain/Models/Chat.cs                     |   11 +
 Rex.Domain/Models/Code.cs                     |   15 +
 Rex.Domain/Models/Comment.cs                  |   17 +
 Rex.Domain/Models/EntityBase.cs               |    6 +
 Rex.Domain/Models/EntityFile.cs               |   12 +
 Rex.Domain/Models/File.cs                     |   12 +
 Rex.Domain/Models/FriendShip.cs               |   12 +
 Rex.Domain/Models/Group.cs                    |   15 +
 Rex.Domain/Models/GroupRole.cs                |    9 +
 Rex.Domain/Models/Message.cs                  |   11 +
 Rex.Domain/Models/Notification.cs             |   15 +
 Rex.Domain/Models/Post.cs                     |   15 +
 Rex.Domain/Models/Reaction.cs                 |   13 +
 Rex.Domain/Models/RefreshToken.cs             |   12 +
 Rex.Domain/Models/User.cs                     |   37 +
 Rex.Domain/Models/UserChallenge.cs            |   13 +
 Rex.Domain/Models/UserChat.cs                 |   11 +
 Rex.Domain/Models/UserGroup.cs                |   15 +
 Rex.Domain/Models/UserRole.cs                 |    8 +
 Rex.Domain/Rex.Domain.csproj                  |   10 +
 .../Context/RexContext.cs                     |  937 ++++++++++++
 .../DependencyInjection.cs                    |   65 +
 .../20251027052200_Initial.Designer.cs        | 1280 +++++++++++++++++
 .../Migrations/20251027052200_Initial.cs      |  736 ++++++++++
 .../Migrations/RexContextModelSnapshot.cs     | 1277 ++++++++++++++++
 .../Repository/ChallengeRepository.cs         |  145 ++
 .../Repository/ChatRepository.cs              |   96 ++
 .../Repository/CodeRepository.cs              |   44 +
 .../Repository/CommentRepository.cs           |  100 ++
 .../Repository/EntityFileRepository.cs        |   20 +
 .../Repository/FileRepository.cs              |   65 +
 .../Repository/FrienshipRepository.cs         |   72 +
 .../Repository/GenericRepository.cs           |   53 +
 .../Repository/GroupRepository.cs             |  112 ++
 .../Repository/GroupRoleRepository.cs         |   14 +
 .../Repository/MessageRepository.cs           |   29 +
 .../Repository/NotificationRepository.cs      |   30 +
 .../Repository/PostRepository.cs              |   47 +
 .../Repository/ReactionRepository.cs          |   52 +
 .../Repository/RefreshTokenRepository.cs      |   50 +
 .../Repository/UserChallengeRepository.cs     |   22 +
 .../Repository/UserChatRepository.cs          |   30 +
 .../Repository/UserGroupRepository.cs         |  217 +++
 .../Repository/UserRepository.cs              |  167 +++
 .../Repository/UserRoleRepository.cs          |   16 +
 .../Rex.Infrastructure.Persistence.csproj     |   25 +
 .../Services/UserRoleService.cs               |   35 +
 .../DependencyInjection.cs                    |  307 ++++
 .../Rex.Infrastructure.Shared.csproj          |   30 +
 .../Services/AuthenticationService.cs         |  135 ++
 .../Authorization/GroupRoleHandler.cs         |   76 +
 .../Authorization/GroupRoleRequirement.cs     |    9 +
 .../Services/CloudinaryService.cs             |   55 +
 .../Services/EmailService.cs                  |   40 +
 .../Services/GithubAuthService.cs             |  105 ++
 .../Services/SignalR/AppConnectionService.cs  |   68 +
 .../Services/SignalR/ChallengeNotifier.cs     |   34 +
 .../Services/SignalR/ChatNotifier.cs          |   32 +
 .../Services/SignalR/CommentsNotifier.cs      |   54 +
 .../Services/SignalR/FriendshipNotifier.cs    |   34 +
 .../Services/SignalR/Hubs/AppHub.cs           |   93 ++
 .../Services/SignalR/InactiveUserNotifier.cs  |   54 +
 .../Services/SignalR/ReactionNotifier.cs      |   41 +
 .../Services/UserClaimService.cs              |   20 +
 .../Controllers/AuthController.cs             |  100 ++
 .../Controllers/ChallengesController.cs       |  137 ++
 .../Controllers/ChatsController.cs            |   37 +
 .../Controllers/CommentsController.cs         |  125 ++
 .../Controllers/FriendshipsController.cs      |   75 +
 .../Controllers/GroupsController.cs           |  213 +++
 .../Controllers/MessagesController.cs         |   56 +
 .../Controllers/NotificationsController.cs    |   51 +
 .../Controllers/PostsController.cs            |   80 ++
 .../Controllers/UsersController.cs            |  204 +++
 .../Filters/HangfireAuthorizationFilter.cs    |   25 +
 Rex.Presentation.Api/Filters/ResultFilter.cs  |   61 +
 .../ExceptionHandlingMiddleware.cs            |   75 +
 Rex.Presentation.Api/Program.cs               |   81 ++
 .../Properties/launchSettings.json            |   41 +
 .../Rex.Presentation.Api.csproj               |   30 +
 .../Rex.Presentation.Api.http                 |    6 +
 .../ServicesExtension/ServiceExtensions.cs    |   79 +
 .../appsettings.Development.json              |    8 +
 Rex.sln                                       |   61 +
 docker-compose.yml                            |   63 +
 332 files changed, 17647 insertions(+)
 create mode 100644 .env.template
 create mode 100644 .gitignore
 create mode 100644 Readme.md
 create mode 100644 Rex.Application/Abstractions/Messages/ICommand.cs
 create mode 100644 Rex.Application/Abstractions/Messages/ICommandHandler.cs
 create mode 100644 Rex.Application/Abstractions/Messages/IQuery.cs
 create mode 100644 Rex.Application/Abstractions/Messages/IQueryHandler.cs
 create mode 100644 Rex.Application/Behavior/ValidationBehavior.cs
 create mode 100644 Rex.Application/DTOs/Challenge/ChallengeDetailsDto.cs
 create mode 100644 Rex.Application/DTOs/Challenge/ChallengeGroupDetailsDto.cs
 create mode 100644 Rex.Application/DTOs/Challenge/ChallengeUserDetailsDto.cs
 create mode 100644 Rex.Application/DTOs/Challenge/CreateChallengeDto.cs
 create mode 100644 Rex.Application/DTOs/Challenge/UpdateChallengeDto.cs
 create mode 100644 Rex.Application/DTOs/Chat/ChatDto.cs
 create mode 100644 Rex.Application/DTOs/Chat/ChatLastMessageDto.cs
 create mode 100644 Rex.Application/DTOs/Code/CodeDto.cs
 create mode 100644 Rex.Application/DTOs/Code/ConfirmAccountDto.cs
 create mode 100644 Rex.Application/DTOs/Code/ConfirmEmailCodeDto.cs
 create mode 100644 Rex.Application/DTOs/Comment/CommentDetailsDto.cs
 create mode 100644 Rex.Application/DTOs/Comment/CommentDto.cs
 create mode 100644 Rex.Application/DTOs/Comment/CommentUpdatedDto.cs
 create mode 100644 Rex.Application/DTOs/Comment/CreateCommentDto.cs
 create mode 100644 Rex.Application/DTOs/Comment/CreateCommentReplyDto.cs
 create mode 100644 Rex.Application/DTOs/Comment/PinCommentDto.cs
 create mode 100644 Rex.Application/DTOs/Configs/EmailDto.cs
 create mode 100644 Rex.Application/DTOs/Configs/ProblemDetailsDto.cs
 create mode 100644 Rex.Application/DTOs/File/FileDetailDto.cs
 create mode 100644 Rex.Application/DTOs/Friendship/FriendshipRequestDto.cs
 create mode 100644 Rex.Application/DTOs/Friendship/UpdateFriendshipStatusDto.cs
 create mode 100644 Rex.Application/DTOs/Group/CreateGroupDto.cs
 create mode 100644 Rex.Application/DTOs/Group/GetGroupMembersRequestDto.cs
 create mode 100644 Rex.Application/DTOs/Group/GroupDetailsDto.cs
 create mode 100644 Rex.Application/DTOs/Group/GroupUserModerationDto.cs
 create mode 100644 Rex.Application/DTOs/Group/ManageRequestStatusDto.cs
 create mode 100644 Rex.Application/DTOs/Group/UpdateGroupDto.cs
 create mode 100644 Rex.Application/DTOs/Group/UpdateRoleMemberdto.cs
 create mode 100644 Rex.Application/DTOs/JWT/GithubResponseDto.cs
 create mode 100644 Rex.Application/DTOs/JWT/RefreshTokenDto.cs
 create mode 100644 Rex.Application/DTOs/JWT/ResponseDto.cs
 create mode 100644 Rex.Application/DTOs/JWT/TokenResponseDto.cs
 create mode 100644 Rex.Application/DTOs/Message/LastMessageDto.cs
 create mode 100644 Rex.Application/DTOs/Message/MessageDto.cs
 create mode 100644 Rex.Application/DTOs/Message/SendFileMessageDto.cs
 create mode 100644 Rex.Application/DTOs/Notification/NotificationDto.cs
 create mode 100644 Rex.Application/DTOs/Post/CreatePostDto.cs
 create mode 100644 Rex.Application/DTOs/Post/PostDetailsDto.cs
 create mode 100644 Rex.Application/DTOs/Reaction/LikeChangedDto.cs
 create mode 100644 Rex.Application/DTOs/Reply/ReplyDto.cs
 create mode 100644 Rex.Application/DTOs/User/RegisterUserDto.cs
 create mode 100644 Rex.Application/DTOs/User/UpdateEmailDto.cs
 create mode 100644 Rex.Application/DTOs/User/UpdatePasswordDto.cs
 create mode 100644 Rex.Application/DTOs/User/UpdateUserInformationDto.cs
 create mode 100644 Rex.Application/DTOs/User/UpdateUsernameDto.cs
 create mode 100644 Rex.Application/DTOs/User/UserCommentDetailsDto.cs
 create mode 100644 Rex.Application/DTOs/User/UserGroupDetailsDto.cs
 create mode 100644 Rex.Application/DTOs/User/UserGroupRequestDto.cs
 create mode 100644 Rex.Application/DTOs/User/UserProfileDto.cs
 create mode 100644 Rex.Application/DependecyInjection.cs
 create mode 100644 Rex.Application/Helpers/InactivityThresholds.cs
 create mode 100644 Rex.Application/Helpers/ProcessFiles.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IChallengeRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IChatRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/ICodeRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/ICommentRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IEntityFileRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IFileRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IFriendShipRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IGenericRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IGroupRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IGroupRoleRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IMessageRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/INotificationRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IPostRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IReactionRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IRefreshTokenRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IUserChallengeRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IUserChatRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IUserGroupRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IUserRepository.cs
 create mode 100644 Rex.Application/Interfaces/Repository/IUserRoleRepository.cs
 create mode 100644 Rex.Application/Interfaces/Services/IAuthenticationService.cs
 create mode 100644 Rex.Application/Interfaces/Services/IChallengeExpirationService.cs
 create mode 100644 Rex.Application/Interfaces/Services/ICloudinaryService.cs
 create mode 100644 Rex.Application/Interfaces/Services/ICodeService.cs
 create mode 100644 Rex.Application/Interfaces/Services/IEmailService.cs
 create mode 100644 Rex.Application/Interfaces/Services/IGithubAuthService.cs
 create mode 100644 Rex.Application/Interfaces/Services/IMessageService.cs
 create mode 100644 Rex.Application/Interfaces/Services/IRemoveUserService.cs
 create mode 100644 Rex.Application/Interfaces/Services/IUserClaimService.cs
 create mode 100644 Rex.Application/Interfaces/Services/IUserInGroupService.cs
 create mode 100644 Rex.Application/Interfaces/Services/IUserRoleService.cs
 create mode 100644 Rex.Application/Interfaces/Services/IWarnUserService.cs
 create mode 100644 Rex.Application/Interfaces/Services/SignalR/IAppConnectionService.cs
 create mode 100644 Rex.Application/Interfaces/Services/SignalR/IAppHub.cs
 create mode 100644 Rex.Application/Interfaces/Services/SignalR/IChallengeNotifier.cs
 create mode 100644 Rex.Application/Interfaces/Services/SignalR/IChatNotifier.cs
 create mode 100644 Rex.Application/Interfaces/Services/SignalR/ICommentsNotifier.cs
 create mode 100644 Rex.Application/Interfaces/Services/SignalR/IFriendshipNotifier.cs
 create mode 100644 Rex.Application/Interfaces/Services/SignalR/IInactiveUserNotifier.cs
 create mode 100644 Rex.Application/Interfaces/Services/SignalR/IReactionNotifier.cs
 create mode 100644 Rex.Application/Modules/Challenges/Commands/CreateChallenge/CreateChallengeCommand.cs
 create mode 100644 Rex.Application/Modules/Challenges/Commands/CreateChallenge/CreateChallengeCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Challenges/Commands/DeleteChallenge/DeleteChallengeCommand.cs
 create mode 100644 Rex.Application/Modules/Challenges/Commands/DeleteChallenge/DeleteChallengeCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Challenges/Commands/JoinChallenge/JoinChallengeCommand.cs
 create mode 100644 Rex.Application/Modules/Challenges/Commands/JoinChallenge/JoinChallengeCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Challenges/Commands/UpdateChallenge/UpdateChallengeCommand.cs
 create mode 100644 Rex.Application/Modules/Challenges/Commands/UpdateChallenge/UpdateChallengeCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Challenges/Queries/GetChallengeById/GetChallengeByIdQuery.cs
 create mode 100644 Rex.Application/Modules/Challenges/Queries/GetChallengeById/GetChallengeByIdQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Challenges/Queries/GetChallengesByStatus/GetChallengesByStatusQuery.cs
 create mode 100644 Rex.Application/Modules/Challenges/Queries/GetChallengesByStatus/GetChallengesByStatusQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Challenges/Queries/GetChallengesByUser/GetChallengesByUserQuery.cs
 create mode 100644 Rex.Application/Modules/Challenges/Queries/GetChallengesByUser/GetChallengesByUserQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Chats/Commands/CreatePrivateChat/CreatePrivateChatCommand.cs
 create mode 100644 Rex.Application/Modules/Chats/Commands/CreatePrivateChat/CreatePrivateChatCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Chats/Queries/GetChatsByUserId/GetChatsByUserIdQuery.cs
 create mode 100644 Rex.Application/Modules/Chats/Queries/GetChatsByUserId/GetChatsByUserIdQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Comments/Commands/CreateComment/CreateCommentCommand.cs
 create mode 100644 Rex.Application/Modules/Comments/Commands/CreateComment/CreateCommentCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Comments/Commands/CreateCommentReply/CreateCommentReplyCommand.cs
 create mode 100644 Rex.Application/Modules/Comments/Commands/CreateCommentReply/CreateCommentReplyCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Comments/Commands/PinComment/PinCommentCommand.cs
 create mode 100644 Rex.Application/Modules/Comments/Commands/PinComment/PinCommentCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Comments/Commands/UpdateComment/UpdateCommentCommand.cs
 create mode 100644 Rex.Application/Modules/Comments/Commands/UpdateComment/UpdateCommentCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Comments/Queries/GetCommentReplies/GetCommentRepliesQuery.cs
 create mode 100644 Rex.Application/Modules/Comments/Queries/GetCommentReplies/GetCommentRepliesQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Comments/Queries/GetCommentsByPostId/GetCommentsByPostIdQuery.cs
 create mode 100644 Rex.Application/Modules/Comments/Queries/GetCommentsByPostId/GetCommentsByPostIdQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Friendships/Commands/CreateRequestFriendship/CreateFriendshipRequestCommand.cs
 create mode 100644 Rex.Application/Modules/Friendships/Commands/CreateRequestFriendship/CreateFriendshipRequestCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Friendships/Commands/DeleteFriendship/DeleteFriendshipCommand.cs
 create mode 100644 Rex.Application/Modules/Friendships/Commands/DeleteFriendship/DeleteFriendshipCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Friendships/Commands/ManageFriendshipRequest/ManageFriendshipRequestCommand.cs
 create mode 100644 Rex.Application/Modules/Friendships/Commands/ManageFriendshipRequest/ManageFriendshipRequestCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Friendships/Queries/GetFriendshipsRequest/GetFriendshipsRequestQuery.cs
 create mode 100644 Rex.Application/Modules/Friendships/Queries/GetFriendshipsRequest/GetFriendshipsRequestQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/CreateGroup/CreateGroupCommand.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/CreateGroup/CreateGroupCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/DeleteGroup/DeleteGroupCommand.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/DeleteGroup/DeleteGroupCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/GroupUserModeration/GroupUserModerationCommand.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/GroupUserModeration/GroupUserModerationCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/ManageRequest/ManageRequestCommand.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/ManageRequest/ManageRequestCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/RequestToJoinGroup/RequestToJoinGroupCommand.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/RequestToJoinGroup/RequestToJoinGroupCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/UpdateGroup/UpdateGroupCommand.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/UpdateGroup/UpdateGroupCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/UpdateGroupRoleMember/UpdateGroupRoleMemberCommand.cs
 create mode 100644 Rex.Application/Modules/Groups/Commands/UpdateGroupRoleMember/UpdateGroupRoleMemberCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupByGroupId/GetGroupByGroupIdQuery.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupByGroupId/GetGroupByGroupIdQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupJoinRequests/GetGroupJoinRequestsCommand.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupJoinRequests/GetGroupJoinRequestsCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupMembers/GetGroupMembersQuery.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupMembers/GetGroupMembersQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupsByUserId/GetGroupsByUserIdQuery.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupsByUserId/GetGroupsByUserIdQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupsPaginated/GetGroupsPaginatedQuery.cs
 create mode 100644 Rex.Application/Modules/Groups/Queries/GetGroupsPaginated/GetGroupsPaginatedQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Messages/Commands/SendFileMessage/SendFileMessageCommand.cs
 create mode 100644 Rex.Application/Modules/Messages/Commands/SendFileMessage/SendFileMessageCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Messages/Commands/SendMessage/SendMessageCommand.cs
 create mode 100644 Rex.Application/Modules/Messages/Commands/SendMessage/SendMessageCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Messages/Queries/GetMessagesByChatId/GetMessagesByChatIdQuery.cs
 create mode 100644 Rex.Application/Modules/Messages/Queries/GetMessagesByChatId/GetMessagesByChatIdQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Notifications/Commands/MarkNotificationAsRead/MarkNotificationAsReadCommand.cs
 create mode 100644 Rex.Application/Modules/Notifications/Commands/MarkNotificationAsRead/MarkNotificationAsReadCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Notifications/Queries/GetNotificationsByUserId/GetNotificationsByUserIdCommand.cs
 create mode 100644 Rex.Application/Modules/Notifications/Queries/GetNotificationsByUserId/GetNotificationsByUserIdCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Posts/Commands/CreatePost/CreatePostCommand.cs
 create mode 100644 Rex.Application/Modules/Posts/Commands/CreatePost/CreatePostCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Posts/Commands/DeletePost/DeletePostCommand.cs
 create mode 100644 Rex.Application/Modules/Posts/Commands/DeletePost/DeletePostCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Posts/Queries/GetPostsByGroupId/GetPostsByGroupIdQuery.cs
 create mode 100644 Rex.Application/Modules/Posts/Queries/GetPostsByGroupId/GetPostsByGroupIdQueryHandler.cs
 create mode 100644 Rex.Application/Modules/Reactions/Commands/AddLike/AddLikeCommand.cs
 create mode 100644 Rex.Application/Modules/Reactions/Commands/AddLike/AddLikeCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Reactions/Commands/RemoveLike/RemoveLikeCommand.cs
 create mode 100644 Rex.Application/Modules/Reactions/Commands/RemoveLike/RemoveLikeCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountValidation.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ConfirmEmailChange/ConfirmEmailChangeCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ConfirmEmailChange/ConfirmEmailChangeCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ConfirmPasswordChangeByEmail/ConfirmPasswordChangeByEmailCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ConfirmPasswordChangeByEmail/ConfirmPasswordChangeByEmailCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/InactiveAccount/InactiveAccountCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/InactiveAccount/InactiveAccountCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/Login/LoginCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/Login/LoginCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/Login/LoginValidation.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserValidation.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeValidation.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdateEmail/UpdateEmailCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdateEmail/UpdateEmailCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdatePassword/UpdatePasswordCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdatePassword/UpdatePasswordCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdatePasswordByEmail/UpdatePasswordByEmailCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdatePasswordByEmail/UpdatePasswordByEmailCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdateUserInformation/UpdateUserInformationCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdateUserInformation/UpdateUserInformationCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdateUsername/UpdateUsernameCommand.cs
 create mode 100644 Rex.Application/Modules/Users/Commands/UpdateUsername/UpdateUsernameCommandHandler.cs
 create mode 100644 Rex.Application/Modules/Users/Queries/GetUserDetails/GetUserDetailsByIdQuery.cs
 create mode 100644 Rex.Application/Modules/Users/Queries/GetUserDetails/GetUserDetailsByIdQueryHandler.cs
 create mode 100644 Rex.Application/Pagination/PagedResult.cs
 create mode 100644 Rex.Application/Rex.Application.csproj
 create mode 100644 Rex.Application/Services/ChallengeExpirationService.cs
 create mode 100644 Rex.Application/Services/CodeService.cs
 create mode 100644 Rex.Application/Services/MessageService.cs
 create mode 100644 Rex.Application/Services/RemoveUserService.cs
 create mode 100644 Rex.Application/Services/UserInGroupService.cs
 create mode 100644 Rex.Application/Services/WarnUserService.cs
 create mode 100644 Rex.Application/Utilities/CodeGenerator.cs
 create mode 100644 Rex.Application/Utilities/DistributedCache.cs
 create mode 100644 Rex.Application/Utilities/EmailTemplate.cs
 create mode 100644 Rex.Application/Utilities/Error.cs
 create mode 100644 Rex.Application/Utilities/Result.cs
 create mode 100644 Rex.Domain/Configurations/CloudinaryConfiguration.cs
 create mode 100644 Rex.Domain/Configurations/EmailConfiguration.cs
 create mode 100644 Rex.Domain/Configurations/GithubConfiguration.cs
 create mode 100644 Rex.Domain/Configurations/JWTConfiguration.cs
 create mode 100644 Rex.Domain/Enum/ChallengeStatus.cs
 create mode 100644 Rex.Domain/Enum/ChatType.cs
 create mode 100644 Rex.Domain/Enum/CodeType.cs
 create mode 100644 Rex.Domain/Enum/ErrorType.cs
 create mode 100644 Rex.Domain/Enum/FileType.cs
 create mode 100644 Rex.Domain/Enum/Gender.cs
 create mode 100644 Rex.Domain/Enum/GroupRole.cs
 create mode 100644 Rex.Domain/Enum/GroupUserModerationStatus.cs
 create mode 100644 Rex.Domain/Enum/GroupVisibility.cs
 create mode 100644 Rex.Domain/Enum/ManageRequestStatus.cs
 create mode 100644 Rex.Domain/Enum/ReactionTargetType.cs
 create mode 100644 Rex.Domain/Enum/RequestStatus.cs
 create mode 100644 Rex.Domain/Enum/TargetType.cs
 create mode 100644 Rex.Domain/Enum/UserChallengeStatus.cs
 create mode 100644 Rex.Domain/Enum/UserRole.cs
 create mode 100644 Rex.Domain/Enum/UserStatus.cs
 create mode 100644 Rex.Domain/Models/AuditableEntity.cs
 create mode 100644 Rex.Domain/Models/Challenge.cs
 create mode 100644 Rex.Domain/Models/Chat.cs
 create mode 100644 Rex.Domain/Models/Code.cs
 create mode 100644 Rex.Domain/Models/Comment.cs
 create mode 100644 Rex.Domain/Models/EntityBase.cs
 create mode 100644 Rex.Domain/Models/EntityFile.cs
 create mode 100644 Rex.Domain/Models/File.cs
 create mode 100644 Rex.Domain/Models/FriendShip.cs
 create mode 100644 Rex.Domain/Models/Group.cs
 create mode 100644 Rex.Domain/Models/GroupRole.cs
 create mode 100644 Rex.Domain/Models/Message.cs
 create mode 100644 Rex.Domain/Models/Notification.cs
 create mode 100644 Rex.Domain/Models/Post.cs
 create mode 100644 Rex.Domain/Models/Reaction.cs
 create mode 100644 Rex.Domain/Models/RefreshToken.cs
 create mode 100644 Rex.Domain/Models/User.cs
 create mode 100644 Rex.Domain/Models/UserChallenge.cs
 create mode 100644 Rex.Domain/Models/UserChat.cs
 create mode 100644 Rex.Domain/Models/UserGroup.cs
 create mode 100644 Rex.Domain/Models/UserRole.cs
 create mode 100644 Rex.Domain/Rex.Domain.csproj
 create mode 100644 Rex.Infrastructure.Persistence/Context/RexContext.cs
 create mode 100644 Rex.Infrastructure.Persistence/DependencyInjection.cs
 create mode 100644 Rex.Infrastructure.Persistence/Migrations/20251027052200_Initial.Designer.cs
 create mode 100644 Rex.Infrastructure.Persistence/Migrations/20251027052200_Initial.cs
 create mode 100644 Rex.Infrastructure.Persistence/Migrations/RexContextModelSnapshot.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/ChallengeRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/ChatRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/CodeRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/CommentRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/EntityFileRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/FileRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/FrienshipRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/GenericRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/GroupRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/GroupRoleRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/MessageRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/NotificationRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/PostRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/ReactionRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/RefreshTokenRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/UserChallengeRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/UserChatRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/UserGroupRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/UserRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Repository/UserRoleRepository.cs
 create mode 100644 Rex.Infrastructure.Persistence/Rex.Infrastructure.Persistence.csproj
 create mode 100644 Rex.Infrastructure.Persistence/Services/UserRoleService.cs
 create mode 100644 Rex.Infrastructure.Shared/DependencyInjection.cs
 create mode 100644 Rex.Infrastructure.Shared/Rex.Infrastructure.Shared.csproj
 create mode 100644 Rex.Infrastructure.Shared/Services/AuthenticationService.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/Authorization/GroupRoleHandler.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/Authorization/GroupRoleRequirement.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/CloudinaryService.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/EmailService.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/GithubAuthService.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/SignalR/AppConnectionService.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/SignalR/ChallengeNotifier.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/SignalR/ChatNotifier.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/SignalR/CommentsNotifier.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/SignalR/FriendshipNotifier.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/SignalR/Hubs/AppHub.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/SignalR/InactiveUserNotifier.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/SignalR/ReactionNotifier.cs
 create mode 100644 Rex.Infrastructure.Shared/Services/UserClaimService.cs
 create mode 100644 Rex.Presentation.Api/Controllers/AuthController.cs
 create mode 100644 Rex.Presentation.Api/Controllers/ChallengesController.cs
 create mode 100644 Rex.Presentation.Api/Controllers/ChatsController.cs
 create mode 100644 Rex.Presentation.Api/Controllers/CommentsController.cs
 create mode 100644 Rex.Presentation.Api/Controllers/FriendshipsController.cs
 create mode 100644 Rex.Presentation.Api/Controllers/GroupsController.cs
 create mode 100644 Rex.Presentation.Api/Controllers/MessagesController.cs
 create mode 100644 Rex.Presentation.Api/Controllers/NotificationsController.cs
 create mode 100644 Rex.Presentation.Api/Controllers/PostsController.cs
 create mode 100644 Rex.Presentation.Api/Controllers/UsersController.cs
 create mode 100644 Rex.Presentation.Api/Filters/HangfireAuthorizationFilter.cs
 create mode 100644 Rex.Presentation.Api/Filters/ResultFilter.cs
 create mode 100644 Rex.Presentation.Api/Middlewares/ExceptionHandlingMiddleware.cs
 create mode 100644 Rex.Presentation.Api/Program.cs
 create mode 100644 Rex.Presentation.Api/Properties/launchSettings.json
 create mode 100644 Rex.Presentation.Api/Rex.Presentation.Api.csproj
 create mode 100644 Rex.Presentation.Api/Rex.Presentation.Api.http
 create mode 100644 Rex.Presentation.Api/ServicesExtension/ServiceExtensions.cs
 create mode 100644 Rex.Presentation.Api/appsettings.Development.json
 create mode 100644 Rex.sln
 create mode 100644 docker-compose.yml

diff --git a/.env.template b/.env.template
new file mode 100644
index 0000000..8149cbe
--- /dev/null
+++ b/.env.template
@@ -0,0 +1,16 @@
+POSTGRES_IMAGE=xxx
+POSTGRES_PORTS=xxx
+POSTGRES_USER=xxx
+POSTGRES_PASSWORD=xxx
+POSTGRES_DB=xxx
+PG_ADMIN_IMAGE=xxx
+PGADMIN_DEFAULT_EMAIL=xxx
+PGADMIN_DEFAULT_PASSWORD=xxx
+PGADMIN_PORTS=xxx
+SEQ_ACCEPT_EULA=xxx
+SEQ_IMAGE=xxx
+SEQ_PORT=xxx
+SEQ_PORT_UI=xxx
+SEQ_FIRSTRUN_ADMINPASSWORD=xxx
+REDIS_PORTS=xxx
+REDIS_IMAGE=xxx
\ No newline at end of file
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..6763e83
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,366 @@
+## Ignore Visual Studio temporary files, build results, and
+## files generated by popular Visual Studio add-ons.
+##
+## Get latest from https://github.com/github/gitignore/blob/master/VisualStudio.gitignore
+
+# User-specific files
+*.rsuser
+*.suo
+*.user
+*.userosscache
+*.sln.docstates
+# User-specific files (MonoDevelop/Xamarin Studio)
+*.userprefs
+.env
+/.idea
+.config
+appsettings.json
+# Mono auto generated files
+mono_crash.*
+
+# Build results
+[Dd]ebug/
+[Dd]ebugPublic/
+[Rr]elease/
+[Rr]eleases/
+x64/
+x86/
+[Ww][Ii][Nn]32/
+[Aa][Rr][Mm]/
+[Aa][Rr][Mm]64/
+bld/
+[Bb]in/
+[Oo]bj/
+[Oo]ut/
+[Ll]og/
+[Ll]ogs/
+
+# Visual Studio 2015/2017 cache/options directory
+.vs/
+# Uncomment if you have tasks that create the project's static files in wwwroot
+#wwwroot/
+
+# Visual Studio 2017 auto generated files
+Generated\ Files/
+
+# MSTest test Results
+[Tt]est[Rr]esult*/
+[Bb]uild[Ll]og.*
+
+# NUnit
+*.VisualState.xml
+TestResult.xml
+nunit-*.xml
+
+# Build Results of an ATL Project
+[Dd]ebugPS/
+[Rr]eleasePS/
+dlldata.c
+
+# Benchmark Results
+BenchmarkDotNet.Artifacts/
+
+# .NET Core
+project.lock.json
+project.fragment.lock.json
+artifacts/
+
+# ASP.NET Scaffolding
+ScaffoldingReadMe.txt
+
+# StyleCop
+StyleCopReport.xml
+
+# Files built by Visual Studio
+*_i.c
+*_p.c
+*_h.h
+*.ilk
+*.meta
+*.obj
+*.iobj
+*.pch
+*.pdb
+*.ipdb
+*.pgc
+*.pgd
+*.rsp
+*.sbr
+*.tlb
+*.tli
+*.tlh
+*.tmp
+*.tmp_proj
+*_wpftmp.csproj
+*.log
+*.vspscc
+*.vssscc
+.builds
+*.pidb
+*.svclog
+*.scc
+*.docx
+
+# Chutzpah Test files
+_Chutzpah*
+
+# Visual C++ cache files
+ipch/
+*.aps
+*.ncb
+*.opendb
+*.opensdf
+*.sdf
+*.cachefile
+*.VC.db
+*.VC.VC.opendb
+
+# Visual Studio profiler
+*.psess
+*.vsp
+*.vspx
+*.sap
+
+# Visual Studio Trace Files
+*.e2e
+
+# TFS 2012 Local Workspace
+$tf/
+
+# Guidance Automation Toolkit
+*.gpState
+
+# ReSharper is a .NET coding add-in
+_ReSharper*/
+*.[Rr]e[Ss]harper
+*.DotSettings.user
+
+# TeamCity is a build add-in
+_TeamCity*
+
+# DotCover is a Code Coverage Tool
+*.dotCover
+
+# AxoCover is a Code Coverage Tool
+.axoCover/*
+!.axoCover/settings.json
+
+# Coverlet is a free, cross platform Code Coverage Tool
+coverage*.json
+coverage*.xml
+coverage*.info
+
+# Visual Studio code coverage results
+*.coverage
+*.coveragexml
+
+# NCrunch
+_NCrunch_*
+.*crunch*.local.xml
+nCrunchTemp_*
+
+# MightyMoose
+*.mm.*
+AutoTest.Net/
+
+# Web workbench (sass)
+.sass-cache/
+
+# Installshield output folder
+[Ee]xpress/
+
+# DocProject is a documentation generator add-in
+DocProject/buildhelp/
+DocProject/Help/*.HxT
+DocProject/Help/*.HxC
+DocProject/Help/*.hhc
+DocProject/Help/*.hhk
+DocProject/Help/*.hhp
+DocProject/Help/Html2
+DocProject/Help/html
+
+# Click-Once directory
+publish/
+
+# Publish Web Output
+*.[Pp]ublish.xml
+*.azurePubxml
+# Note: Comment the next line if you want to checkin your web deploy settings,
+# but database connection strings (with potential passwords) will be unencrypted
+*.pubxml
+*.publishproj
+
+# Microsoft Azure Web App publish settings. Comment the next line if you want to
+# checkin your Azure Web App publish settings, but sensitive information contained
+# in these scripts will be unencrypted
+PublishScripts/
+
+# NuGet Packages
+*.nupkg
+# NuGet Symbol Packages
+*.snupkg
+# The packages folder can be ignored because of Package Restore
+**/[Pp]ackages/*
+# except build/, which is used as an MSBuild target.
+!**/[Pp]ackages/build/
+# Uncomment if necessary however generally it will be regenerated when needed
+#!**/[Pp]ackages/repositories.config
+# NuGet v3's project.json files produces more ignorable files
+*.nuget.props
+*.nuget.targets
+
+# Microsoft Azure Build Output
+csx/
+*.build.csdef
+
+# Microsoft Azure Emulator
+ecf/
+rcf/
+
+# Windows Store app package directories and files
+AppPackages/
+BundleArtifacts/
+Package.StoreAssociation.xml
+_pkginfo.txt
+*.appx
+*.appxbundle
+*.appxupload
+
+# Visual Studio cache files
+# files ending in .cache can be ignored
+*.[Cc]ache
+# but keep track of directories ending in .cache
+!?*.[Cc]ache/
+
+# Others
+ClientBin/
+~$*
+*~
+*.dbmdl
+*.dbproj.schemaview
+*.jfm
+*.pfx
+*.publishsettings
+orleans.codegen.cs
+
+# Including strong name files can present a security risk
+# (https://github.com/github/gitignore/pull/2483#issue-259490424)
+#*.snk
+
+# Since there are multiple workflows, uncomment next line to ignore bower_components
+# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
+#bower_components/
+
+# RIA/Silverlight projects
+Generated_Code/
+
+# Backup & report files from converting an old project file
+# to a newer Visual Studio version. Backup files are not needed,
+# because we have git ;-)
+_UpgradeReport_Files/
+Backup*/
+UpgradeLog*.XML
+UpgradeLog*.htm
+ServiceFabricBackup/
+*.rptproj.bak
+
+# SQL Server files
+*.mdf
+*.ldf
+*.ndf
+
+# Business Intelligence projects
+*.rdl.data
+*.bim.layout
+*.bim_*.settings
+*.rptproj.rsuser
+*- [Bb]ackup.rdl
+*- [Bb]ackup ([0-9]).rdl
+*- [Bb]ackup ([0-9][0-9]).rdl
+
+# Microsoft Fakes
+FakesAssemblies/
+
+# GhostDoc plugin setting file
+*.GhostDoc.xml
+
+# Node.js Tools for Visual Studio
+.ntvs_analysis.dat
+node_modules/
+
+# Visual Studio 6 build log
+*.plg
+
+# Visual Studio 6 workspace options file
+*.opt
+
+# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
+*.vbw
+
+# Visual Studio LightSwitch build output
+**/*.HTMLClient/GeneratedArtifacts
+**/*.DesktopClient/GeneratedArtifacts
+**/*.DesktopClient/ModelManifest.xml
+**/*.Server/GeneratedArtifacts
+**/*.Server/ModelManifest.xml
+_Pvt_Extensions
+
+# Paket dependency manager
+.paket/paket.exe
+paket-files/
+
+# FAKE - F# Make
+.fake/
+
+# CodeRush personal settings
+.cr/personal
+
+# Python Tools for Visual Studio (PTVS)
+__pycache__/
+*.pyc
+
+# Cake - Uncomment if you are using it
+# tools/**
+# !tools/packages.config
+
+# Tabs Studio
+*.tss
+
+# Telerik's JustMock configuration file
+*.jmconfig
+
+# BizTalk build output
+*.btp.cs
+*.btm.cs
+*.odx.cs
+*.xsd.cs
+
+# OpenCover UI analysis results
+OpenCover/
+
+# Azure Stream Analytics local run output
+ASALocalRun/
+
+# MSBuild Binary and Structured Log
+*.binlog
+
+# NVidia Nsight GPU debugger configuration file
+*.nvuser
+
+# MFractors (Xamarin productivity tool) working folder
+.mfractor/
+
+# Local History for Visual Studio
+.localhistory/
+
+# BeatPulse healthcheck temp database
+healthchecksdb
+
+# Backup folder for Package Reference Convert tool in Visual Studio 2017
+MigrationBackup/
+
+# Ionide (cross platform F# VS Code tools) working folder
+.ionide/
+
+# Fody - auto-generated XML schema
+FodyWeavers.xsd
\ No newline at end of file
diff --git a/Readme.md b/Readme.md
new file mode 100644
index 0000000..7c65fbc
--- /dev/null
+++ b/Readme.md
@@ -0,0 +1,209 @@
+
+
+##  **What is Rex?**
+
+Rex is a **social platform designed specifically for autodidacts** - self-directed learners who thrive on curiosity and peer collaboration. It's where passionate learners create **thematic study groups**, tackle **knowledge challenges**, and share their learning journeys with like-minded individuals.
+
+###  **Core Philosophy**
+> *"Learning is not a solo journey - it's a collaborative adventure where every question sparks discovery and every challenge builds wisdom."*
+
+##  **The Learning Ecosystem**
+
+###  **Study Groups**
+Users can create and join topic-focused learning communities:
+-  **Programming & Tech** - JavaScript, Python, AI/ML, DevOps
+-  **Creative Arts** - Digital design, photography, music production
+-  **Business & Finance** - Entrepreneurship, investing, marketing
+-  **Science & Research** - Data science, biology, physics
+-  **Languages & Culture** - Spanish, Japanese, cultural studies
+- *...and any topic imaginable*
+
+###  **Challenge System**
+Group leaders create engaging challenges that members can tackle:
+
+```
+ Challenge Example: "Build a REST API"
+  Objective: Create a user authentication API
+  Duration: 7 days
+  Resources: Documentation links, tutorials
+  Solution Sharing: Code + explanation of approach
+```
+
+###  **Knowledge Sharing**
+Members don't just submit solutions - they **explain their thinking**:
+-  **Problem-solving approach**
+-  **Tools and resources used**
+-  **Lessons learned**
+-  **Challenges faced**
+-  **Next steps for improvement**
+
+##  **Architecture**
+
+*Built with Clean Architecture principles for scalability and maintainability*
+
+```
+ Rex Learning Platform/
+
+  Rex.Domain/                    # Core Business Logic
+     Models/                   # Entities (User, Group, Challenge, Post, etc.)
+     Enum/                     # Domain enumerations
+     Configurations/          # Domain settings (JWT, Email)
+
+  Rex.Application/              # Application Layer
+     Interfaces/              # Repository & Service contracts
+       Repository/             # Data access interfaces
+       Services/               # Business service interfaces
+     Services/                # Business logic implementations
+     DTOs/                    # Data transfer objects
+     Utilities/              # Helper classes (Result pattern, Error handling)
+     Abstractions/           # CQRS patterns (Commands, Queries)
+
+  Rex.Infrastructure/          # External Concerns
+     Persistence/            # Data Access Layer
+       Repository/            # Repository implementations
+       Context/               # EF Core DbContext
+       Migrations/            # Database migrations
+       Services/              # Persistence services
+     Shared/                 # Cross-cutting concerns
+        Services/              # Authentication, Email services
+
+  Rex.Presentation.Api/        # API Layer
+      Controllers/             # REST API endpoints
+      ServicesExtension/       # Dependency injection setup
+```
+
+##  **Tech Stack**
+
+| Component | Technology | Purpose |
+|-----------|------------|----------|
+|  **Backend** | .NET 8 + ASP.NET Core Web API | Robust learning platform |
+|  **Database** | PostgreSQL + Entity Framework Core | Scalable data management |
+|  **Infrastructure** | Docker Compose | Development environment |
+|  **Monitoring** | Serilog + Seq | Structured logging and insights |
+|  **Security** | JWT + Refresh Tokens | Secure authentication system |
+|  **Database Tools** | pgAdmin | Database administration |
+
+---
+
+<div align="center">
+
+#  **Getting Started**
+
+*Launch Rex in just a few simple steps*
+
+</div>
+
+<br>
+
+<div align="center">
+
+###  **Prerequisites**
+
+Make sure you have **Docker Desktop** installed
+
+</div>
+
+<br>
+
+---
+
+<div align="center">
+
+##  **Environment Setup**
+
+*Configure Rex for your learning adventure*
+
+</div>
+
+<br>
+
+<div align="center">
+
+<table>
+<tr>
+<td width="33%" align="center">
+
+### 1
+<img src="https://img.shields.io/badge/Copy-Template-FF9500?style=for-the-badge&logo=files&logoColor=white" alt="Copy">
+
+**Copy Environment Template**
+
+```bash
+cp .env.template .env
+```
+
+</td>
+<td width="33%" align="center">
+
+### 2
+<img src="https://img.shields.io/badge/Configure-Variables-4CAF50?style=for-the-badge&logo=edit&logoColor=white" alt="Edit">
+
+**Edit Configuration**
+
+Open `.env` file and fill in your local environment values
+
+</td>
+<td width="33%" align="center">
+
+### 3
+<img src="https://img.shields.io/badge/Launch-Rex-2196F3?style=for-the-badge&logo=rocket&logoColor=white" alt="Launch">
+
+**Start the Platform**
+
+```bash
+docker compose up -d
+```
+
+</td>
+</tr>
+</table>
+
+</div>
+
+<br>
+
+<div align="center">
+
+
+
+###  **Welcome to Rex - Let the learning begin!**
+
+</div>
+
+---
+
+##  **Key Features**
+
+<table>
+<tr>
+<td width="50%">
+
+###  **For Learners**
+-  Join study groups by interest
+-  Participate in learning challenges
+-  Share solutions and explanations
+-  Connect with fellow autodidacts
+
+</td>
+<td width="50%">
+
+###  **For Group Leaders**
+-  Create themed study groups
+-  Design engaging challenges
+-  Curate learning resources
+-  Monitor group progress
+-  Manage group dynamics
+
+</td>
+</tr>
+</table>
+
+
+
+---
+
+<div align="center">
+  <strong>Built by learners, for learners </strong><br>
+  <sub>Rex - Where autodidacts become unstoppable </sub><br><br>
+  <em>"The best way to learn is to teach, and the best way to teach is to challenge."</em>
+</div>
\ No newline at end of file
diff --git a/Rex.Application/Abstractions/Messages/ICommand.cs b/Rex.Application/Abstractions/Messages/ICommand.cs
new file mode 100644
index 0000000..a37329b
--- /dev/null
+++ b/Rex.Application/Abstractions/Messages/ICommand.cs
@@ -0,0 +1,10 @@
+using MediatR;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Abstractions.Messages;
+
+public interface ICommand : IRequest<Result>, IBaseCommand;
+
+public interface ICommand<TResponse> : IRequest<ResultT<TResponse>>, IBaseCommand;
+
+public interface IBaseCommand;
\ No newline at end of file
diff --git a/Rex.Application/Abstractions/Messages/ICommandHandler.cs b/Rex.Application/Abstractions/Messages/ICommandHandler.cs
new file mode 100644
index 0000000..5b7cfd7
--- /dev/null
+++ b/Rex.Application/Abstractions/Messages/ICommandHandler.cs
@@ -0,0 +1,12 @@
+using MediatR;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Abstractions.Messages;
+
+public interface ICommandHandler<in TCommand> : 
+    IRequestHandler<TCommand, Result> 
+    where TCommand : ICommand;
+
+public interface ICommandHandler<in TCommand, TResponse> :
+    IRequestHandler<TCommand, ResultT<TResponse>> 
+    where TCommand : ICommand<TResponse>; 
\ No newline at end of file
diff --git a/Rex.Application/Abstractions/Messages/IQuery.cs b/Rex.Application/Abstractions/Messages/IQuery.cs
new file mode 100644
index 0000000..ba95d61
--- /dev/null
+++ b/Rex.Application/Abstractions/Messages/IQuery.cs
@@ -0,0 +1,6 @@
+using MediatR;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Abstractions.Messages;
+
+public interface IQuery<TResponse>: IRequest<ResultT<TResponse>>;
\ No newline at end of file
diff --git a/Rex.Application/Abstractions/Messages/IQueryHandler.cs b/Rex.Application/Abstractions/Messages/IQueryHandler.cs
new file mode 100644
index 0000000..3267487
--- /dev/null
+++ b/Rex.Application/Abstractions/Messages/IQueryHandler.cs
@@ -0,0 +1,8 @@
+using MediatR;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Abstractions.Messages;
+
+public interface IQueryHandler<in TQuery, TResponse> : 
+    IRequestHandler<TQuery, ResultT<TResponse>>
+    where TQuery : IQuery<TResponse>;
\ No newline at end of file
diff --git a/Rex.Application/Behavior/ValidationBehavior.cs b/Rex.Application/Behavior/ValidationBehavior.cs
new file mode 100644
index 0000000..99d46da
--- /dev/null
+++ b/Rex.Application/Behavior/ValidationBehavior.cs
@@ -0,0 +1,32 @@
+using FluentValidation;
+using MediatR;
+
+namespace Rex.Application.Behavior;
+
+public class ValidationBehavior<TRequest, TResponse>(IEnumerable<IValidator<TRequest>> validators):
+    IPipelineBehavior<TRequest, TResponse>
+    where TRequest : class
+{
+    public async Task<TResponse> Handle(TRequest request, RequestHandlerDelegate<TResponse> next, CancellationToken cancellationToken)
+    {
+        ArgumentNullException.ThrowIfNull(request);
+
+        if (validators.Any())
+        {
+            var context = new ValidationContext<TRequest>(request);
+            var validationResults = await Task.WhenAll(validators
+                .Select(v => v.ValidateAsync(context, cancellationToken)))
+                .ConfigureAwait(false);
+
+            var failures = validationResults
+                .Where(v => v.Errors.Count > 0)
+                .SelectMany(s => s.Errors)
+                .ToList();
+            
+            if(failures.Count >0)
+                throw new ValidationException(failures);
+        }
+        
+        return await next().ConfigureAwait(false);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Challenge/ChallengeDetailsDto.cs b/Rex.Application/DTOs/Challenge/ChallengeDetailsDto.cs
new file mode 100644
index 0000000..52bd7c7
--- /dev/null
+++ b/Rex.Application/DTOs/Challenge/ChallengeDetailsDto.cs
@@ -0,0 +1,10 @@
+namespace Rex.Application.DTOs.Challenge;
+
+public record ChallengeDetailsDto(
+    Guid ChallengeId,
+    string Title,
+    string Description,
+    string Status,
+    string CoverPhoto,
+    TimeSpan Duration
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Challenge/ChallengeGroupDetailsDto.cs b/Rex.Application/DTOs/Challenge/ChallengeGroupDetailsDto.cs
new file mode 100644
index 0000000..956ac24
--- /dev/null
+++ b/Rex.Application/DTOs/Challenge/ChallengeGroupDetailsDto.cs
@@ -0,0 +1,12 @@
+namespace Rex.Application.DTOs.Challenge;
+
+public record ChallengeGroupDetailsDto(
+    Guid ChallengeId,
+    string Title,
+    string Description,
+    string Status,
+    string CoverPhoto,
+    TimeSpan Duration,
+    List<string> UserProfilePhotos,
+    int TotalParticipants
+        );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Challenge/ChallengeUserDetailsDto.cs b/Rex.Application/DTOs/Challenge/ChallengeUserDetailsDto.cs
new file mode 100644
index 0000000..26750f9
--- /dev/null
+++ b/Rex.Application/DTOs/Challenge/ChallengeUserDetailsDto.cs
@@ -0,0 +1,14 @@
+namespace Rex.Application.DTOs.Challenge;
+
+public record ChallengeUserDetailsDto(
+    Guid ChallengeId,
+    string ProfilePhoto,
+    string CoverPhoto,
+    string Title,
+    string Description,
+    string Status,
+    TimeSpan Duration,
+    string GroupTitle,
+    List<string> UserProfilePhotos,
+    int TotalParticipants
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Challenge/CreateChallengeDto.cs b/Rex.Application/DTOs/Challenge/CreateChallengeDto.cs
new file mode 100644
index 0000000..acd55d9
--- /dev/null
+++ b/Rex.Application/DTOs/Challenge/CreateChallengeDto.cs
@@ -0,0 +1,11 @@
+using Microsoft.AspNetCore.Http;
+
+namespace Rex.Application.DTOs.Challenge;
+
+public record CreateChallengeDto(
+    Guid GroupId,
+    string Title,
+    string Description,
+    TimeSpan Duration,
+    IFormFile CoverPhoto
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Challenge/UpdateChallengeDto.cs b/Rex.Application/DTOs/Challenge/UpdateChallengeDto.cs
new file mode 100644
index 0000000..9118ad1
--- /dev/null
+++ b/Rex.Application/DTOs/Challenge/UpdateChallengeDto.cs
@@ -0,0 +1,11 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Enum;
+
+namespace Rex.Application.DTOs.Challenge;
+
+public record UpdateChallengeDto(
+    string Title,
+    string Description,
+    TimeSpan Duration,
+    ChallengeStatus Status
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Chat/ChatDto.cs b/Rex.Application/DTOs/Chat/ChatDto.cs
new file mode 100644
index 0000000..b7cd397
--- /dev/null
+++ b/Rex.Application/DTOs/Chat/ChatDto.cs
@@ -0,0 +1,8 @@
+namespace Rex.Application.DTOs.Challenge;
+
+public record ChatDto(
+    Guid Id,
+    string? Name,
+    string Type,
+    string ProfilePicture
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Chat/ChatLastMessageDto.cs b/Rex.Application/DTOs/Chat/ChatLastMessageDto.cs
new file mode 100644
index 0000000..f2ceb92
--- /dev/null
+++ b/Rex.Application/DTOs/Chat/ChatLastMessageDto.cs
@@ -0,0 +1,11 @@
+using Rex.Application.DTOs.Message;
+
+namespace Rex.Application.DTOs.Challenge;
+
+public record ChatLastMessageDto(
+    Guid Id,
+    string? Name,
+    string Type,
+    string ProfilePicture,
+    LastMessageDto? LastMessage
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Code/CodeDto.cs b/Rex.Application/DTOs/Code/CodeDto.cs
new file mode 100644
index 0000000..9ba91b2
--- /dev/null
+++ b/Rex.Application/DTOs/Code/CodeDto.cs
@@ -0,0 +1,10 @@
+namespace Rex.Application.DTOs.Code;
+
+public record CodeDto
+(
+    Guid UserId,
+    Guid CodeId,
+    string Code,
+    bool IsUsed,
+    DateTime Expiration
+);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Code/ConfirmAccountDto.cs b/Rex.Application/DTOs/Code/ConfirmAccountDto.cs
new file mode 100644
index 0000000..f83b9ca
--- /dev/null
+++ b/Rex.Application/DTOs/Code/ConfirmAccountDto.cs
@@ -0,0 +1,3 @@
+namespace Rex.Application.DTOs.Code;
+
+public record ConfirmAccountDto(string Code);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Code/ConfirmEmailCodeDto.cs b/Rex.Application/DTOs/Code/ConfirmEmailCodeDto.cs
new file mode 100644
index 0000000..c9120f2
--- /dev/null
+++ b/Rex.Application/DTOs/Code/ConfirmEmailCodeDto.cs
@@ -0,0 +1,3 @@
+namespace Rex.Application.DTOs.Code;
+
+public record ConfirmEmailCodeDto(string Code);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Comment/CommentDetailsDto.cs b/Rex.Application/DTOs/Comment/CommentDetailsDto.cs
new file mode 100644
index 0000000..fd8cd10
--- /dev/null
+++ b/Rex.Application/DTOs/Comment/CommentDetailsDto.cs
@@ -0,0 +1,17 @@
+using Rex.Application.DTOs.File;
+using Rex.Application.DTOs.Reply;
+using Rex.Application.DTOs.User;
+
+namespace Rex.Application.DTOs.Comment;
+
+public record CommentDetailsDto(
+    Guid CommentId,
+    Guid PostId,
+    string Description,
+    bool IsPinned,
+    bool Edited,
+    bool HasReplies,
+    UserCommentDetailsDto User,
+    DateTime CreatedAt,
+    IEnumerable<FileDetailDto>? Files = null
+    );
diff --git a/Rex.Application/DTOs/Comment/CommentDto.cs b/Rex.Application/DTOs/Comment/CommentDto.cs
new file mode 100644
index 0000000..1209343
--- /dev/null
+++ b/Rex.Application/DTOs/Comment/CommentDto.cs
@@ -0,0 +1,13 @@
+using Microsoft.AspNetCore.Http;
+
+namespace Rex.Application.DTOs.Comment;
+
+public record CommentDto(
+    Guid CommentId,
+    Guid PostId,
+    Guid UserId,
+    string Description,
+    bool IsPinned,
+    bool Edited,
+    IEnumerable<Models.File>? Files = null
+        );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Comment/CommentUpdatedDto.cs b/Rex.Application/DTOs/Comment/CommentUpdatedDto.cs
new file mode 100644
index 0000000..941954f
--- /dev/null
+++ b/Rex.Application/DTOs/Comment/CommentUpdatedDto.cs
@@ -0,0 +1,11 @@
+using Rex.Application.DTOs.File;
+
+namespace Rex.Application.DTOs.Comment;
+
+public record CommentUpdatedDto(
+    Guid CommentId,
+    string Description,
+    bool IsPinned,
+    bool Edited,
+    IEnumerable<FileDetailDto>? Files = null
+        );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Comment/CreateCommentDto.cs b/Rex.Application/DTOs/Comment/CreateCommentDto.cs
new file mode 100644
index 0000000..7acadae
--- /dev/null
+++ b/Rex.Application/DTOs/Comment/CreateCommentDto.cs
@@ -0,0 +1,9 @@
+using Microsoft.AspNetCore.Http;
+
+namespace Rex.Application.DTOs.Comment;
+
+public record CreateCommentDto(
+    Guid PostId,
+    string Description,
+    IEnumerable<IFormFile>? Files = null
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Comment/CreateCommentReplyDto.cs b/Rex.Application/DTOs/Comment/CreateCommentReplyDto.cs
new file mode 100644
index 0000000..4f724ce
--- /dev/null
+++ b/Rex.Application/DTOs/Comment/CreateCommentReplyDto.cs
@@ -0,0 +1,10 @@
+using Microsoft.AspNetCore.Http;
+
+namespace Rex.Application.DTOs.Comment;
+
+public record CreateCommentReplyDto(
+    Guid ParentCommentId,
+    Guid PostId,
+    string Description,
+    IEnumerable<IFormFile>? Files = null 
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Comment/PinCommentDto.cs b/Rex.Application/DTOs/Comment/PinCommentDto.cs
new file mode 100644
index 0000000..6c34d01
--- /dev/null
+++ b/Rex.Application/DTOs/Comment/PinCommentDto.cs
@@ -0,0 +1,7 @@
+namespace Rex.Application.DTOs.Comment;
+
+public record PinCommentDto(
+    Guid CommentId,
+    Guid PostId,
+    bool Pin
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Configs/EmailDto.cs b/Rex.Application/DTOs/Configs/EmailDto.cs
new file mode 100644
index 0000000..083c745
--- /dev/null
+++ b/Rex.Application/DTOs/Configs/EmailDto.cs
@@ -0,0 +1,7 @@
+namespace Rex.Application.DTOs.Configs;
+
+public record EmailDto(
+    string User,
+    string Body,
+    string Subject
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Configs/ProblemDetailsDto.cs b/Rex.Application/DTOs/Configs/ProblemDetailsDto.cs
new file mode 100644
index 0000000..2b0537d
--- /dev/null
+++ b/Rex.Application/DTOs/Configs/ProblemDetailsDto.cs
@@ -0,0 +1,12 @@
+namespace Rex.Application.DTOs.Configs;
+
+public record ProblemDetailsDto(
+    bool HasError, 
+    string? Message = null, 
+    int? Code = null, 
+    string? Details = null, 
+    Dictionary<string, string[]>? Errors = null)
+{
+    public static ProblemDetailsDto Fail(string message, int code, string? details = null, Dictionary<string, string[]>? errors = null)
+        => new ProblemDetailsDto(true, message, code, details, errors);
+};
\ No newline at end of file
diff --git a/Rex.Application/DTOs/File/FileDetailDto.cs b/Rex.Application/DTOs/File/FileDetailDto.cs
new file mode 100644
index 0000000..f1e6991
--- /dev/null
+++ b/Rex.Application/DTOs/File/FileDetailDto.cs
@@ -0,0 +1,3 @@
+namespace Rex.Application.DTOs.File;
+
+public record FileDetailDto(Guid Id, string Url, string Type);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Friendship/FriendshipRequestDto.cs b/Rex.Application/DTOs/Friendship/FriendshipRequestDto.cs
new file mode 100644
index 0000000..da97bdb
--- /dev/null
+++ b/Rex.Application/DTOs/Friendship/FriendshipRequestDto.cs
@@ -0,0 +1,10 @@
+namespace Rex.Application.DTOs.Friendship;
+
+public record FriendshipRequestDto(
+    Guid FriendshipId,
+    Guid UserId,
+    string FullName,
+    string Status,
+    string ProfilePictureUrl,
+    DateTime RequestedAt
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Friendship/UpdateFriendshipStatusDto.cs b/Rex.Application/DTOs/Friendship/UpdateFriendshipStatusDto.cs
new file mode 100644
index 0000000..afe6c08
--- /dev/null
+++ b/Rex.Application/DTOs/Friendship/UpdateFriendshipStatusDto.cs
@@ -0,0 +1,7 @@
+using Rex.Enum;
+
+namespace Rex.Application.DTOs.Friendship;
+
+public record UpdateFriendshipStatusDto(
+    ManageRequestStatus Status
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Group/CreateGroupDto.cs b/Rex.Application/DTOs/Group/CreateGroupDto.cs
new file mode 100644
index 0000000..e01a69d
--- /dev/null
+++ b/Rex.Application/DTOs/Group/CreateGroupDto.cs
@@ -0,0 +1,12 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Enum;
+
+namespace Rex.Application.DTOs.Group;
+
+public record CreateGroupDto(
+    IFormFile ProfilePhoto,
+    IFormFile? CoverPhoto,
+    string Title,
+    string Description,
+    GroupVisibility Visibility
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Group/GetGroupMembersRequestDto.cs b/Rex.Application/DTOs/Group/GetGroupMembersRequestDto.cs
new file mode 100644
index 0000000..f1402dc
--- /dev/null
+++ b/Rex.Application/DTOs/Group/GetGroupMembersRequestDto.cs
@@ -0,0 +1,6 @@
+using Rex.Enum;
+
+namespace Rex.Application.DTOs.Group;
+
+public record GetGroupMembersRequestDto(string? SearchTerm,
+    GroupRole? RoleFilter);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Group/GroupDetailsDto.cs b/Rex.Application/DTOs/Group/GroupDetailsDto.cs
new file mode 100644
index 0000000..82ff504
--- /dev/null
+++ b/Rex.Application/DTOs/Group/GroupDetailsDto.cs
@@ -0,0 +1,12 @@
+namespace Rex.Application.DTOs.Group;
+
+public record GroupDetailsDto(
+    Guid GroupId,
+    string ProfilePicture,
+    string CoverPicture,
+    string Title,
+    string Description,
+    string Visibility,
+    int MemberCount,
+    bool IsJoined
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Group/GroupUserModerationDto.cs b/Rex.Application/DTOs/Group/GroupUserModerationDto.cs
new file mode 100644
index 0000000..9dfd815
--- /dev/null
+++ b/Rex.Application/DTOs/Group/GroupUserModerationDto.cs
@@ -0,0 +1,5 @@
+using Rex.Enum;
+
+namespace Rex.Application.DTOs.Group;
+
+public record GroupUserModerationDto(GroupUserModerationStatus Status);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Group/ManageRequestStatusDto.cs b/Rex.Application/DTOs/Group/ManageRequestStatusDto.cs
new file mode 100644
index 0000000..3be99d6
--- /dev/null
+++ b/Rex.Application/DTOs/Group/ManageRequestStatusDto.cs
@@ -0,0 +1,7 @@
+using Rex.Enum;
+
+namespace Rex.Application.DTOs.Group;
+
+public record ManageRequestStatusDto(
+    ManageRequestStatus Status
+);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Group/UpdateGroupDto.cs b/Rex.Application/DTOs/Group/UpdateGroupDto.cs
new file mode 100644
index 0000000..b8cb8ed
--- /dev/null
+++ b/Rex.Application/DTOs/Group/UpdateGroupDto.cs
@@ -0,0 +1,12 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Enum;
+
+namespace Rex.Application.DTOs.Group;
+
+public record UpdateGroupDto(
+    IFormFile? ProfilePhoto,
+    IFormFile? CoverPhoto,
+    string? Title,
+    string? Description,
+    GroupVisibility? Visibility
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Group/UpdateRoleMemberdto.cs b/Rex.Application/DTOs/Group/UpdateRoleMemberdto.cs
new file mode 100644
index 0000000..ad0e333
--- /dev/null
+++ b/Rex.Application/DTOs/Group/UpdateRoleMemberdto.cs
@@ -0,0 +1,5 @@
+using Rex.Enum;
+
+namespace Rex.Application.DTOs.Group;
+
+public record UpdateRoleMemberdto(GroupRole Role );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/JWT/GithubResponseDto.cs b/Rex.Application/DTOs/JWT/GithubResponseDto.cs
new file mode 100644
index 0000000..1d4ac1f
--- /dev/null
+++ b/Rex.Application/DTOs/JWT/GithubResponseDto.cs
@@ -0,0 +1,7 @@
+namespace Rex.Application.DTOs.JWT;
+
+public record GithubResponseDto(
+    string AccessToken,
+    string RefreshToken,
+    Guid UserId
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/JWT/RefreshTokenDto.cs b/Rex.Application/DTOs/JWT/RefreshTokenDto.cs
new file mode 100644
index 0000000..86bb5fa
--- /dev/null
+++ b/Rex.Application/DTOs/JWT/RefreshTokenDto.cs
@@ -0,0 +1,3 @@
+namespace Rex.Application.DTOs.JWT;
+
+public record RefreshTokenDto(string refreshToken);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/JWT/ResponseDto.cs b/Rex.Application/DTOs/JWT/ResponseDto.cs
new file mode 100644
index 0000000..0b3a83a
--- /dev/null
+++ b/Rex.Application/DTOs/JWT/ResponseDto.cs
@@ -0,0 +1,3 @@
+namespace Rex.Application.DTOs.JWT;
+
+public record ResponseDto(string Message);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/JWT/TokenResponseDto.cs b/Rex.Application/DTOs/JWT/TokenResponseDto.cs
new file mode 100644
index 0000000..b3afc72
--- /dev/null
+++ b/Rex.Application/DTOs/JWT/TokenResponseDto.cs
@@ -0,0 +1,6 @@
+namespace Rex.Application.DTOs.JWT;
+
+public record TokenResponseDto(
+    string AccessToken,
+    string RefreshToken
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Message/LastMessageDto.cs b/Rex.Application/DTOs/Message/LastMessageDto.cs
new file mode 100644
index 0000000..8649443
--- /dev/null
+++ b/Rex.Application/DTOs/Message/LastMessageDto.cs
@@ -0,0 +1,10 @@
+namespace Rex.Application.DTOs.Message;
+
+public record LastMessageDto(
+    Guid MessageId,
+    string Description,
+    DateTime CreatedAt,
+    Guid SenderId,
+    string SenderName,
+    string SenderProfilePhoto
+);
diff --git a/Rex.Application/DTOs/Message/MessageDto.cs b/Rex.Application/DTOs/Message/MessageDto.cs
new file mode 100644
index 0000000..2457593
--- /dev/null
+++ b/Rex.Application/DTOs/Message/MessageDto.cs
@@ -0,0 +1,14 @@
+using Rex.Application.DTOs.File;
+
+namespace Rex.Application.DTOs.Message;
+
+public record MessageDto(
+    Guid MessageId,
+    Guid ChatId,
+    Guid SenderId,
+    string Name,
+    string ProfilePicture,
+    string Description,
+    DateTime CreatedAt,
+    IEnumerable<FileDetailDto>? Files = null
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Message/SendFileMessageDto.cs b/Rex.Application/DTOs/Message/SendFileMessageDto.cs
new file mode 100644
index 0000000..0b881fe
--- /dev/null
+++ b/Rex.Application/DTOs/Message/SendFileMessageDto.cs
@@ -0,0 +1,9 @@
+using Microsoft.AspNetCore.Http;
+
+namespace Rex.Application.DTOs.Message;
+
+public record SendFileMessageDto(
+    Guid ChatId,
+    string? Message,
+    List<IFormFile> Files
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Notification/NotificationDto.cs b/Rex.Application/DTOs/Notification/NotificationDto.cs
new file mode 100644
index 0000000..f63c235
--- /dev/null
+++ b/Rex.Application/DTOs/Notification/NotificationDto.cs
@@ -0,0 +1,13 @@
+namespace Rex.Application.DTOs.Notification;
+
+public record NotificationDto(
+    Guid Id,
+    string Title,
+    string Description,
+    Guid UserId,
+    string RecipientType,
+    Guid RecipientId,
+    string MetadataJson,
+    DateTime CreatedAt,
+    bool IsRead = false
+);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Post/CreatePostDto.cs b/Rex.Application/DTOs/Post/CreatePostDto.cs
new file mode 100644
index 0000000..ae0ba93
--- /dev/null
+++ b/Rex.Application/DTOs/Post/CreatePostDto.cs
@@ -0,0 +1,11 @@
+using Microsoft.AspNetCore.Http;
+
+namespace Rex.Application.DTOs.Post;
+
+public record CreatePostDto(
+    Guid GroupId,
+    Guid? ChallengeId,
+    string Title,
+    string Description,
+    List<IFormFile>? Files = null
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Post/PostDetailsDto.cs b/Rex.Application/DTOs/Post/PostDetailsDto.cs
new file mode 100644
index 0000000..37d1e2e
--- /dev/null
+++ b/Rex.Application/DTOs/Post/PostDetailsDto.cs
@@ -0,0 +1,19 @@
+using Rex.Application.DTOs.File;
+
+namespace Rex.Application.DTOs.Post;
+
+public record PostDetailsDto(
+    Guid PostId,
+    Guid AuthorId,
+    Guid GroupId,
+    string AuthorName,
+    string Title,
+    string Description,
+    string ProfilePhoto,
+    int LikeCount,
+    int CommentCount,
+    bool HasLiked,             
+    DateTime CreatedAt,
+    bool HasCompletedChallenge,
+    List<FileDetailDto> Files
+);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/Reaction/LikeChangedDto.cs b/Rex.Application/DTOs/Reaction/LikeChangedDto.cs
new file mode 100644
index 0000000..86cfecd
--- /dev/null
+++ b/Rex.Application/DTOs/Reaction/LikeChangedDto.cs
@@ -0,0 +1,8 @@
+namespace Rex.Application.DTOs.Reaction;
+
+public record LikeChangedDto(
+    Guid PostId,
+    int TotalLikes,
+    Guid UserId,
+    bool Liked
+);
diff --git a/Rex.Application/DTOs/Reply/ReplyDto.cs b/Rex.Application/DTOs/Reply/ReplyDto.cs
new file mode 100644
index 0000000..e09fb18
--- /dev/null
+++ b/Rex.Application/DTOs/Reply/ReplyDto.cs
@@ -0,0 +1,14 @@
+using Rex.Application.DTOs.File;
+using Rex.Application.DTOs.User;
+
+namespace Rex.Application.DTOs.Reply;
+
+public record ReplyDto(
+    Guid ReplyId,
+    Guid ParentCommentId,
+    string Description,
+    bool Edited,
+    bool? HasReplies,
+    UserCommentDetailsDto User,
+    DateTime CreatedAt,
+    IEnumerable<FileDetailDto>? Files = null);
diff --git a/Rex.Application/DTOs/User/RegisterUserDto.cs b/Rex.Application/DTOs/User/RegisterUserDto.cs
new file mode 100644
index 0000000..8fd3360
--- /dev/null
+++ b/Rex.Application/DTOs/User/RegisterUserDto.cs
@@ -0,0 +1,14 @@
+namespace Rex.Application.DTOs.User;
+
+public record RegisterUserDto(
+    Guid UserId,
+    string FirstName,
+    string LastName,
+    string UserName,
+    string Email,
+    string ProfilePhoto,
+    string? CoverPhoto,
+    string? Biography,
+    string Gender,
+    DateTime Birthday
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/User/UpdateEmailDto.cs b/Rex.Application/DTOs/User/UpdateEmailDto.cs
new file mode 100644
index 0000000..4c31b59
--- /dev/null
+++ b/Rex.Application/DTOs/User/UpdateEmailDto.cs
@@ -0,0 +1,3 @@
+namespace Rex.Application.DTOs.User;
+
+public record UpdateEmailDto(string Email, string NewEmail);
diff --git a/Rex.Application/DTOs/User/UpdatePasswordDto.cs b/Rex.Application/DTOs/User/UpdatePasswordDto.cs
new file mode 100644
index 0000000..fa1d803
--- /dev/null
+++ b/Rex.Application/DTOs/User/UpdatePasswordDto.cs
@@ -0,0 +1,6 @@
+namespace Rex.Application.DTOs.User;
+
+public record UpdatePasswordDto(
+    string CurrentPassword,
+    string NewPassword
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/User/UpdateUserInformationDto.cs b/Rex.Application/DTOs/User/UpdateUserInformationDto.cs
new file mode 100644
index 0000000..b6817a3
--- /dev/null
+++ b/Rex.Application/DTOs/User/UpdateUserInformationDto.cs
@@ -0,0 +1,10 @@
+using Microsoft.AspNetCore.Http;
+
+namespace Rex.Application.DTOs.User;
+
+public record UpdateUserInformationDto(
+    IFormFile? ProfilePhoto,
+    string? Firstname,
+    string? Lastname,
+    string? Biography
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/User/UpdateUsernameDto.cs b/Rex.Application/DTOs/User/UpdateUsernameDto.cs
new file mode 100644
index 0000000..46d160b
--- /dev/null
+++ b/Rex.Application/DTOs/User/UpdateUsernameDto.cs
@@ -0,0 +1,3 @@
+namespace Rex.Application.DTOs.User;
+
+public record UpdateUsernameDto(string Username);
\ No newline at end of file
diff --git a/Rex.Application/DTOs/User/UserCommentDetailsDto.cs b/Rex.Application/DTOs/User/UserCommentDetailsDto.cs
new file mode 100644
index 0000000..1b88e41
--- /dev/null
+++ b/Rex.Application/DTOs/User/UserCommentDetailsDto.cs
@@ -0,0 +1,8 @@
+namespace Rex.Application.DTOs.User;
+
+public record UserCommentDetailsDto(
+    Guid UserId,
+    string Name,
+    string Lastname,
+    string ProfilePhoto
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/User/UserGroupDetailsDto.cs b/Rex.Application/DTOs/User/UserGroupDetailsDto.cs
new file mode 100644
index 0000000..d3d99a8
--- /dev/null
+++ b/Rex.Application/DTOs/User/UserGroupDetailsDto.cs
@@ -0,0 +1,9 @@
+namespace Rex.Application.DTOs.User;
+
+public record UserGroupDetailsDto(
+    Guid UserId,
+    string Name,
+    string Lastname,
+    string Role,
+    string ProfilePhoto
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/User/UserGroupRequestDto.cs b/Rex.Application/DTOs/User/UserGroupRequestDto.cs
new file mode 100644
index 0000000..fa29213
--- /dev/null
+++ b/Rex.Application/DTOs/User/UserGroupRequestDto.cs
@@ -0,0 +1,9 @@
+namespace Rex.Application.DTOs.User;
+
+public record UserGroupRequestDto(
+    string FirstName,
+    string LastName,
+    string ProfilePicture,
+    string Status,
+    TimeSpan TimeSinceRequested 
+    );
\ No newline at end of file
diff --git a/Rex.Application/DTOs/User/UserProfileDto.cs b/Rex.Application/DTOs/User/UserProfileDto.cs
new file mode 100644
index 0000000..e4427d5
--- /dev/null
+++ b/Rex.Application/DTOs/User/UserProfileDto.cs
@@ -0,0 +1,18 @@
+namespace Rex.Application.DTOs.User;
+
+public record UserProfileDto(
+    string FirstName,
+    string LastName,
+    string Email,
+    string UserName,
+    string ProfilePhoto,
+    string? CoverPhoto,
+    DateTime Birthday,
+    DateTime CreatedAt,
+    string? Biography,
+    string Gender,
+    DateTime? LastLoginAt,
+    int GroupsCount,
+    int LikesCount,
+    int ChallengesCount
+    );
\ No newline at end of file
diff --git a/Rex.Application/DependecyInjection.cs b/Rex.Application/DependecyInjection.cs
new file mode 100644
index 0000000..3362c62
--- /dev/null
+++ b/Rex.Application/DependecyInjection.cs
@@ -0,0 +1,37 @@
+using System.Reflection;
+using FluentValidation;
+using Microsoft.Extensions.Configuration;
+using Microsoft.Extensions.DependencyInjection;
+using Rex.Application.Behavior;
+using Rex.Application.Interfaces;
+using Rex.Application.Services;
+
+namespace Rex.Application;
+
+public static class DependecyInjection
+{
+    public static void AddApplicationLayer(this IServiceCollection services, IConfiguration configuration)
+    {
+        services.AddValidatorsFromAssembly(Assembly.GetExecutingAssembly());
+        services.AddMediatR(config =>
+        {
+            config.RegisterServicesFromAssemblies(Assembly.GetExecutingAssembly());
+            config.AddOpenBehavior(typeof(ValidationBehavior<,>));
+        });
+
+        services.AddProblemDetails();
+        
+        #region Services
+
+        services.AddScoped<ICodeService, CodeService>();
+        services.AddScoped<IMessageService, MessageService>();
+        services.AddScoped<IWarnUserService, WarnUserService>();
+        services.AddScoped<IRemoveUserService, RemoveUserService>();
+        services.AddScoped<IChallengeExpirationService, ChallengeExpirationService>();
+        services.AddScoped<IUserInGroupService, UserInGroupService>();
+        
+        #endregion
+
+        services.AddHttpContextAccessor();
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Helpers/InactivityThresholds.cs b/Rex.Application/Helpers/InactivityThresholds.cs
new file mode 100644
index 0000000..0028c04
--- /dev/null
+++ b/Rex.Application/Helpers/InactivityThresholds.cs
@@ -0,0 +1,7 @@
+namespace Rex.Application.Helpers;
+
+public static class InactivityThresholds
+{
+    public const int WarningDays = 10;
+    public const int RemovalDays = 20;
+}
\ No newline at end of file
diff --git a/Rex.Application/Helpers/ProcessFiles.cs b/Rex.Application/Helpers/ProcessFiles.cs
new file mode 100644
index 0000000..7096a0d
--- /dev/null
+++ b/Rex.Application/Helpers/ProcessFiles.cs
@@ -0,0 +1,81 @@
+using Microsoft.AspNetCore.Http;
+using Microsoft.Extensions.Logging;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Helpers;
+
+public static class ProcessFiles
+{
+    public static async Task<ResultT<ResponseDto>> ProcessFilesAsync(
+        ILogger logger,
+        IEnumerable<IFormFile> files,
+        Guid entityId,
+        IFileRepository fileRepository,
+        IEntityFileRepository entityFileRepository,
+        ICloudinaryService cloudinaryService,
+        TargetType targetType,
+        CancellationToken cancellationToken)
+    {
+        var tasks = files.Select(async file =>
+        {
+            await using var stream = file.OpenReadStream();
+
+            FileType? fileType = file.ContentType switch
+            {
+                var s when s.StartsWith("image/") => FileType.Image,
+                var s when s.StartsWith("video/") => FileType.Video,
+                "application/pdf" => FileType.Archive,
+                _ => null
+            };
+
+            if (fileType is null)
+            {
+                logger.LogWarning("File type not supported: '{FileName}'", file.FileName);
+                return false; 
+            }
+
+            string url = fileType switch
+            {
+                FileType.Image   => await cloudinaryService.UploadImageAsync(stream, file.FileName, cancellationToken),
+                FileType.Video   => await cloudinaryService.UploadVideoAsync(stream, file.FileName, cancellationToken),
+                FileType.Archive => await cloudinaryService.UploadArchiveAsync(stream, file.FileName, cancellationToken)
+                
+            };
+
+            var newFile = new Models.File
+            {
+                Id = Guid.NewGuid(),
+                Url = url,
+                Type = fileType.ToString(),
+                UploadedAt = DateTime.UtcNow
+            };
+            
+            await fileRepository.CreateAsync(newFile, cancellationToken);
+
+            var entityFile = new EntityFile
+            {
+                Id = Guid.NewGuid(),
+                FileId = newFile.Id,
+                TargetId = entityId,
+                TargetType = targetType.ToString()
+            };
+            await entityFileRepository.CreateAsync(entityFile, cancellationToken);
+
+            logger.LogInformation("File '{FileName}' uploaded successfully!", file.FileName);
+            return true; 
+        });
+
+        var results = await Task.WhenAll(tasks);
+
+        if (results.Any(r => !r))
+            return ResultT<ResponseDto>.Failure(Error.Failure("415",
+                "Some files could not be processed. Only images and videos are allowed."));
+
+        return ResultT<ResponseDto>.Success(new ResponseDto("All your files have been uploaded successfully!"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IChallengeRepository.cs b/Rex.Application/Interfaces/Repository/IChallengeRepository.cs
new file mode 100644
index 0000000..abf72c3
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IChallengeRepository.cs
@@ -0,0 +1,77 @@
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with challenges in the database.
+    /// </summary>
+    public interface IChallengeRepository : IGenericRepository<Challenge>
+    {
+        /// <summary>
+        /// Gets a paginated list of challenges by group ID and challenge status.
+        /// </summary>
+        /// <param name="groupId">The ID of the group the challenges belong to.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="status">The status of the challenge.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of challenges that match the criteria.</returns>
+        Task<PagedResult<Challenge>> GetChallengesPaginatedByGroupIdAndStatusAsync(Guid groupId, int page, int size,
+            ChallengeStatus status,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Gets a paginated list of challenges based on user participation in a group and challenge status.
+        /// </summary>
+        /// <param name="userId">The user ID.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="groupId">The group ID.</param>
+        /// <param name="status">The user's participation status in the challenge.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of challenges with the user's participation.</returns>
+        Task<PagedResult<Challenge>> GetChallengesPaginatedByUserParticipationGroupAndStatusAsync(Guid userId, int page, int size,
+            Guid groupId, UserChallengeStatus status,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Gets a paginated list of challenges by user ID and participation status.
+        /// </summary>
+        /// <param name="userId">The user ID.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="status">The user's participation status.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of challenges the user is participating in.</returns>
+        Task<PagedResult<Challenge>> GetChallengesPaginatedByUserIdAndStatusAsync(Guid userId, int page, int size,
+            UserChallengeStatus status,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if a user has already joined a specific challenge.
+        /// </summary>
+        /// <param name="userId">The user ID.</param>
+        /// <param name="challengeId">The challenge ID.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the user has already joined the challenge; otherwise false.</returns>
+        Task<bool> UserAlreadyJoined(Guid userId, Guid challengeId, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if a challenge belongs to a specific group.
+        /// </summary>
+        /// <param name="groupId">The group ID.</param>
+        /// <param name="challengeId">The challenge ID.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the challenge belongs to the group; otherwise false.</returns>
+        Task<bool> ChallengeBelongsToGroup(Guid groupId, Guid challengeId, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Retrieves all active challenges that have passed their end date.
+        /// </summary>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A collection of expired challenges with active status.</returns>
+        Task<IEnumerable<Challenge>> GetExpiredChallenges(CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IChatRepository.cs b/Rex.Application/Interfaces/Repository/IChatRepository.cs
new file mode 100644
index 0000000..5d92776
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IChatRepository.cs
@@ -0,0 +1,32 @@
+using Rex.Application.Pagination;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with chats in the database.
+    /// </summary>
+    public interface IChatRepository : IGenericRepository<Chat>
+    {
+        /// <summary>
+        /// Gets a paginated list of chats along with their last message for a specific user.
+        /// </summary>
+        /// <param name="userId">The ID of the user.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of chats with their last message.</returns>
+        Task<PagedResult<Chat>> GetChatsWithLastMessageByUserIdAsync(
+            Guid userId, int page, int size, string? searchTerm = null, CancellationToken cancellationToken = default);
+        
+        /// <summary>
+        /// Checks if a chat exists by its ID.
+        /// </summary>
+        /// <param name="chatId">The chat ID.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the chat exists; otherwise false.</returns>
+        Task<bool> ChatExistsAsync(Guid chatId, CancellationToken cancellationToken);
+
+        Task<Chat> GetOneToOneChat(Guid firstUser, Guid secondUser, CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/ICodeRepository.cs b/Rex.Application/Interfaces/Repository/ICodeRepository.cs
new file mode 100644
index 0000000..67c84f6
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/ICodeRepository.cs
@@ -0,0 +1,56 @@
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with codes in the database.
+    /// </summary>
+    public interface ICodeRepository : IGenericRepository<Code>
+    {
+        /// <summary>
+        /// Creates a new code in the database.
+        /// </summary>
+        /// <param name="code">The code to create.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        Task CreateCodeAsync(Code code, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Retrieves a code by its ID.
+        /// </summary>
+        /// <param name="id">The ID of the code.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>The code with the specified ID.</returns>
+        Task<Code> GetCodeByIdAsync(Guid id, CancellationToken cancellationToken);
+        
+        /// <summary>
+        /// Retrieves a <see cref="Code"/> entity that matches the specified code value.
+        /// </summary>
+        /// <param name="value">The code value to search for.</param>
+        /// <param name="cancellationToken">A token to monitor for cancellation requests.</param>
+        /// <returns>The <see cref="Code"/> entity if found; otherwise, null.</returns>
+        Task<Code> GetCodeByValueAsync(string value, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if a code is valid.
+        /// </summary>
+        /// <param name="code">The code to validate.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the code is valid; otherwise false.</returns>
+        Task<bool> IsCodeValidAsync(string code, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Marks a code as used.
+        /// </summary>
+        /// <param name="code">The code value to mark as used.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        Task MarkCodeAsUsedAsync(string code, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if a code has already been used.
+        /// </summary>
+        /// <param name="code">The ID of the code.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the code has been used; otherwise false.</returns>
+        Task<bool> IsCodeUsedAsync(string code, CancellationToken cancellationToken);
+    }
+}
diff --git a/Rex.Application/Interfaces/Repository/ICommentRepository.cs b/Rex.Application/Interfaces/Repository/ICommentRepository.cs
new file mode 100644
index 0000000..929597d
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/ICommentRepository.cs
@@ -0,0 +1,48 @@
+using Rex.Application.Pagination;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with comments in the database.
+    /// </summary>
+    public interface ICommentRepository : IGenericRepository<Comment>
+    {
+        /// <summary>
+        /// Gets a paginated list of comments for a specific post.
+        /// </summary>
+        /// <param name="postId">The ID of the post.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of comments for the post.</returns>
+        Task<PagedResult<Comment>> GetCommentsPaginatedByPostIdAsync(Guid postId, int page, int size,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Gets a paginated list of replies to a specific comment in a post.
+        /// </summary>
+        /// <param name="postId">The ID of the post.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="parentCommentId">The ID of the parent comment.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of comment replies.</returns>
+        Task<PagedResult<Comment>> GetCommentsRepliedPaginatedByParentCommentIdAsync(Guid postId, int page, int size,
+            Guid parentCommentId, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Gets the total number of comments for a specific post.
+        /// </summary>
+        /// <param name="postId">The ID of the post.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>The total number of comments.</returns>
+        Task<int> GetCommentsCountByPostIdAsync(Guid postId, CancellationToken cancellationToken);
+
+        Task<bool> CommentAlreadyPinned(Guid commentId, CancellationToken cancellationToken);
+        Task<bool> AnotherCommentIsPinned(Guid postId, CancellationToken cancellationToken);
+
+        Task<Dictionary<Guid, int>> GetCommentsCountByPostIdsAsync(IEnumerable<Guid> postIds,
+            CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IEntityFileRepository.cs b/Rex.Application/Interfaces/Repository/IEntityFileRepository.cs
new file mode 100644
index 0000000..a2ae8e0
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IEntityFileRepository.cs
@@ -0,0 +1,32 @@
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Models;
+using File = Rex.Models.File;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with entity files in the database.
+    /// </summary>
+    public interface IEntityFileRepository : IGenericRepository<EntityFile>
+    {
+        /// <summary>
+        /// Checks if a file exists for a specific target entity.
+        /// </summary>
+        /// <param name="targetId">The ID of the target entity.</param>
+        /// <param name="fileId">The ID of the file.</param>
+        /// <param name="targetType">The type of the target entity.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the file exists for the target entity; otherwise false.</returns>
+        Task<bool> ExistsAsync(Guid targetId, Guid fileId, TargetType targetType, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Counts the number of files associated with a specific target entity.
+        /// </summary>
+        /// <param name="targetId">The ID of the target entity.</param>
+        /// <param name="targetType">The type of the target entity.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>The total number of files for the target entity.</returns>
+        Task<int> CountByTargetIdAsync(Guid targetId, TargetType targetType, CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IFileRepository.cs b/Rex.Application/Interfaces/Repository/IFileRepository.cs
new file mode 100644
index 0000000..d76437f
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IFileRepository.cs
@@ -0,0 +1,46 @@
+using Rex.Application.Pagination;
+using Rex.Enum;
+using File = Rex.Models.File;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with files in the database.
+    /// </summary>
+    public interface IFileRepository : IGenericRepository<File>
+    {
+        /// <summary>
+        /// Gets a paginated list of files for a specific entity filtered by file type.
+        /// </summary>
+        /// <param name="targetId">The ID of the target entity.</param>
+        /// <param name="targetType">The type of the target entity.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="type">The type of files to retrieve.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of files matching the entity and file type.</returns>
+        Task<IEnumerable<File>> GetFilesByEntityAndTypeAsync(Guid targetId, TargetType targetType, int page,
+            int size, FileType type, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Gets a paginated list of files for a specific entity, regardless of file type.
+        /// </summary>
+        /// <param name="targetId">The ID of the target entity.</param>
+        /// <param name="targetType">The type of the target entity.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of files for the entity.</returns>
+        Task<IEnumerable<File>> GetFilesByEntityAsync(Guid targetId, TargetType targetType, int page,
+            int size, CancellationToken cancellationToken);
+        
+        Task<File> GetFileByEntityAndTypeAsync(Guid targetId, TargetType targetType, CancellationToken cancellationToken);
+
+        Task<IEnumerable<File>> GetFilesByTargetIdsAsync(IEnumerable<Guid> ids, TargetType targetType,
+            CancellationToken cancellationToken);
+        
+        Task<IEnumerable<File>> GetFilesByTargetIdAsync(Guid targetId, TargetType targetType,
+            CancellationToken cancellationToken);
+
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IFriendShipRepository.cs b/Rex.Application/Interfaces/Repository/IFriendShipRepository.cs
new file mode 100644
index 0000000..1572d3f
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IFriendShipRepository.cs
@@ -0,0 +1,38 @@
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with friendships in the database.
+    /// </summary>
+    public interface IFriendShipRepository : IGenericRepository<FriendShip>
+    {
+        /// <summary>
+        /// Gets a paginated list of friendship requests for a specific user filtered by request status.
+        /// </summary>
+        /// <param name="userId">The ID of the user.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="status">The status of the friendship requests.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of friendship requests.</returns>
+        Task<PagedResult<FriendShip>> GetFriendShipRequestsByUserIdAsync(Guid userId, int page, int size,
+            RequestStatus status, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if a friendship exists between two users.
+        /// </summary>
+        /// <param name="requesterId">The ID of the user who sent the request.</param>
+        /// <param name="targetUserId">The ID of the target user.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the friendship exists; otherwise false.</returns>
+        Task<bool> FriendShipExistAsync(Guid requesterId, Guid targetUserId, CancellationToken cancellationToken);
+        
+        Task<FriendShip> GetFriendShipInPendingAsync(Guid requesterId, Guid targetUserId, CancellationToken cancellationToken);
+
+        Task<FriendShip> GetFriendShipBetweenUsersAsync(Guid requesterId, Guid targetUserId,
+            CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IGenericRepository.cs b/Rex.Application/Interfaces/Repository/IGenericRepository.cs
new file mode 100644
index 0000000..9aeade7
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IGenericRepository.cs
@@ -0,0 +1,56 @@
+using System.Linq.Expressions;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines generic CRUD operations for entities.
+    /// </summary>
+    /// <typeparam name="TEntity">The type of entity.</typeparam>
+    public interface IGenericRepository<TEntity> where TEntity : class
+    {
+        /// <summary>
+        /// Retrieves an entity by its ID.
+        /// </summary>
+        /// <param name="id">The ID of the entity.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>The entity with the specified ID.</returns>
+        Task<TEntity> GetByIdAsync(Guid id, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Updates an existing entity in the database.
+        /// </summary>
+        /// <param name="entity">The entity to update.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        Task UpdateAsync(TEntity entity, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Deletes an entity from the database.
+        /// </summary>
+        /// <param name="entity">The entity to delete.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        Task DeleteAsync(TEntity entity, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Creates a new entity in the database.
+        /// </summary>
+        /// <param name="entity">The entity to create.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        Task CreateAsync(TEntity entity, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Saves changes made in the context to the database.
+        /// </summary>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        Task SaveAsync(CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Validates an entity based on a specified condition.
+        /// </summary>
+        /// <param name="validation">The expression representing the validation condition.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the entity satisfies the condition; otherwise false.</returns>
+        Task<bool> ValidateAsync(Expression<Func<TEntity, bool>> validation, CancellationToken cancellationToken);
+        
+        Task UpdateRangeAsync(IEnumerable<TEntity> entities, CancellationToken cancellationToken);
+    }
+}
diff --git a/Rex.Application/Interfaces/Repository/IGroupRepository.cs b/Rex.Application/Interfaces/Repository/IGroupRepository.cs
new file mode 100644
index 0000000..1e950a8
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IGroupRepository.cs
@@ -0,0 +1,25 @@
+using Rex.Application.DTOs;
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with groups in the database.
+    /// </summary>
+    public interface IGroupRepository : IGenericRepository<Group>
+    {
+        /// <summary>
+        /// Gets a paginated list of groups associated with a specific user.
+        /// </summary>
+        /// <param name="userId">The ID of the user.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of groups for the user.</returns>
+        Task<PagedResult<Group>> GetGroupsByUserIdAsync(Guid userId, int page, int size, CancellationToken cancellationToken);
+        
+        Task<PagedResult<Group>> GetGroupsPaginatedAsync(Guid userId, int page, int size, CancellationToken cancellationToken);
+        Task<Group> GetGroupByIdAsync(Guid groupId, CancellationToken cancellationToken);
+        
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IGroupRoleRepository.cs b/Rex.Application/Interfaces/Repository/IGroupRoleRepository.cs
new file mode 100644
index 0000000..a6a5be2
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IGroupRoleRepository.cs
@@ -0,0 +1,8 @@
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository;
+
+public interface IGroupRoleRepository: IGenericRepository<GroupRole>
+{
+    Task<GroupRole> GetRoleByNameAsync(Enum.GroupRole role, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IMessageRepository.cs b/Rex.Application/Interfaces/Repository/IMessageRepository.cs
new file mode 100644
index 0000000..9c4af2c
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IMessageRepository.cs
@@ -0,0 +1,22 @@
+using Rex.Application.Pagination;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with messages in the database.
+    /// </summary>
+    public interface IMessageRepository : IGenericRepository<Message>
+    {
+        /// <summary>
+        /// Gets a paginated list of messages for a specific chat.
+        /// </summary>
+        /// <param name="chatId">The ID of the chat.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of messages for the chat.</returns>
+        Task<PagedResult<Message>> GetMessagesByChatIdAsync(Guid chatId, int page, int size,
+            CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/INotificationRepository.cs b/Rex.Application/Interfaces/Repository/INotificationRepository.cs
new file mode 100644
index 0000000..e5327da
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/INotificationRepository.cs
@@ -0,0 +1,22 @@
+using Rex.Application.Pagination;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with notifications in the database.
+    /// </summary>
+    public interface INotificationRepository : IGenericRepository<Notification>
+    {
+        /// <summary>
+        /// Gets a paginated list of notifications for a specific user.
+        /// </summary>
+        /// <param name="userId">The ID of the user.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of notifications for the user.</returns>
+        Task<PagedResult<Notification>> GetNotificationsByUserIdAsync(Guid userId, int page, int size,
+            CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IPostRepository.cs b/Rex.Application/Interfaces/Repository/IPostRepository.cs
new file mode 100644
index 0000000..6e94d4e
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IPostRepository.cs
@@ -0,0 +1,22 @@
+using Rex.Application.Pagination;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with posts in the database.
+    /// </summary>
+    public interface IPostRepository : IGenericRepository<Post>
+    {
+        /// <summary>
+        /// Gets a paginated list of posts for a specific group.
+        /// </summary>
+        /// <param name="groupId">The ID of the group.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of posts for the group.</returns>
+        Task<PagedResult<Post>> GetPostsByGroupIdAsync(Guid groupId, int page, int size,
+            CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IReactionRepository.cs b/Rex.Application/Interfaces/Repository/IReactionRepository.cs
new file mode 100644
index 0000000..458a08d
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IReactionRepository.cs
@@ -0,0 +1,21 @@
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with reactions in the database.
+    /// </summary>
+    public interface IReactionRepository : IGenericRepository<Reaction>
+    {
+        Task<int> CountLikesAsync(Guid targetId, ReactionTargetType targetType, CancellationToken cancellationToken);
+
+        Task<Reaction> HasLikedAsync(Guid targetId, Guid userId, CancellationToken cancellationToken);
+
+        Task<Dictionary<Guid, int>> GetLikesCountByPostIdsAsync(IEnumerable<Guid> Ids, TargetType targetType,
+            CancellationToken cancellationToken);
+
+        Task<HashSet<Guid>> GetUserLikesForTargetsAsync( Guid userId, List<Guid> targetIds,
+            ReactionTargetType targetType, CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IRefreshTokenRepository.cs b/Rex.Application/Interfaces/Repository/IRefreshTokenRepository.cs
new file mode 100644
index 0000000..58178b4
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IRefreshTokenRepository.cs
@@ -0,0 +1,51 @@
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with refresh tokens in the database.
+    /// </summary>
+    public interface IRefreshTokenRepository : IGenericRepository<RefreshToken>
+    {
+        /// <summary>
+        /// Creates a new refresh token in the database.
+        /// </summary>
+        /// <param name="token">The refresh token to create.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        Task CreateRefreshTokenAsync(RefreshToken token, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Retrieves a refresh token by its ID.
+        /// </summary>
+        /// <param name="tokenId">The ID of the refresh token.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>The refresh token with the specified ID.</returns>
+        Task<RefreshToken> GetRefreshTokenByIdAsync(Guid tokenId, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if a refresh token is valid.
+        /// </summary>
+        /// <param name="token">The refresh token to validate.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the token is valid; otherwise false.</returns>
+        Task<bool> IsRefreshTokenValidAsync(Guid userId, string receivedToken, CancellationToken cancellationToken);
+        
+        /// <summary>
+        /// Marks a refresh token as used.
+        /// </summary>
+        /// <param name="token">The token value to mark as used.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        Task MarkRefreshTokenAsUsedAsync(string token, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if a refresh token has already been used.
+        /// </summary>
+        /// <param name="tokenId">The ID of the refresh token.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the token has been used; otherwise false.</returns>
+        Task RevokeOldRefreshTokensAsync(Guid userId, Guid tokenId,
+            CancellationToken cancellationToken);
+
+        Task<List<RefreshToken>> GetActiveTokensByUserIdAsync(Guid userId, CancellationToken cancellationToken);
+    }
+}
diff --git a/Rex.Application/Interfaces/Repository/IUserChallengeRepository.cs b/Rex.Application/Interfaces/Repository/IUserChallengeRepository.cs
new file mode 100644
index 0000000..3210d26
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IUserChallengeRepository.cs
@@ -0,0 +1,22 @@
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with user challenges in the database.
+    /// </summary>
+    public interface IUserChallengeRepository : IGenericRepository<UserChallenge>
+    {
+        /// <summary>
+        /// Gets the total number of challenges associated with a specific user.
+        /// </summary>
+        /// <param name="userId">The ID of the user.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>The total number of challenges for the user.</returns>
+        Task<int> GetChallengesCountByUserIdAsync(Guid userId, CancellationToken cancellationToken);
+
+        Task<UserChallenge> GetByUserAndChallengeAsync(Guid userId, Guid challengeId,
+            CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IUserChatRepository.cs b/Rex.Application/Interfaces/Repository/IUserChatRepository.cs
new file mode 100644
index 0000000..66c38dc
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IUserChatRepository.cs
@@ -0,0 +1,25 @@
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with user-chat relationships in the database.
+    /// </summary>
+    public interface IUserChatRepository : IGenericRepository<UserChat>
+    {
+        /// <summary>
+        /// Checks if a user is part of a specific chat.
+        /// </summary>
+        /// <param name="userId">The ID of the user.</param>
+        /// <param name="chatId">The ID of the chat.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the user is in the chat; otherwise false.</returns>
+        Task<bool> IsUserInChatAsync(Guid userId, Guid chatId, CancellationToken cancellationToken);
+        
+        Task<List<Guid>> GetUserChatsAsync(Guid userId, CancellationToken cancellationToken);
+
+        Task CreateRangeAsync(IEnumerable<UserChat> entities, CancellationToken cancellationToken);
+        
+        Task<User> GetOtherUserInChatAsync(Guid chatId, Guid currentUserId, CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IUserGroupRepository.cs b/Rex.Application/Interfaces/Repository/IUserGroupRepository.cs
new file mode 100644
index 0000000..449ce74
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IUserGroupRepository.cs
@@ -0,0 +1,46 @@
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Models;
+using GroupRole = Rex.Enum.GroupRole;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with user-group relationships in the database.
+    /// </summary>
+    public interface IUserGroupRepository : IGenericRepository<UserGroup>
+    {
+        /// <summary>
+        /// Gets the total number of groups a user belongs to.
+        /// </summary>
+        /// <param name="userId">The ID of the user.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>The total number of groups for the user.</returns>
+        Task<int> GetUserGroupCountAsync(Guid userId, RequestStatus status, CancellationToken cancellationToken);
+
+        Task<bool> IsUserInGroupAsync(Guid userId, Guid groupId, RequestStatus? status = null, 
+            CancellationToken cancellationToken = default);
+        Task<bool> IsGroupPrivateAsync(Guid groupId, CancellationToken cancellationToken);
+        Task<bool> IsUserBannedAsync(Guid userId, Guid groupId, CancellationToken cancellationToken);
+
+        Task<PagedResult<UserGroup>> GetMembersAsync(Guid groupId, GroupRole? roleFilter, string? searchTerm,
+            int pageNumber, int pageSize, CancellationToken cancellationToken);
+        
+        Task<UserGroup> GetMemberAsync(Guid userId, Guid groupId, CancellationToken cancellation);
+        
+        Task<PagedResult<UserGroup>> GetGroupRequestsAsync(Guid groupId, RequestStatus status, string? searchTerm, int pageNumber, int pageSize,
+            CancellationToken cancellationToken);
+        
+        Task<UserGroup> GetGroupRequestAsync(Guid userId, Guid groupId, CancellationToken cancellationToken);
+
+        Task<bool> RequestExistsAsync(Guid userId, Guid groupId, CancellationToken cancellationToken);
+
+        Task<IEnumerable<UserGroup>> GetInactiveUserGroupsForWarning(int inactiveDays, CancellationToken cancellationToken);
+
+        Task<IEnumerable<UserGroup>> GetInactiveUserGroupsForRemoval(int inactiveDays, CancellationToken cancellationToken);
+
+        Task ResetWarningStatus(Guid userId, Guid groupId, CancellationToken cancellationToken);
+
+        Task MarkMultipleAsWarned(IEnumerable<Guid> userGroupIds, CancellationToken cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Repository/IUserRepository.cs b/Rex.Application/Interfaces/Repository/IUserRepository.cs
new file mode 100644
index 0000000..422d4ba
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IUserRepository.cs
@@ -0,0 +1,131 @@
+using Rex.Application.Pagination;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository
+{
+    /// <summary>
+    /// Defines methods to interact with users in the database.
+    /// </summary>
+    public interface IUserRepository : IGenericRepository<User>
+    {
+        /// <summary>
+        /// Checks if a user's account is confirmed.
+        /// </summary>
+        /// <param name="id">The ID of the user.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the account is confirmed; otherwise false.</returns>
+        Task<bool> ConfirmedAccountAsync(Guid id, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if a username is already in use by another user.
+        /// </summary>
+        /// <param name="userName">The username to check.</param>
+        /// <param name="userId">The ID of the current user.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the username is in use; otherwise false.</returns>
+        Task<bool> UserNameInUseAsync(Guid userId, string userName, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Retrieves a user by their email address.
+        /// </summary>
+        /// <param name="email">The email of the user.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>The user with the specified email.</returns>
+        Task<User> GetByEmailAsync(string email, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if an email is already in use by another user.
+        /// </summary>
+        /// <param name="email">The email to check.</param>
+        /// <param name="userId">The ID of the current user.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the email is in use; otherwise false.</returns>
+        Task<bool> EmailInUseAsync(string email, Guid userId, CancellationToken cancellationToken);
+        
+        Task<bool> EmailInUseByYouAsync(Guid userId, string email,  CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Updates a user's password.
+        /// </summary>
+        /// <param name="user">The user whose password will be updated.</param>
+        /// <param name="newPassword">The new password.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        Task UpdatePasswordAsync(User user, string newPassword, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if an email exists in the database.
+        /// </summary>
+        /// <param name="email">The email to check.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the email exists; otherwise false.</returns>
+        Task<bool> EmailExistAsync(string email, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Checks if a username exists in the database.
+        /// </summary>
+        /// <param name="userName">The username to check.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>True if the username exists; otherwise false.</returns>
+        Task<bool> UserNameExistAsync(string userName, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Retrieves detailed information about a user.
+        /// </summary>
+        /// <param name="id">The ID of the user.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>The user details.</returns>
+        Task<User> GetUserDetailsAsync(Guid id, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Gets a paginated list of users in a specific group.
+        /// </summary>
+        /// <param name="groupId">The ID of the group.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of users in the group.</returns>
+        Task<PagedResult<User>> GetUsersByGroupIdAsync(Guid groupId, int page, int size,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Gets a paginated list of users in a group filtered by name or last name.
+        /// </summary>
+        /// <param name="groupId">The ID of the group.</param>
+        /// <param name="searchTerm">The search term for name or last name.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of users matching the search term.</returns>
+        Task<PagedResult<User>> GetUsersByNameOrLastnameAsync(Guid groupId, string searchTerm, int page,
+            int size, CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Gets a paginated list of users with pending requests in a specific group.
+        /// </summary>
+        /// <param name="groupId">The ID of the group.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of users with pending requests.</returns>
+        Task<PagedResult<User>> GetPendingRequestsByGroupIdAsync(Guid groupId, int page, int size,
+            CancellationToken cancellationToken);
+
+        /// <summary>
+        /// Gets a paginated list of administrative members in a specific group.
+        /// </summary>
+        /// <param name="groupId">The ID of the group.</param>
+        /// <param name="page">The page number to retrieve.</param>
+        /// <param name="size">The number of items per page.</param>
+        /// <param name="cancellationToken">Token to cancel the operation.</param>
+        /// <returns>A paginated list of administrative members.</returns>
+        Task<PagedResult<User>> GetAdministrativeMembersByGroupIdAsync(Guid groupId, int page, int size,
+            CancellationToken cancellationToken);
+
+        Task UpdateLastTimeConnectionAsync(Guid userId, bool isActive, CancellationToken cancellationToken);
+        
+        Task<User> GetUserByCommentIdAsync(Guid parentCommentId, CancellationToken cancellationToken);
+        
+        Task<User> GetByGitHubIdAsync(string githubId, CancellationToken cancellationToken);
+        
+    }
+}
diff --git a/Rex.Application/Interfaces/Repository/IUserRoleRepository.cs b/Rex.Application/Interfaces/Repository/IUserRoleRepository.cs
new file mode 100644
index 0000000..3741bbe
--- /dev/null
+++ b/Rex.Application/Interfaces/Repository/IUserRoleRepository.cs
@@ -0,0 +1,10 @@
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.Repository;
+
+public interface IUserRoleRepository: IGenericRepository<UserRole>
+{
+    Task<bool> RoleExistsAsync(Guid roleId, CancellationToken cancellationToken);
+    
+    Task<UserRole> GetRoleByNameAsync(string roleName, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IAuthenticationService.cs b/Rex.Application/Interfaces/Services/IAuthenticationService.cs
new file mode 100644
index 0000000..36f45b6
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IAuthenticationService.cs
@@ -0,0 +1,18 @@
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Utilities;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces;
+
+/// <summary>
+/// Service responsible for handling authentication tasks.
+/// </summary>
+public interface IAuthenticationService
+{
+    /// <summary>
+    /// Generates a JWT token for the specified user.
+    /// </summary>
+    Task<string> GenerateTokenAsync(User user, CancellationToken cancellationToken);
+    Task<string> GenerateRefreshTokenAsync(User user, CancellationToken cancellationToken);
+    Task<ResultT<TokenResponseDto>> RefreshTokenAsync(string refreshToken, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IChallengeExpirationService.cs b/Rex.Application/Interfaces/Services/IChallengeExpirationService.cs
new file mode 100644
index 0000000..c793c0a
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IChallengeExpirationService.cs
@@ -0,0 +1,9 @@
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Interfaces;
+
+public interface IChallengeExpirationService
+{
+    Task<ResultT<ResponseDto>> MarkChallengeExpired(CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/ICloudinaryService.cs b/Rex.Application/Interfaces/Services/ICloudinaryService.cs
new file mode 100644
index 0000000..1882243
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/ICloudinaryService.cs
@@ -0,0 +1,9 @@
+namespace Rex.Application.Interfaces;
+
+public interface ICloudinaryService
+{
+    Task<string> UploadArchiveAsync(Stream archive, string archiveName, CancellationToken cancellationToken);
+    Task<string> UploadImageAsync(Stream archive, string imageName, CancellationToken cancellationToken);
+    Task<string> UploadVideoAsync(Stream archive, string imageName, CancellationToken cancellationToken);
+    
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/ICodeService.cs b/Rex.Application/Interfaces/Services/ICodeService.cs
new file mode 100644
index 0000000..a3d552b
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/ICodeService.cs
@@ -0,0 +1,36 @@
+using Rex.Application.DTOs.Code;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Interfaces;
+
+/// <summary>
+/// Service for managing user-related codes and their validation.
+/// </summary>
+public interface ICodeService
+{
+    /// <summary>
+    /// Creates a code for a specific user based on the given code type.
+    /// </summary>
+    Task<ResultT<string>> CreateCodeAsync(Guid userId, CodeType codeType, CancellationToken cancellationToken);
+    
+    /// <summary>
+    /// Retrieves a code by its unique identifier.
+    /// </summary>
+    Task<ResultT<CodeDto>> GetCodeByIdAsync(Guid id, CancellationToken cancellationToken);
+
+    /// <summary>
+    /// Confirms a user's account using a specific code.
+    /// </summary>
+    Task<Result> ConfirmCodeAsync(Guid userId, string code, CancellationToken cancellationToken);
+    
+    /// <summary>
+    /// Checks whether the provided code is valid.
+    /// </summary>
+    Task<Result> IsCodeValidAsync(string code, CancellationToken cancellationToken);
+    
+    /// <summary>
+    /// Validates a code and returns its value if valid.
+    /// </summary>
+    Task<ResultT<string>> ValidateCodeAsync(string code, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IEmailService.cs b/Rex.Application/Interfaces/Services/IEmailService.cs
new file mode 100644
index 0000000..2c5f90c
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IEmailService.cs
@@ -0,0 +1,14 @@
+using Rex.Application.DTOs.Configs;
+
+namespace Rex.Application.Interfaces;
+
+/// <summary>
+/// Service for sending emails.
+/// </summary>
+public interface IEmailService
+{
+    /// <summary>
+    /// Sends an email using the provided email data.
+    /// </summary>
+    Task SendEmailAsync(EmailDto emailAnswer);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IGithubAuthService.cs b/Rex.Application/Interfaces/Services/IGithubAuthService.cs
new file mode 100644
index 0000000..bbaaedd
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IGithubAuthService.cs
@@ -0,0 +1,10 @@
+using System.Security.Claims;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Interfaces;
+
+public interface IGithubAuthService
+{
+    Task<ResultT<GithubResponseDto>> AuthenticateGitHubUserAsync(ClaimsPrincipal principal, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IMessageService.cs b/Rex.Application/Interfaces/Services/IMessageService.cs
new file mode 100644
index 0000000..a2d69a8
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IMessageService.cs
@@ -0,0 +1,16 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.DTOs.Message;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Interfaces;
+
+public interface IMessageService
+{
+    Task<ResultT<MessageDto>> SendMessageAsync(
+        Guid chatId,
+        Guid userId,
+        string messageText,
+        IEnumerable<IFormFile>? files = null,
+        CancellationToken cancellationToken = default);
+
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IRemoveUserService.cs b/Rex.Application/Interfaces/Services/IRemoveUserService.cs
new file mode 100644
index 0000000..cc5b803
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IRemoveUserService.cs
@@ -0,0 +1,10 @@
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Interfaces;
+
+public interface IRemoveUserService
+{
+    Task<ResultT<ResponseDto>> ProcessRemoval(CancellationToken cancellationToken);
+
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IUserClaimService.cs b/Rex.Application/Interfaces/Services/IUserClaimService.cs
new file mode 100644
index 0000000..8ba0b81
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IUserClaimService.cs
@@ -0,0 +1,8 @@
+using System.Security.Claims;
+
+namespace Rex.Application.Interfaces;
+
+public interface IUserClaimService
+{
+    Guid GetUserId(ClaimsPrincipal user);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IUserInGroupService.cs b/Rex.Application/Interfaces/Services/IUserInGroupService.cs
new file mode 100644
index 0000000..81ae372
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IUserInGroupService.cs
@@ -0,0 +1,8 @@
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Interfaces;
+
+public interface IUserInGroupService
+{
+    Task<ResultT<string>> GetUserRoleInGroupAsync(Guid userId, Guid groupId, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IUserRoleService.cs b/Rex.Application/Interfaces/Services/IUserRoleService.cs
new file mode 100644
index 0000000..3b91d16
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IUserRoleService.cs
@@ -0,0 +1,12 @@
+namespace Rex.Application.Interfaces;
+
+/// <summary>
+/// Service responsible for managing and retrieving user roles.
+/// </summary>
+public interface IUserRoleService
+{
+    /// <summary>
+    /// Gets the list of role names assigned to a specific user.
+    /// </summary>
+    Task<List<string>> GetUserRolesAsync(Guid userId, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/IWarnUserService.cs b/Rex.Application/Interfaces/Services/IWarnUserService.cs
new file mode 100644
index 0000000..7cfbdb3
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/IWarnUserService.cs
@@ -0,0 +1,9 @@
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Interfaces;
+
+public interface IWarnUserService
+{
+    Task<ResultT<ResponseDto>> ProcessWarning(CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/SignalR/IAppConnectionService.cs b/Rex.Application/Interfaces/Services/SignalR/IAppConnectionService.cs
new file mode 100644
index 0000000..837a8fc
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/SignalR/IAppConnectionService.cs
@@ -0,0 +1,9 @@
+using Microsoft.AspNetCore.SignalR;
+
+namespace Rex.Application.Interfaces.SignalR;
+
+public interface IAppConnectionService
+{
+    Task HandleConnectedAsync(HubCallerContext context, IGroupManager groupManager);
+    Task HandleDisconnectedAsync(HubCallerContext context);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/SignalR/IAppHub.cs b/Rex.Application/Interfaces/Services/SignalR/IAppHub.cs
new file mode 100644
index 0000000..c300678
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/SignalR/IAppHub.cs
@@ -0,0 +1,24 @@
+using Rex.Application.DTOs.Challenge;
+using Rex.Application.DTOs.Message;
+using Rex.Application.DTOs.Notification;
+using Rex.Application.DTOs.Reaction;
+
+namespace Rex.Application.Interfaces.SignalR;
+
+public interface IAppHub
+{
+    Task ReceiveMessage(MessageDto message);
+    Task ReceiveFriendRequestNotification(NotificationDto notification);
+    Task ReceiveReactionNotification(NotificationDto notification);
+    Task ReceiveCommentNotification(NotificationDto notification);
+    Task ReceiveReplyNotification(NotificationDto notification);
+    Task ReceiveWarnNotification(NotificationDto notification);
+    Task ReceiveRemoveNotification(NotificationDto notification);
+    
+    Task ReceiveChatCreated(ChatDto chat);
+    Task ReceiveError(string error);
+
+    Task CreateFriendshipRequest(Guid otherUserId);
+    
+    Task ReceiveLikeUpdate(LikeChangedDto update);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/SignalR/IChallengeNotifier.cs b/Rex.Application/Interfaces/Services/SignalR/IChallengeNotifier.cs
new file mode 100644
index 0000000..b93e95f
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/SignalR/IChallengeNotifier.cs
@@ -0,0 +1,8 @@
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.SignalR;
+
+public interface IChallengeNotifier
+{
+    Task SendChallengeNotification(Notification notificationChallenge, CancellationToken cancellation);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/SignalR/IChatNotifier.cs b/Rex.Application/Interfaces/Services/SignalR/IChatNotifier.cs
new file mode 100644
index 0000000..909d9e4
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/SignalR/IChatNotifier.cs
@@ -0,0 +1,10 @@
+using Rex.Application.DTOs.Message;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.SignalR;
+
+public interface IChatNotifier
+{
+    Task NotifyChatCreatedAsync(IEnumerable<Guid> userIds, Chat chat, CancellationToken cancellationToken);
+    Task NotifyMessageAsync(Guid chatId, MessageDto message);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/SignalR/ICommentsNotifier.cs b/Rex.Application/Interfaces/Services/SignalR/ICommentsNotifier.cs
new file mode 100644
index 0000000..c17c4f7
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/SignalR/ICommentsNotifier.cs
@@ -0,0 +1,9 @@
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.SignalR;
+
+public interface ICommentsNotifier
+{
+    Task SendCommentNotification(Notification notificationComment, CancellationToken cancellationToken);
+    Task SendReplyNotification(Notification notificationReply, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/SignalR/IFriendshipNotifier.cs b/Rex.Application/Interfaces/Services/SignalR/IFriendshipNotifier.cs
new file mode 100644
index 0000000..e27e328
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/SignalR/IFriendshipNotifier.cs
@@ -0,0 +1,9 @@
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.SignalR;
+
+public interface IFriendshipNotifier
+{
+    Task SendFriendRequestNotification(Notification notification, CancellationToken cancellationToken);
+
+}
diff --git a/Rex.Application/Interfaces/Services/SignalR/IInactiveUserNotifier.cs b/Rex.Application/Interfaces/Services/SignalR/IInactiveUserNotifier.cs
new file mode 100644
index 0000000..515a4fc
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/SignalR/IInactiveUserNotifier.cs
@@ -0,0 +1,9 @@
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.SignalR;
+
+public interface IInactiveUserNotifier
+{
+    Task SendWarnNotification(Notification notification, CancellationToken cancellationToken);
+    Task SendBanNotification(Notification notification, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Interfaces/Services/SignalR/IReactionNotifier.cs b/Rex.Application/Interfaces/Services/SignalR/IReactionNotifier.cs
new file mode 100644
index 0000000..fe2b6d2
--- /dev/null
+++ b/Rex.Application/Interfaces/Services/SignalR/IReactionNotifier.cs
@@ -0,0 +1,11 @@
+using Rex.Application.DTOs;
+using Rex.Application.DTOs.Reaction;
+using Rex.Models;
+
+namespace Rex.Application.Interfaces.SignalR;
+
+public interface IReactionNotifier
+{
+    Task ReactionPostNotificationAsync(Notification notification, CancellationToken cancellationToken);
+    Task LikeChangedNotificationAsync(LikeChangedDto dto, CancellationToken cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Commands/CreateChallenge/CreateChallengeCommand.cs b/Rex.Application/Modules/Challenges/Commands/CreateChallenge/CreateChallengeCommand.cs
new file mode 100644
index 0000000..0e7f45d
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Commands/CreateChallenge/CreateChallengeCommand.cs
@@ -0,0 +1,14 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Challenges.CreateChallenge;
+
+public record CreateChallengeCommand(
+    Guid UserId,
+    Guid GroupId,
+    string Title,
+    string Description,
+    TimeSpan Duration,
+    IFormFile CoverPhoto
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Commands/CreateChallenge/CreateChallengeCommandHandler.cs b/Rex.Application/Modules/Challenges/Commands/CreateChallenge/CreateChallengeCommandHandler.cs
new file mode 100644
index 0000000..72e1f89
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Commands/CreateChallenge/CreateChallengeCommandHandler.cs
@@ -0,0 +1,124 @@
+using System.Text.Json;
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+using File = Rex.Models.File;
+
+namespace Rex.Application.Modules.Challenges.CreateChallenge;
+
+public class CreateChallengeCommandHandler(
+    ILogger<CreateChallengeCommandHandler> logger,
+    IChallengeRepository challengeRepository,
+    IEntityFileRepository entityFileRepository,
+    IFileRepository fileRepository,
+    IUserRepository userRepository,
+    ICloudinaryService cloudinaryService,
+    IGroupRepository groupRepository,
+    IChallengeNotifier challengeNotifier,
+    IDistributedCache cache
+) : ICommandHandler<CreateChallengeCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(CreateChallengeCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request for creating a challenge.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "Oops! We couldn't process your request. Please provide the challenge details."));
+        }
+
+        var group = await groupRepository.GetGroupByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("No group found with the provided GroupId.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("404", "We couldn't find the group you selected."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("No user found with the provided UserId.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("404",
+                "We couldn't find your account. Please check your details."));
+        }
+
+        string coverPhotoUrl = "";
+        if (request.CoverPhoto is not null)
+        {
+            await using var stream = request.CoverPhoto.OpenReadStream();
+            coverPhotoUrl =
+                await cloudinaryService.UploadImageAsync(stream, request.CoverPhoto.FileName, cancellationToken);
+            logger.LogInformation("Cover photo uploaded.");
+        }
+
+        Challenge challenge = new()
+        {
+            Id = Guid.NewGuid(),
+            Title = request.Title,
+            Description = request.Description,
+            Duration = request.Duration,
+            Status = ChallengeStatus.Active.ToString(),
+            CoverPhoto = coverPhotoUrl,
+            CreatorId = request.UserId,
+            GroupId = request.GroupId
+        };
+
+        await challengeRepository.CreateAsync(challenge, cancellationToken);
+        logger.LogInformation("Challenge '{ChallengeTitle}' saved successfully.", request.Title);
+
+        File file = new()
+        {
+            Id = Guid.NewGuid(),
+            Url = coverPhotoUrl,
+            Type = FileType.Image.ToString(),
+            UploadedAt = DateTime.UtcNow
+        };
+
+        await fileRepository.CreateAsync(file, cancellationToken);
+        logger.LogInformation("File registered successfully for challenge '{ChallengeTitle}'.", request.Title);
+
+        EntityFile entityFile = new()
+        {
+            Id = Guid.NewGuid(),
+            TargetId = challenge.Id,
+            FileId = file.Id,
+            TargetType = TargetType.Challenge.ToString()
+        };
+
+        logger.LogInformation("Cover photo linked successfully to challenge '{ChallengeTitle}'.", request.Title);
+        await entityFileRepository.CreateAsync(entityFile, cancellationToken);
+        
+        var metadata = new
+        {
+            GroupId = group.Id,
+            ChallengeId = challenge.Id,
+            ChallengeTitle = challenge.Title,
+            CreatedBy = $"{user.FirstName} {user.LastName}"
+        };
+
+        var notification = new Notification
+        {
+            Title = "New Challenge",
+            Description = $"{user.FirstName} {user.LastName} gave an impulse to your post in '{group.Title}'",
+            UserId = user.Id,
+            RecipientType = TargetType.Group.ToString(),                  
+            RecipientId = group.Id,                     
+            MetadataJson = JsonSerializer.Serialize(metadata),
+            CreatedAt = DateTime.UtcNow
+        };
+
+        await challengeNotifier.SendChallengeNotification(notification, cancellationToken);
+        
+        await cache.IncrementVersionAsync("challenge", request.GroupId, logger, cancellationToken);
+        
+        logger.LogInformation("Challenge '{ChallengeTitle}' created successfully.", request.Title);
+        return ResultT<ResponseDto>.Success(new ResponseDto("Your challenge has been created successfully!"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Commands/DeleteChallenge/DeleteChallengeCommand.cs b/Rex.Application/Modules/Challenges/Commands/DeleteChallenge/DeleteChallengeCommand.cs
new file mode 100644
index 0000000..8fe9656
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Commands/DeleteChallenge/DeleteChallengeCommand.cs
@@ -0,0 +1,10 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Challenges.Commands.DeleteChallenge;
+
+public record DeleteChallengeCommand(
+    Guid ChallengeId,
+    Guid GroupId,
+    Guid UserId
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Commands/DeleteChallenge/DeleteChallengeCommandHandler.cs b/Rex.Application/Modules/Challenges/Commands/DeleteChallenge/DeleteChallengeCommandHandler.cs
new file mode 100644
index 0000000..266296c
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Commands/DeleteChallenge/DeleteChallengeCommandHandler.cs
@@ -0,0 +1,89 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Challenges.Commands.DeleteChallenge;
+
+public class DeleteChallengeCommandHandler(
+    ILogger<DeleteChallengeCommandHandler> logger,
+    IGroupRepository groupRepository,
+    IChallengeRepository challengeRepository,
+    IUserRepository userRepository,
+    IUserGroupRepository userGroupRepository,
+    IDistributedCache cache
+) : ICommandHandler<DeleteChallengeCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(DeleteChallengeCommand request, CancellationToken cancellationToken)
+    {
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User with ID {UserId} not found.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound(
+                "404",
+                "We couldn't find your account. Please make sure you're logged in."
+            ));
+        }
+
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Group with ID {GroupId} not found.", request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound(
+                "404",
+                "The group you're trying to access couldn't be found. Please check if you still belong to it."
+            ));
+        }
+        
+        var challenge = await challengeRepository.GetByIdAsync(request.ChallengeId, cancellationToken);
+        if (challenge is null)
+        {
+            logger.LogWarning("Challenge with ID {ChallengeId} not found.", request.ChallengeId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound(
+                "404",
+                "The challenge you're trying to delete doesn't exist or was already removed."
+            ));
+        }
+
+        var isMember = await userGroupRepository.IsUserInGroupAsync(request.UserId, group.Id, RequestStatus.Accepted, cancellationToken);
+        if (!isMember)
+        {
+            logger.LogWarning("User {UserId} is not a member of group {GroupId}.", request.UserId, group.Id);
+            return ResultT<ResponseDto>.Failure(Error.Failure(
+                "403",
+                "You are not a member of this group or your membership hasn't been approved yet."
+            ));
+        }
+
+        var userGroup = await userGroupRepository.GetMemberAsync(request.UserId, group.Id, cancellationToken);
+        if (userGroup is null)
+        {
+            logger.LogWarning("Membership not found for user {UserId} in group {GroupId}.", request.UserId, group.Id);
+            return ResultT<ResponseDto>.Failure(Error.NotFound(
+                "404",
+                "We couldn't verify your membership in this group. Please try refreshing or contact an admin."
+            ));
+        }
+
+        if (userGroup.GroupRole.Role.Equals(GroupRole.Member.ToString(), StringComparison.OrdinalIgnoreCase))
+        {
+            logger.LogWarning("User {UserId} lacks permission to delete challenges in group {GroupId}.", request.UserId, group.Id);
+            return ResultT<ResponseDto>.Failure(Error.Failure(
+                "403",
+                "Only group admins can delete challenges."
+            ));
+        }
+
+        await challengeRepository.DeleteAsync(challenge, cancellationToken);
+        logger.LogInformation("Challenge {ChallengeId} deleted by user {UserId} from group {GroupId}.",
+            request.ChallengeId, request.UserId, group.Id);
+
+        await cache.IncrementVersionAsync("challenge", group.Id, logger, cancellationToken);
+        
+        return ResultT<ResponseDto>.Success(new ResponseDto("Challenge was successfully deleted."));
+    }
+}
diff --git a/Rex.Application/Modules/Challenges/Commands/JoinChallenge/JoinChallengeCommand.cs b/Rex.Application/Modules/Challenges/Commands/JoinChallenge/JoinChallengeCommand.cs
new file mode 100644
index 0000000..e56d527
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Commands/JoinChallenge/JoinChallengeCommand.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Challenges.Commands.JoinChallenge;
+
+public record JoinChallengeCommand(
+    Guid ChallengeId,
+    Guid UserId
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Commands/JoinChallenge/JoinChallengeCommandHandler.cs b/Rex.Application/Modules/Challenges/Commands/JoinChallenge/JoinChallengeCommandHandler.cs
new file mode 100644
index 0000000..645b146
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Commands/JoinChallenge/JoinChallengeCommandHandler.cs
@@ -0,0 +1,72 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Modules.Challenges.Commands.JoinChallenge;
+
+public class JoinChallengeCommandHandler(
+    ILogger<JoinChallengeCommandHandler> logger,
+    IChallengeRepository challengeRepository,
+    IUserRepository userRepository,
+    IUserChallengeRepository userChallengeRepository,
+    IDistributedCache cache
+) : ICommandHandler<JoinChallengeCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(JoinChallengeCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request to join a challenge.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "Oops! The request is invalid. Please try again."));
+        }
+
+        var challenge = await challengeRepository.GetByIdAsync(request.ChallengeId, cancellationToken);
+        if (challenge is null)
+        {
+            logger.LogWarning("Challenge not found when attempting to join.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("404",
+                "Sorry, we couldn't find the challenge you want to join."));
+        }
+
+        if (challenge.Status != ChallengeStatus.Active.ToString())
+        {
+            logger.LogWarning("Challenge is not active.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "This challenge is not active right now."));
+        }
+
+        if ((challenge.CreatedAt + challenge.Duration) < DateTime.UtcNow)
+        {
+            logger.LogWarning("Challenge has expired.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "The time to join this challenge has passed."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found when attempting to join challenge.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("404",
+                "We couldn't find your account. Please check your details."));
+        }
+
+        UserChallenge userChallenge = new()
+        {
+            ChallengeId = challenge.Id,
+            UserId = user.Id,
+            Status = UserChallengeStatus.Enrolled.ToString()
+        };
+
+        await userChallengeRepository.CreateAsync(userChallenge, cancellationToken);
+        
+        await cache.IncrementVersionAsync("challenge", challenge.GroupId, logger, cancellationToken);
+
+        logger.LogInformation("User joined the challenge successfully.");
+        return ResultT<ResponseDto>.Success(new ResponseDto("You've successfully joined the challenge! Good luck!"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Commands/UpdateChallenge/UpdateChallengeCommand.cs b/Rex.Application/Modules/Challenges/Commands/UpdateChallenge/UpdateChallengeCommand.cs
new file mode 100644
index 0000000..e6de0bd
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Commands/UpdateChallenge/UpdateChallengeCommand.cs
@@ -0,0 +1,14 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Challenges.Commands.UpdateChallenge;
+
+public record UpdateChallengeCommand(
+    Guid GroupId,
+    Guid ChallengeId,
+    string Title,
+    string Description,
+    TimeSpan Duration,
+    ChallengeStatus Status
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Commands/UpdateChallenge/UpdateChallengeCommandHandler.cs b/Rex.Application/Modules/Challenges/Commands/UpdateChallenge/UpdateChallengeCommandHandler.cs
new file mode 100644
index 0000000..664847f
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Commands/UpdateChallenge/UpdateChallengeCommandHandler.cs
@@ -0,0 +1,64 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Challenges.Commands.UpdateChallenge;
+
+public class UpdateChallengeCommandHandler(
+    ILogger<UpdateChallengeCommandHandler> logger,
+    IChallengeRepository challengeRepository,
+    IGroupRepository groupRepository,
+    IDistributedCache cache
+): ICommandHandler<UpdateChallengeCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(UpdateChallengeCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request to update a challenge.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Oops! Your request was empty. Please provide the challenge details and try again."));
+        }
+
+        var challenge = await challengeRepository.GetByIdAsync(request.ChallengeId, cancellationToken);
+        if (challenge is null)
+        {
+            logger.LogWarning("Challenge not found when attempting to update.");
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Hmm, we couldnt find the challenge youre trying to update."));
+        }
+        
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Group not found for the challenge being updated.");
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "The group associated with this challenge seems to be missing."));
+        }
+        
+        var belongsToGroup = await challengeRepository.ChallengeBelongsToGroup(
+            request.GroupId, request.ChallengeId, cancellationToken);
+
+        if (!belongsToGroup)
+        {
+            logger.LogWarning("Challenge {ChallengeId} doesn't belong to group {GroupId}.",
+                request.ChallengeId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "This challenge doesn't belong to the group you're posting in."));
+        }
+
+        challenge.Title = request.Title;
+        challenge.Description = request.Description;
+        challenge.Duration = request.Duration;
+        challenge.Status = request.Status.ToString();
+        challenge.UpdatedAt = DateTime.UtcNow;
+
+        await challengeRepository.UpdateAsync(challenge, cancellationToken);
+
+        await cache.IncrementVersionAsync("challenge", request.ChallengeId, logger, cancellationToken);
+        
+        logger.LogInformation("Challenge updated successfully.");
+        return ResultT<ResponseDto>.Success(new ResponseDto("Your challenge has been updated successfully!"));
+    }
+
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Queries/GetChallengeById/GetChallengeByIdQuery.cs b/Rex.Application/Modules/Challenges/Queries/GetChallengeById/GetChallengeByIdQuery.cs
new file mode 100644
index 0000000..d359f9a
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Queries/GetChallengeById/GetChallengeByIdQuery.cs
@@ -0,0 +1,10 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Challenge;  
+
+namespace Rex.Application.Modules.Challenges.Queries.GetChallengeById;
+
+public record GetChallengeByIdQuery(
+    Guid ChallengeId,
+    Guid GroupId,
+    Guid UserId
+    ): IQuery<ChallengeDetailsDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Queries/GetChallengeById/GetChallengeByIdQueryHandler.cs b/Rex.Application/Modules/Challenges/Queries/GetChallengeById/GetChallengeByIdQueryHandler.cs
new file mode 100644
index 0000000..8d8c188
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Queries/GetChallengeById/GetChallengeByIdQueryHandler.cs
@@ -0,0 +1,73 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Challenge;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Challenges.Queries.GetChallengeById;
+
+public class GetChallengeByIdQueryHandler(
+    ILogger<GetChallengeByIdQueryHandler> logger,
+    IDistributedCache cache,
+    IGroupRepository groupRepository,
+    IChallengeRepository challengeRepository
+) : IQueryHandler<GetChallengeByIdQuery, ChallengeDetailsDto>
+{
+    public async Task<ResultT<ChallengeDetailsDto>> Handle(GetChallengeByIdQuery request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("The request to get a challenge was empty");
+            return ResultT<ChallengeDetailsDto>.Failure(Error.Failure("400", "The request is invalid"));
+        }
+
+        var group = await groupRepository.GetGroupByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("No group found with id {GroupId}", request.GroupId);
+            return ResultT<ChallengeDetailsDto>.Failure(Error.NotFound("404", "The specified group was not found"));
+        }
+
+        var version = await cache.GetVersionAsync("challenge", request.GroupId, cancellationToken);
+        var cacheKey = $"challenge:details:{request.ChallengeId}:group:{request.GroupId}:version:{version}";
+
+        var challengeDetails = await cache.GetOrCreateAsync(
+            cacheKey,
+            async () =>
+            {
+                var challenge = await challengeRepository.GetByIdAsync(request.ChallengeId, cancellationToken);
+                if (challenge is null || challenge.GroupId != request.GroupId)
+                {
+                    logger.LogWarning("Challenge {ChallengeId} does not exist in group {GroupId}", request.ChallengeId, request.GroupId);
+                    return null!;
+                }
+
+                return new ChallengeDetailsDto(
+                    challenge.Id,
+                    challenge.Title,
+                    challenge.Description,
+                    challenge.Status,
+                    challenge.CoverPhoto,
+                    challenge.Duration
+                );
+            },
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (challengeDetails is null)
+        {
+            return ResultT<ChallengeDetailsDto>.Failure(Error.NotFound("404", "The challenge does not exist in the selected group"));
+        }
+
+        var joined = await challengeRepository.UserAlreadyJoined(request.UserId, request.ChallengeId, cancellationToken);
+        if (!joined)
+        {
+            logger.LogWarning("User {UserId} tried to access challenge {ChallengeId} without joining", request.UserId, request.ChallengeId);
+            return ResultT<ChallengeDetailsDto>.Failure(Error.Failure("403", "You must join the challenge before posting"));
+        }
+
+        return ResultT<ChallengeDetailsDto>.Success(challengeDetails);
+    }
+}
diff --git a/Rex.Application/Modules/Challenges/Queries/GetChallengesByStatus/GetChallengesByStatusQuery.cs b/Rex.Application/Modules/Challenges/Queries/GetChallengesByStatus/GetChallengesByStatusQuery.cs
new file mode 100644
index 0000000..22b67e2
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Queries/GetChallengesByStatus/GetChallengesByStatusQuery.cs
@@ -0,0 +1,13 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Challenge;  
+using Rex.Application.Pagination;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Challenges.Queries.GetChallengesByStatus;
+
+public record GetChallengesByStatusQuery(
+    Guid GroupId,
+    ChallengeStatus Status,
+    int PageNumber,
+    int PageSize
+    ): IQuery<PagedResult<ChallengeGroupDetailsDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Queries/GetChallengesByStatus/GetChallengesByStatusQueryHandler.cs b/Rex.Application/Modules/Challenges/Queries/GetChallengesByStatus/GetChallengesByStatusQueryHandler.cs
new file mode 100644
index 0000000..208b892
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Queries/GetChallengesByStatus/GetChallengesByStatusQueryHandler.cs
@@ -0,0 +1,95 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Challenge;  
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Challenges.Queries.GetChallengesByStatus;
+
+public class GetChallengesByStatusQueryHandler(
+    ILogger<GetChallengesByStatusQueryHandler> logger,
+    IChallengeRepository challengeRepository,
+    IGroupRepository groupRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetChallengesByStatusQuery, PagedResult<ChallengeGroupDetailsDto>>
+{
+    public async Task<ResultT<PagedResult<ChallengeGroupDetailsDto>>> Handle(GetChallengesByStatusQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request for challenges by status.");
+            return ResultT<PagedResult<ChallengeGroupDetailsDto>>.Failure(Error.Failure("400",
+                "Oops! The request cannot be empty."));
+        }
+        
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Group not found for retrieving challenges.");
+            return ResultT<PagedResult<ChallengeGroupDetailsDto>>.Failure(Error.NotFound("404",
+                "Hmm, we couldn't find the specified group."));
+        }
+
+        logger.LogInformation(
+            "Fetching challenges for group with status {Status}. Page {PageNumber}, PageSize {PageSize}.",
+            request.Status, request.PageNumber, request.PageSize);
+        
+        var version = await cache.GetVersionAsync("challenge", request.GroupId, cancellationToken);
+        var cacheKey =
+            $"challenges:group:{request.GroupId}:status:{request.Status}:page:{request.PageNumber}:size:{request.PageSize}:version:{version}";
+
+        var result = await cache.GetOrCreateAsync(
+            cacheKey,
+            async () => await challengeRepository.GetChallengesPaginatedByGroupIdAndStatusAsync(
+                request.GroupId,
+                request.PageNumber,
+                request.PageSize,
+                request.Status,
+                cancellationToken
+            ),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (!result.Items.Any())
+        {
+            logger.LogInformation("No challenges found for group {GroupId} with status {Status}", 
+                request.GroupId, request.Status);
+            return ResultT<PagedResult<ChallengeGroupDetailsDto>>.Success(
+                new PagedResult<ChallengeGroupDetailsDto>([], result.TotalItems, result.ActualPage, result.TotalPages)
+            );
+        }
+
+        var elements = result.Items
+            .Select(c => new ChallengeGroupDetailsDto(
+                c.Id,
+                c.Title,
+                c.Description,
+                c.Status.ToString(),
+                c.CoverPhoto,
+                c.Duration,
+                c.UserChallenges
+                    .Select(uc => uc.User.ProfilePhoto)
+                    .Where(pp => !string.IsNullOrEmpty(pp))
+                    .Take(5)
+                    .ToList(),
+                c.UserChallenges.Count(uc => uc.Status == UserChallengeStatus.Enrolled.ToString())
+            ))
+            .ToList();
+
+        var pagedResult = new PagedResult<ChallengeGroupDetailsDto>(
+            elements,
+            result.TotalItems,
+            result.ActualPage,
+            result.TotalPages
+        );
+
+        logger.LogInformation("Successfully retrieved {Count} challenges for group {GroupId}", 
+            elements.Count, request.GroupId);
+        return ResultT<PagedResult<ChallengeGroupDetailsDto>>.Success(pagedResult);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Queries/GetChallengesByUser/GetChallengesByUserQuery.cs b/Rex.Application/Modules/Challenges/Queries/GetChallengesByUser/GetChallengesByUserQuery.cs
new file mode 100644
index 0000000..bbaa3a7
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Queries/GetChallengesByUser/GetChallengesByUserQuery.cs
@@ -0,0 +1,13 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Challenge;  
+using Rex.Application.Pagination;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Challenges.Queries.GetChallengesByUser;
+
+public record GetChallengesByUserQuery(
+    Guid UserId,
+    UserChallengeStatus Status,
+    int PageNumber,
+    int PageSize
+    ): IQuery<PagedResult<ChallengeUserDetailsDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Challenges/Queries/GetChallengesByUser/GetChallengesByUserQueryHandler.cs b/Rex.Application/Modules/Challenges/Queries/GetChallengesByUser/GetChallengesByUserQueryHandler.cs
new file mode 100644
index 0000000..0e31be8
--- /dev/null
+++ b/Rex.Application/Modules/Challenges/Queries/GetChallengesByUser/GetChallengesByUserQueryHandler.cs
@@ -0,0 +1,95 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Challenge;  
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Challenges.Queries.GetChallengesByUser;
+
+public class GetChallengesByUserQueryHandler(
+    ILogger<GetChallengesByUserQueryHandler> logger,
+    IChallengeRepository challengeRepository,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetChallengesByUserQuery, PagedResult<ChallengeUserDetailsDto>>
+{
+    public async Task<ResultT<PagedResult<ChallengeUserDetailsDto>>> Handle(GetChallengesByUserQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received invalid request for retrieving challenges.");
+            return ResultT<PagedResult<ChallengeUserDetailsDto>>.Failure(Error.Failure("400",
+                "Oops! The request seems invalid. Please try again."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found when fetching challenges.");
+            return ResultT<PagedResult<ChallengeUserDetailsDto>>.Failure(Error.Failure("404",
+                "Hmm, we couldn't find your account. Please check your details."));
+        }
+
+        var result = await cache.GetOrCreateAsync(
+            $"challenges:user:{request.UserId}:status:{request.Status}:page:{request.PageNumber}:size:{request.PageSize}",
+            async () => await challengeRepository.GetChallengesPaginatedByUserIdAndStatusAsync(
+                request.UserId,
+                request.PageNumber,
+                request.PageSize,
+                request.Status,
+                cancellationToken
+            ),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (!result.Items.Any())
+        {
+            logger.LogInformation("No challenges found for user {UserId} with status {Status}", 
+                request.UserId, request.Status);
+            return ResultT<PagedResult<ChallengeUserDetailsDto>>.Success(
+                new PagedResult<ChallengeUserDetailsDto>([], result.TotalItems, result.ActualPage, result.TotalPages)
+            );
+        }
+
+        var elements = result.Items.Select(challenge =>
+        {
+            var userChallenge = challenge.UserChallenges?.FirstOrDefault(uc => uc.UserId == request.UserId);
+            var userChallengeStatus = userChallenge?.Status ?? string.Empty;
+
+            return new ChallengeUserDetailsDto
+            (
+                challenge.Id,
+                challenge.Group.ProfilePhoto,
+                challenge.CoverPhoto,
+                challenge.Title,
+                challenge.Description,
+                userChallengeStatus,
+                challenge.Duration,
+                challenge.Group.Title,
+                challenge.UserChallenges?
+                    .Select(c => c.User.ProfilePhoto)
+                    .Where(photo => !string.IsNullOrEmpty(photo))
+                    .Take(5)
+                    .ToList() ?? [],
+                challenge.UserChallenges?
+                    .Count(c => c.Status == UserChallengeStatus.Enrolled.ToString()) ?? 0
+            );
+        }).ToList();
+
+        var pagedResult = new PagedResult<ChallengeUserDetailsDto>(
+            elements,
+            result.TotalItems,
+            result.ActualPage,
+            result.TotalPages
+        );
+
+        logger.LogInformation("Successfully retrieved {Count} challenges for user {UserId}", 
+            elements.Count, request.UserId);
+        return ResultT<PagedResult<ChallengeUserDetailsDto>>.Success(pagedResult);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Chats/Commands/CreatePrivateChat/CreatePrivateChatCommand.cs b/Rex.Application/Modules/Chats/Commands/CreatePrivateChat/CreatePrivateChatCommand.cs
new file mode 100644
index 0000000..a809d43
--- /dev/null
+++ b/Rex.Application/Modules/Chats/Commands/CreatePrivateChat/CreatePrivateChatCommand.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Chats.Commands.CreatePrivateChat;
+
+public record CreatePrivateChatCommand(
+    Guid UserId,
+    Guid SecondUserId
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Chats/Commands/CreatePrivateChat/CreatePrivateChatCommandHandler.cs b/Rex.Application/Modules/Chats/Commands/CreatePrivateChat/CreatePrivateChatCommandHandler.cs
new file mode 100644
index 0000000..2c71d80
--- /dev/null
+++ b/Rex.Application/Modules/Chats/Commands/CreatePrivateChat/CreatePrivateChatCommandHandler.cs
@@ -0,0 +1,94 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Chats.Commands.CreatePrivateChat;
+
+public class CreatePrivateChatCommandHandler(
+    ILogger<CreatePrivateChatCommandHandler> logger,
+    IUserChatRepository userChatRepository,
+    IChatRepository chatRepository,
+    IUserRepository userRepository,
+    IFriendShipRepository friendShipRepository,
+    IChatNotifier chatNotifier,
+    IDistributedCache cache
+    ) : ICommandHandler<CreatePrivateChatCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(CreatePrivateChatCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received null request to create private chat.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Oops! Something went wrong. The request is invalid."));
+        }
+
+        if (request.UserId == request.SecondUserId)
+        {
+            logger.LogWarning("User {UserId} attempted to create a chat with themselves.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "You cannot start a chat with yourself."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        var secondUser = await userRepository.GetByIdAsync(request.SecondUserId, cancellationToken);
+
+        if (user is null || secondUser is null)
+        {
+            logger.LogWarning("One or both users not found: User1={UserId}, User2={SecondUserId}", request.UserId, request.SecondUserId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "One or both users could not be found."));
+        }
+
+        var friendshipExists = await friendShipRepository.FriendShipExistAsync(request.UserId, secondUser.Id, cancellationToken);
+        if (!friendshipExists)
+        {
+            logger.LogWarning("Failed to create chat between users {UserId} and {SecondUserId} because friendship is inactive.", 
+                request.UserId, request.SecondUserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "You cannot create a chat because the friendship is no longer active."));
+        }
+
+        var chatExists = await chatRepository.GetOneToOneChat(request.UserId, request.SecondUserId, cancellationToken);
+        if (chatExists is not null)
+        {
+            logger.LogInformation("Chat already exists between users {UserId} and {SecondUserId} with ChatId {ChatId}", 
+                request.UserId, request.SecondUserId, chatExists.Id);
+            return ResultT<ResponseDto>.Failure(Error.Conflict("409", "A chat with this user already exists."));
+        }
+
+        var chat = new Models.Chat
+        {
+            Id = Guid.NewGuid(),
+            Type = ChatType.Private.ToString()
+        };
+
+        await chatRepository.CreateAsync(chat, cancellationToken);
+        logger.LogInformation("Created new private chat with ID {ChatId} between users {UserId} and {SecondUserId}",
+            chat.Id, request.UserId, request.SecondUserId);
+
+        var userChats = new List<Models.UserChat>
+        {
+            new() { ChatId = chat.Id, UserId = request.UserId },
+            new() { ChatId = chat.Id, UserId = request.SecondUserId }
+        };
+
+        await userChatRepository.CreateRangeAsync(userChats, cancellationToken);
+        logger.LogInformation("Linked users {UserId} and {SecondUserId} to chat {ChatId}", request.UserId, request.SecondUserId, chat.Id);
+
+        await cache.IncrementVersionAsync("chat", request.UserId, logger, cancellationToken);
+        await cache.IncrementVersionAsync("chat", request.SecondUserId, logger, cancellationToken);
+        logger.LogInformation("Cache invalidated for users {UserId} and {SecondUserId}", request.UserId, request.SecondUserId);
+        
+        await chatNotifier.NotifyChatCreatedAsync(
+            new[] { request.UserId, request.SecondUserId },
+            chat,
+            cancellationToken
+        );
+
+        logger.LogInformation("Notification sent for chat {ChatId} creation to users {UserId} and {SecondUserId}", chat.Id, request.UserId, request.SecondUserId);
+        
+        return ResultT<ResponseDto>.Success(new ResponseDto("Chat created successfully!"));
+    }
+}
diff --git a/Rex.Application/Modules/Chats/Queries/GetChatsByUserId/GetChatsByUserIdQuery.cs b/Rex.Application/Modules/Chats/Queries/GetChatsByUserId/GetChatsByUserIdQuery.cs
new file mode 100644
index 0000000..38b21cf
--- /dev/null
+++ b/Rex.Application/Modules/Chats/Queries/GetChatsByUserId/GetChatsByUserIdQuery.cs
@@ -0,0 +1,12 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Challenge;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Chats.Queries.GetChatsByUserId;
+
+public record GetChatsByUserIdQuery(
+    Guid UserId,
+    int PageNumber,
+    int PageSize,
+    string? SearchTerm = null
+    ): IQuery<PagedResult<ChatLastMessageDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Chats/Queries/GetChatsByUserId/GetChatsByUserIdQueryHandler.cs b/Rex.Application/Modules/Chats/Queries/GetChatsByUserId/GetChatsByUserIdQueryHandler.cs
new file mode 100644
index 0000000..f5197fc
--- /dev/null
+++ b/Rex.Application/Modules/Chats/Queries/GetChatsByUserId/GetChatsByUserIdQueryHandler.cs
@@ -0,0 +1,110 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Challenge;
+using Rex.Application.DTOs.Message;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Chats.Queries.GetChatsByUserId;
+
+public class GetChatsByUserIdQueryHandler(
+    ILogger<GetChatsByUserIdQueryHandler> logger,
+    IUserRepository userRepository,
+    IChatRepository chatRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetChatsByUserIdQuery, PagedResult<ChatLastMessageDto>>
+{
+    public async Task<ResultT<PagedResult<ChatLastMessageDto>>> Handle(GetChatsByUserIdQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("GetChatsByUserIdQuery request is null");
+            return ResultT<PagedResult<ChatLastMessageDto>>.Failure(
+                Error.Failure("400", "The request is invalid."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found with ID {UserId}", request.UserId);
+            return ResultT<PagedResult<ChatLastMessageDto>>.Failure(
+                Error.Failure("404", "The user could not be found."));
+        }
+
+        var searchTerm = request.SearchTerm ?? "all";
+        var version = await cache.GetVersionAsync("chat", request.UserId, cancellationToken);
+        var cacheKey =
+            $"chats:user:{request.UserId}:page:{request.PageNumber}:size:{request.PageSize}:searchTerm:{searchTerm}:version:{version}";
+        
+        var result = await cache.GetOrCreateAsync(
+            cacheKey,
+            async () => await chatRepository.GetChatsWithLastMessageByUserIdAsync(
+                request.UserId, request.PageNumber, request.PageSize, request.SearchTerm, cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (!result.Items.Any())
+        {
+            logger.LogInformation("No chats found for user ID {UserId}", request.UserId);
+            return ResultT<PagedResult<ChatLastMessageDto>>.Success(
+                new PagedResult<ChatLastMessageDto>([], result.TotalItems, result.ActualPage, result.TotalPages)
+            );
+        }
+
+        var chatDtos = result.Items.Select(chat =>
+        {
+            var lastMessage = chat.Messages?
+                .OrderByDescending(m => m.CreatedAt)
+                .FirstOrDefault();
+
+            var lastMessageDto = lastMessage != null
+                ? new LastMessageDto(
+                    lastMessage.Id,
+                    lastMessage.Description,
+                    lastMessage.CreatedAt,
+                    lastMessage.SenderId,
+                    lastMessage.Sender != null 
+                        ? $"{lastMessage.Sender.FirstName} {lastMessage.Sender.LastName}" 
+                        : "Unknown sender",
+                    lastMessage.Sender?.ProfilePhoto ?? ""
+                )
+                : null;
+
+            if (chat.Type == ChatType.Private.ToString())
+            {
+                var otherUser = chat.UserChats?.FirstOrDefault(uc => uc.UserId != request.UserId)?.User;
+                return new ChatLastMessageDto(
+                    chat.Id,
+                    otherUser != null ? $"{otherUser.FirstName} {otherUser.LastName}" : "Unknown user",
+                    chat.Type,
+                    otherUser?.ProfilePhoto ?? "",
+                    lastMessageDto
+                );
+            }
+
+            return new ChatLastMessageDto(
+                chat.Id,
+                chat.Name ?? "Unnamed Group",
+                chat.Type,
+                chat.GroupPhoto ?? "", 
+                lastMessageDto
+            );
+        }).ToList();
+
+        var pagedResult = new PagedResult<ChatLastMessageDto>(
+            chatDtos, 
+            result.TotalItems, 
+            result.ActualPage, 
+            result.TotalPages
+        );
+        
+        logger.LogInformation("Successfully retrieved {Count} chats for user {UserId}", 
+            chatDtos.Count, request.UserId);
+        return ResultT<PagedResult<ChatLastMessageDto>>.Success(pagedResult);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Comments/Commands/CreateComment/CreateCommentCommand.cs b/Rex.Application/Modules/Comments/Commands/CreateComment/CreateCommentCommand.cs
new file mode 100644
index 0000000..0d89044
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Commands/CreateComment/CreateCommentCommand.cs
@@ -0,0 +1,12 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Comment;
+
+namespace Rex.Application.Modules.Comments.Commands.CreateComment;
+
+public record CreateCommentCommand(
+    Guid PostId,
+    Guid UserId,
+    string Description,
+    IEnumerable<IFormFile>? Files = null
+    ):ICommand<CommentDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Comments/Commands/CreateComment/CreateCommentCommandHandler.cs b/Rex.Application/Modules/Comments/Commands/CreateComment/CreateCommentCommandHandler.cs
new file mode 100644
index 0000000..0c14a3f
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Commands/CreateComment/CreateCommentCommandHandler.cs
@@ -0,0 +1,103 @@
+using System.Text.Json;
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Comment;
+using Rex.Application.Helpers;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Modules.Comments.Commands.CreateComment;
+
+public class CreateCommentCommandHandler(
+    ILogger<CreateCommentCommandHandler> logger,
+    IUserRepository userRepository,
+    ICommentRepository commentRepository,
+    IPostRepository postRepository,
+    IFileRepository fileRepository,
+    IEntityFileRepository entityFileRepository,
+    ICloudinaryService cloudinaryService,
+    ICommentsNotifier commentsNotifier,
+    IDistributedCache cache
+) : ICommandHandler<CreateCommentCommand, CommentDto>
+{
+    public async Task<ResultT<CommentDto>> Handle(CreateCommentCommand request, CancellationToken cancellationToken)
+    {
+        logger.LogInformation("Handling CreateCommentCommand for UserId: {UserId}, PostId: {PostId}",
+            request.UserId, request.PostId);
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+            return ResultT<CommentDto>.Failure(Error.NotFound("404", "Oops! The specified user doesn't seem to exist."));
+
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(request.UserId, cancellationToken);
+        if (!accountConfirmed)
+            return ResultT<CommentDto>.Failure(Error.Failure("403", "You need to confirm your account before creating a comment."));
+
+        var post = await postRepository.GetByIdAsync(request.PostId, cancellationToken);
+        if (post is null)
+            return ResultT<CommentDto>.Failure(Error.NotFound("404", "Hmm, we couldn't find the target post."));
+
+        Comment comment = new Comment
+        {
+            Description = request.Description,
+            PostId = request.PostId,
+            UserId = request.UserId,
+            IsPinned = false,
+            Edited = false
+        };
+
+        await commentRepository.CreateAsync(comment, cancellationToken);
+
+        if (request.Files is not null && request.Files.Any())
+        {
+            var filesResult = await ProcessFiles.ProcessFilesAsync(logger, request.Files, comment.Id,
+                fileRepository, entityFileRepository, cloudinaryService, TargetType.Comment, cancellationToken);
+
+            if (!filesResult.IsSuccess)
+                return filesResult.Error;
+        }
+
+        var files = await fileRepository.GetFilesByTargetIdAsync(comment.Id, TargetType.Comment, cancellationToken);
+
+        CommentDto commentDto = new CommentDto(
+            comment.Id,
+            comment.PostId,
+            comment.UserId,
+            comment.Description,
+            comment.IsPinned,
+            comment.Edited,
+            files
+        );
+
+        await cache.IncrementVersionAsync("comments", request.PostId, logger, cancellationToken);
+
+        var metadata = new
+        {
+            PostId = post.Id,
+            PostTitle = post.Title,
+            CommentId = comment.Id,
+            CommentAuthor = $"{user.FirstName} {user.LastName}"
+        };
+
+        var notification = new Notification
+        {
+            Title = "New Comment",
+            Description = $"{user.FirstName} {user.LastName} commented on your post '{post.Title}'",
+            UserId = user.Id,
+            RecipientType = TargetType.User.ToString(),
+            RecipientId = post.UserId,
+            MetadataJson = JsonSerializer.Serialize(metadata),
+            Read = false,
+            CreatedAt = DateTime.UtcNow
+        };
+
+        await commentsNotifier.SendCommentNotification(notification, cancellationToken);
+
+        return ResultT<CommentDto>.Success(commentDto);
+    }
+}
diff --git a/Rex.Application/Modules/Comments/Commands/CreateCommentReply/CreateCommentReplyCommand.cs b/Rex.Application/Modules/Comments/Commands/CreateCommentReply/CreateCommentReplyCommand.cs
new file mode 100644
index 0000000..98ff056
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Commands/CreateCommentReply/CreateCommentReplyCommand.cs
@@ -0,0 +1,13 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Reply;
+
+namespace Rex.Application.Modules.Comments.Commands.CreateCommentReply;
+
+public record CreateCommentReplyCommand(
+    Guid ParentCommentId,
+    Guid PostId,
+    Guid UserId,
+    string Description,
+    IEnumerable<IFormFile>? Files = null 
+        ) : ICommand<ReplyDto>;
diff --git a/Rex.Application/Modules/Comments/Commands/CreateCommentReply/CreateCommentReplyCommandHandler.cs b/Rex.Application/Modules/Comments/Commands/CreateCommentReply/CreateCommentReplyCommandHandler.cs
new file mode 100644
index 0000000..49a49c9
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Commands/CreateCommentReply/CreateCommentReplyCommandHandler.cs
@@ -0,0 +1,152 @@
+using System.Text.Json;
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.File;
+using Rex.Application.DTOs.Reply;
+using Rex.Application.DTOs.User;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+using Rex.Application.Helpers;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.SignalR;
+
+namespace Rex.Application.Modules.Comments.Commands.CreateCommentReply;
+
+public class CreateCommentReplyCommandHandler(
+    ILogger<CreateCommentReplyCommandHandler> logger,
+    IUserRepository userRepository,
+    ICommentRepository commentRepository,
+    ICommentsNotifier commentsNotifier,
+    IPostRepository postRepository,
+    IEntityFileRepository entityFileRepository,
+    IFileRepository fileRepository,
+    ICloudinaryService cloudinaryService,
+    IDistributedCache cache
+) : ICommandHandler<CreateCommentReplyCommand, ReplyDto>
+{
+    public async Task<ResultT<ReplyDto>> Handle(CreateCommentReplyCommand request, CancellationToken cancellationToken)
+    {
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("Create reply failed: User with ID '{UserId}' not found.", request.UserId);
+            return ResultT<ReplyDto>.Failure(Error.NotFound("404", "User not found."));
+        }
+        
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(request.UserId, cancellationToken);
+        if (!accountConfirmed)
+        {
+            logger.LogWarning("User with ID {UserId} tried to create a reply but the account is not confirmed.", request.UserId);
+            return ResultT<ReplyDto>.Failure(Error.Failure("403", "You need to confirm your account before creating a reply."));
+        }
+
+        var post = await postRepository.GetByIdAsync(request.PostId, cancellationToken);
+        if (post is null)
+        {
+            logger.LogWarning("Create reply failed: Post with ID '{PostId}' not found.", request.PostId);
+            return ResultT<ReplyDto>.Failure(Error.NotFound("404", "Post not found."));
+        }
+
+        var parentComment = await commentRepository.GetByIdAsync(request.ParentCommentId, cancellationToken);
+        if (parentComment is null)
+        {
+            logger.LogWarning("Create reply failed: Parent comment with ID '{ParentCommentId}' not found.", request.ParentCommentId);
+            return ResultT<ReplyDto>.Failure(Error.NotFound("404", "Parent comment not found."));
+        }
+
+        var userComment = await userRepository.GetUserByCommentIdAsync(request.ParentCommentId, cancellationToken);
+        if (userComment is null)
+        {
+            logger.LogWarning("Failed to notify reply: Original comment's user not found for ParentCommentId '{ParentCommentId}'", request.ParentCommentId);
+            return ResultT<ReplyDto>.Failure(Error.NotFound("404", "Original comment's user not found."));
+        }
+
+        var reply = new Comment
+        {
+            Id = Guid.NewGuid(),
+            Description = request.Description,
+            PostId = request.PostId,
+            UserId = request.UserId,
+            ParentCommentId = request.ParentCommentId,
+            IsPinned = false,
+            Edited = false
+        };
+
+        await commentRepository.CreateAsync(reply, cancellationToken);
+
+        if (request.Files is not null && request.Files.Any())
+        {
+            var filesResult = await ProcessFiles.ProcessFilesAsync(
+                logger, 
+                request.Files, 
+                reply.Id,
+                fileRepository, 
+                entityFileRepository, 
+                cloudinaryService, 
+                TargetType.Comment, 
+                cancellationToken
+            );
+
+            if (!filesResult.IsSuccess)
+            {
+                return filesResult.Error;
+            }
+        }
+
+        var files = await fileRepository.GetFilesByTargetIdAsync(reply.Id, TargetType.Comment, cancellationToken);
+
+        var replyFiles = files.Where(f => f.EntityFiles.Any(e => e.TargetId == reply.Id)).ToList();
+
+        var replyDto = new ReplyDto(
+            reply.Id,
+            reply.ParentCommentId!.Value,
+            reply.Description,
+            reply.Edited,
+            false,
+            new UserCommentDetailsDto(
+                user.Id,
+                user.FirstName,
+                user.LastName,
+                user.ProfilePhoto
+            ),
+            reply.CreatedAt,
+            replyFiles.Select(c => new FileDetailDto(c.Id,c.Url, c.Type))
+        );
+
+        logger.LogInformation(
+            "Reply created successfully with ID '{ReplyId}', parent comment '{ParentCommentId}', by user '{UserId}' on post '{PostId}'.",
+            reply.Id, reply.ParentCommentId, reply.UserId, reply.PostId
+        );
+        
+        await cache.IncrementVersionAsync("comments", request.ParentCommentId, logger, cancellationToken);
+        logger.LogInformation("Cache invalidated for replies of ParentCommentId: {ParentCommentId}", request.ParentCommentId);
+        
+        var metadata = new
+        {
+            PostId = post.Id,
+            PostTitle = post.Title,
+            CommentId = reply.ParentCommentId,
+            ReplyId = reply.Id,
+            ReplyAuthor = $"{user.FirstName} {user.LastName}"
+        };
+
+        var notification = new Notification
+        {
+            Title = "New Reply",
+            Description = $"{user.FirstName} {user.LastName} replied to your comment on '{post.Title}'",
+            UserId = user.Id,
+            RecipientType = "User",
+            RecipientId = userComment.Id,
+            MetadataJson = JsonSerializer.Serialize(metadata),
+            Read = false,
+            CreatedAt = DateTime.UtcNow
+        };
+
+        await commentsNotifier.SendReplyNotification(notification, cancellationToken);
+        
+        return ResultT<ReplyDto>.Success(replyDto);
+    }
+}
diff --git a/Rex.Application/Modules/Comments/Commands/PinComment/PinCommentCommand.cs b/Rex.Application/Modules/Comments/Commands/PinComment/PinCommentCommand.cs
new file mode 100644
index 0000000..8c718f9
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Commands/PinComment/PinCommentCommand.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Comment;
+
+namespace Rex.Application.Modules.Comments.Commands.PinComment;
+
+public record PinCommentCommand(
+    Guid CommentId,
+    Guid UserId,
+    Guid PostId,
+    bool Pin
+    ):ICommand<CommentUpdatedDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Comments/Commands/PinComment/PinCommentCommandHandler.cs b/Rex.Application/Modules/Comments/Commands/PinComment/PinCommentCommandHandler.cs
new file mode 100644
index 0000000..38cd909
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Commands/PinComment/PinCommentCommandHandler.cs
@@ -0,0 +1,93 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Comment;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Comments.Commands.PinComment;
+
+public class PinCommentCommandHandler(
+    ILogger<PinCommentCommandHandler> logger,
+    ICommentRepository commentRepository,
+    IPostRepository postRepository,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : ICommandHandler<PinCommentCommand, CommentUpdatedDto>
+{
+    public async Task<ResultT<CommentUpdatedDto>> Handle(PinCommentCommand request, CancellationToken cancellationToken)
+    {
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("We couldn't find the user with ID {UserId}.", request.UserId);
+            return ResultT<CommentUpdatedDto>.Failure(Error.NotFound("404", "Oops! We couldnt find that user."));
+        }
+
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(request.UserId, cancellationToken);
+        if (!accountConfirmed)
+        {
+            logger.LogWarning("User {UserId} tried to create a group but the account is not confirmed.",
+                request.UserId);
+            return ResultT<CommentUpdatedDto>.Failure(Error.Failure("403", "You need to confirm your account first."));
+        }
+
+        var post = await postRepository.GetByIdAsync(request.PostId, cancellationToken);
+        if (post is null)
+        {
+            logger.LogWarning("We couldn't find the post with ID {PostId}.", request.PostId);
+            return ResultT<CommentUpdatedDto>.Failure(Error.NotFound("404",
+                "The post you are looking for doesn't exist."));
+        }
+
+        var comment = await commentRepository.GetByIdAsync(request.CommentId, cancellationToken);
+        if (comment is null)
+        {
+            logger.LogWarning("We couldn't find the comment with ID {CommentId}.", request.CommentId);
+            return ResultT<CommentUpdatedDto>.Failure(Error.NotFound("404", "The comment doesn't exist."));
+        }
+
+        if (post.UserId != request.UserId)
+        {
+            logger.LogWarning("User {UserId} tried to pin a comment on a post they don't own. PostId: {PostId}",
+                request.UserId, request.PostId);
+            return ResultT<CommentUpdatedDto>.Failure(Error.Failure("401",
+                "You can't pin comments on a post you don't own."));
+        }
+
+        if (request.Pin)
+        {
+            var alreadyPinned = await commentRepository.CommentAlreadyPinned(request.CommentId, cancellationToken);
+            if (alreadyPinned)
+            {
+                logger.LogWarning("Comment {CommentId} is already pinned.", request.CommentId);
+                return ResultT<CommentUpdatedDto>.Failure(Error.Failure("400", "This comment is already pinned."));
+            }
+
+            var anotherPinned = await commentRepository.AnotherCommentIsPinned(request.PostId, cancellationToken);
+            if (anotherPinned)
+            {
+                logger.LogWarning("Another comment is already pinned on post {PostId}.", request.PostId);
+                return ResultT<CommentUpdatedDto>.Failure(Error.Failure("400",
+                    "There is already a pinned comment on this post."));
+            }
+        }
+
+        comment.IsPinned = request.Pin;
+        await commentRepository.UpdateAsync(comment, cancellationToken);
+        
+        await cache.IncrementVersionAsync("comments", comment.PostId, logger, cancellationToken);
+        logger.LogInformation("Cache invalidated for comments of PostId: {PostId}", comment.PostId);
+
+        var dto = new CommentUpdatedDto(
+            comment.Id,
+            comment.Description,
+            comment.IsPinned,
+            comment.Edited
+        );
+
+        logger.LogInformation("Comment with ID {CommentId} has been successfully {Action}.", comment.Id,
+            request.Pin ? "pinned" : "unpinned");
+        return ResultT<CommentUpdatedDto>.Success(dto);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Comments/Commands/UpdateComment/UpdateCommentCommand.cs b/Rex.Application/Modules/Comments/Commands/UpdateComment/UpdateCommentCommand.cs
new file mode 100644
index 0000000..20cc7a6
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Commands/UpdateComment/UpdateCommentCommand.cs
@@ -0,0 +1,12 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Comment;
+
+namespace Rex.Application.Modules.Comments.Commands.UpdateComment;
+
+public record UpdateCommentCommand(
+    Guid CommentId,
+    string Description,
+    IEnumerable<IFormFile>? NewFiles = null,
+    IEnumerable<Guid>? FilesToDelete = null
+        ): ICommand<CommentUpdatedDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Comments/Commands/UpdateComment/UpdateCommentCommandHandler.cs b/Rex.Application/Modules/Comments/Commands/UpdateComment/UpdateCommentCommandHandler.cs
new file mode 100644
index 0000000..a98aca2
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Commands/UpdateComment/UpdateCommentCommandHandler.cs
@@ -0,0 +1,81 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Comment;
+using Rex.Application.DTOs.File;
+using Rex.Application.Helpers;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Comments.Commands.UpdateComment;
+
+public class UpdateCommentCommandHandler(
+    ILogger<UpdateCommentCommandHandler> logger,
+    ICommentRepository commentRepository,
+    IFileRepository fileRepository,
+    IEntityFileRepository entityFileRepository,
+    ICloudinaryService cloudinaryService,
+    IDistributedCache cache
+) : ICommandHandler<UpdateCommentCommand, CommentUpdatedDto>
+{
+    public async Task<ResultT<CommentUpdatedDto>> Handle(UpdateCommentCommand request,
+        CancellationToken cancellationToken)
+    {
+        logger.LogInformation("Starting update for comment {CommentId}...", request.CommentId);
+
+        var comment = await commentRepository.GetByIdAsync(request.CommentId, cancellationToken);
+        if (comment is null)
+            return ResultT<CommentUpdatedDto>.Failure(
+                Error.NotFound("404", "We couldnt find the comment you wanted to update."));
+
+        if (request.FilesToDelete is not null && request.FilesToDelete.Any())
+        {
+            var filesToDelete =
+                await fileRepository.GetFilesByTargetIdsAsync(request.FilesToDelete, TargetType.Comment,
+                    cancellationToken);
+
+            foreach (var file in filesToDelete)
+            {
+                file.Deleted = true;
+                file.DeletedAt = DateTime.UtcNow;
+                await fileRepository.UpdateAsync(file, cancellationToken);
+            }
+
+            logger.LogInformation("Removed {Count} file(s) from comment {CommentId}", filesToDelete.Count(), comment.Id);
+        }
+
+        if (request.NewFiles is not null && request.NewFiles.Any())
+        {
+            var filesResult = await ProcessFiles.ProcessFilesAsync(
+                logger, request.NewFiles, comment.Id, fileRepository, entityFileRepository,
+                cloudinaryService, TargetType.Comment, cancellationToken);
+
+            if (!filesResult.IsSuccess)
+                return filesResult.Error;
+        }
+
+        comment.Description = request.Description;
+        comment.Edited = true;
+        await commentRepository.UpdateAsync(comment, cancellationToken);
+
+        await cache.IncrementVersionAsync("comments", comment.PostId, logger, cancellationToken);
+        logger.LogInformation("Cache invalidated for comments of PostId: {PostId}", comment.PostId);
+        
+        var currentFiles =
+            await fileRepository.GetFilesByTargetIdAsync(comment.Id, TargetType.Comment, cancellationToken);
+
+        var dto = new CommentUpdatedDto(
+            comment.Id,
+            comment.Description,
+            comment.IsPinned,
+            comment.Edited,
+            currentFiles.Select(f => new FileDetailDto(f.Id,f.Url, f.Type))
+        );
+
+        logger.LogInformation("Comment {CommentId} updated successfully", comment.Id);
+
+        return ResultT<CommentUpdatedDto>.Success(dto);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Comments/Queries/GetCommentReplies/GetCommentRepliesQuery.cs b/Rex.Application/Modules/Comments/Queries/GetCommentReplies/GetCommentRepliesQuery.cs
new file mode 100644
index 0000000..43c14b9
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Queries/GetCommentReplies/GetCommentRepliesQuery.cs
@@ -0,0 +1,12 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Reply;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Comments.Queries.GetCommentReplies;
+
+public record GetCommentRepliesQuery(
+    Guid PostId,
+    Guid ParentCommentId,
+    int PageNumber,
+    int PageSize
+    ): IQuery<PagedResult<ReplyDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Comments/Queries/GetCommentReplies/GetCommentRepliesQueryHandler.cs b/Rex.Application/Modules/Comments/Queries/GetCommentReplies/GetCommentRepliesQueryHandler.cs
new file mode 100644
index 0000000..9e057d8
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Queries/GetCommentReplies/GetCommentRepliesQueryHandler.cs
@@ -0,0 +1,101 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.File;
+using Rex.Application.DTOs.Reply;
+using Rex.Application.DTOs.User;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Comments.Queries.GetCommentReplies;
+
+public class GetCommentRepliesQueryHandler(
+    ILogger<GetCommentRepliesQueryHandler> logger,
+    ICommentRepository commentRepository,
+    IFileRepository fileRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetCommentRepliesQuery, PagedResult<ReplyDto>>
+{
+    public async Task<ResultT<PagedResult<ReplyDto>>> Handle(GetCommentRepliesQuery request,
+        CancellationToken cancellationToken)
+    {
+        logger.LogInformation(
+            "Fetching replies for ParentCommentId: {ParentCommentId}, PostId: {PostId}, Page: {Page}, PageSize: {PageSize}",
+            request.ParentCommentId, request.PostId, request.PageNumber, request.PageSize
+        );
+
+        var version = await cache.GetVersionAsync("comments", request.ParentCommentId, cancellationToken);
+
+        var comments = await cache.GetOrCreateAsync(
+            $"Get:Comment:Replies:{request.ParentCommentId}:{request.PageNumber}:{request.PageSize}:version:{version}:",
+            async () => await commentRepository.GetCommentsRepliedPaginatedByParentCommentIdAsync(
+                request.PostId,
+                request.PageNumber,
+                request.PageSize,
+                request.ParentCommentId,
+                cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (!comments.Items.Any())
+        {
+            logger.LogWarning(
+                "No replies found for ParentCommentId: {ParentCommentId} in PostId: {PostId}.",
+                request.ParentCommentId, request.PostId
+            );
+
+            return ResultT<PagedResult<ReplyDto>>.Failure(Error.NotFound(
+                "404",
+                "We couldn't find any replies for this comment. It may not exist or hasn't received any replies yet."
+            ));
+        }
+
+        var files = await cache.GetOrCreateAsync(
+            $"Get:Comment:Files:Replies:{request.ParentCommentId}:{request.PageNumber}:{request.PageSize}",
+            async () => await fileRepository.GetFilesByTargetIdsAsync(
+                comments.Items.Select(c => c.Id), 
+                TargetType.Comment, 
+                cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        var elements = comments.Items.Select(c =>
+        {
+            var commentFiles = files.Where(f => f.EntityFiles.Any(e => e.TargetId == c.Id))
+                .Select(f => new FileDetailDto(f.Id, f.Url, f.Type));
+
+            return new ReplyDto(
+                c.Id,
+                c.ParentCommentId!.Value, 
+                c.Description,
+                c.Edited,
+                c.Replies.Any(),
+                new UserCommentDetailsDto(
+                    c.UserId,
+                    c.User.FirstName,
+                    c.User.LastName,
+                    c.User.ProfilePhoto),
+                c.CreatedAt,
+                commentFiles
+            );
+        });
+
+        logger.LogInformation(
+            "Successfully retrieved {Count} replies for ParentCommentId: {ParentCommentId}",
+            comments.Items.Count(), request.ParentCommentId
+        );
+
+        var result = new PagedResult<ReplyDto>(
+            elements,
+            comments.TotalItems,
+            comments.ActualPage,
+            comments.TotalPages
+        );
+
+        return ResultT<PagedResult<ReplyDto>>.Success(result);
+    }
+}
diff --git a/Rex.Application/Modules/Comments/Queries/GetCommentsByPostId/GetCommentsByPostIdQuery.cs b/Rex.Application/Modules/Comments/Queries/GetCommentsByPostId/GetCommentsByPostIdQuery.cs
new file mode 100644
index 0000000..d88e816
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Queries/GetCommentsByPostId/GetCommentsByPostIdQuery.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Comment;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Comments.Queries.GetCommentsByPostId;
+
+public record GetCommentsByPostIdQuery(
+    Guid PostId,
+    int PageNumber,
+    int PageSize
+    ): IQuery<PagedResult<CommentDetailsDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Comments/Queries/GetCommentsByPostId/GetCommentsByPostIdQueryHandler.cs b/Rex.Application/Modules/Comments/Queries/GetCommentsByPostId/GetCommentsByPostIdQueryHandler.cs
new file mode 100644
index 0000000..a8eb2bd
--- /dev/null
+++ b/Rex.Application/Modules/Comments/Queries/GetCommentsByPostId/GetCommentsByPostIdQueryHandler.cs
@@ -0,0 +1,91 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Comment;
+using Rex.Application.DTOs.File;
+using Rex.Application.DTOs.Reply;
+using Rex.Application.DTOs.User;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Comments.Queries.GetCommentsByPostId;
+
+public class GetCommentsByPostIdQueryHandler(
+    ILogger<GetCommentsByPostIdQueryHandler> logger,
+    ICommentRepository commentRepository,
+    IFileRepository fileRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetCommentsByPostIdQuery, PagedResult<CommentDetailsDto>>
+{
+    public async Task<ResultT<PagedResult<CommentDetailsDto>>> Handle(GetCommentsByPostIdQuery request,
+        CancellationToken cancellationToken)
+    {
+        logger.LogInformation("Handling GetCommentsByPostIdQuery for PostId: {PostId}, Page: {Page}, Size: {Size}",
+            request.PostId, request.PageNumber, request.PageSize);
+
+        var version = await cache.GetVersionAsync("comments", request.PostId, cancellationToken);
+
+        var comments = await cache.GetOrCreateAsync(
+            $"Get:Comments:By:Post:{request.PostId}:{request.PageNumber}:{request.PageSize}:version:{version}:",
+            async () =>
+            {
+                logger.LogInformation("Cache miss: fetching comments from repository for PostId: {PostId}", request.PostId);
+                return await commentRepository.GetCommentsPaginatedByPostIdAsync(
+                    request.PostId, request.PageNumber, request.PageSize, cancellationToken);
+            },
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (!comments.Items.Any())
+        {
+            logger.LogWarning("No comments found for PostId: {PostId}", request.PostId);
+            return ResultT<PagedResult<CommentDetailsDto>>.Success(
+                new PagedResult<CommentDetailsDto>([], comments.TotalItems, comments.ActualPage, comments.TotalPages));
+        }
+
+        var files = await cache.GetOrCreateAsync(
+            $"Get:Comment:Files:Replies:{request.PostId}:{request.PageNumber}:{request.PageSize}",
+            async () => await fileRepository.GetFilesByTargetIdsAsync(comments.Items.Select(c => c.Id), TargetType.Comment, cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+        
+        logger.LogInformation("Mapping {Count} comments to DTOs for PostId: {PostId}", comments.Items.Count(), request.PostId);
+
+        var elements = comments.Items.Select(c =>
+        {
+            var commentFiles = files.Where(f => f.EntityFiles.Any(e => e.TargetId == c.Id))
+                .Select(f => new FileDetailDto(f.Id, f.Url, f.Type));
+
+            return new CommentDetailsDto(
+                c.Id,
+                c.PostId,
+                c.Description,
+                c.IsPinned,
+                c.Edited,
+                c.Replies.Any(),
+                new UserCommentDetailsDto(
+                    c.UserId,
+                    c.User.FirstName,
+                    c.User.LastName,
+                    c.User.ProfilePhoto),
+                c.CreatedAt,
+                commentFiles
+            );
+        });
+
+        var result = new PagedResult<CommentDetailsDto>(
+            elements,
+            comments.TotalItems,
+            comments.ActualPage,
+            comments.TotalPages
+        );
+
+        logger.LogInformation("Successfully handled GetCommentsByPostIdQuery for PostId: {PostId}", request.PostId);
+
+        return ResultT<PagedResult<CommentDetailsDto>>.Success(result);
+    }
+}
diff --git a/Rex.Application/Modules/Friendships/Commands/CreateRequestFriendship/CreateFriendshipRequestCommand.cs b/Rex.Application/Modules/Friendships/Commands/CreateRequestFriendship/CreateFriendshipRequestCommand.cs
new file mode 100644
index 0000000..7f1d172
--- /dev/null
+++ b/Rex.Application/Modules/Friendships/Commands/CreateRequestFriendship/CreateFriendshipRequestCommand.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Friendships.Commands.CreateRequestFriendship;
+
+public record CreateFriendshipRequestCommand(
+    Guid RequesterId,
+    Guid TargetUserId
+    ):ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Friendships/Commands/CreateRequestFriendship/CreateFriendshipRequestCommandHandler.cs b/Rex.Application/Modules/Friendships/Commands/CreateRequestFriendship/CreateFriendshipRequestCommandHandler.cs
new file mode 100644
index 0000000..72fdb94
--- /dev/null
+++ b/Rex.Application/Modules/Friendships/Commands/CreateRequestFriendship/CreateFriendshipRequestCommandHandler.cs
@@ -0,0 +1,110 @@
+using System.Text.Json;
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Modules.Friendships.Commands.CreateRequestFriendship;
+
+public class CreateFriendshipRequestCommandHandler(
+    ILogger<CreateFriendshipRequestCommandHandler> logger,
+    IFriendShipRepository friendShipRepository,
+    IUserRepository userRepository,
+    IFriendshipNotifier friendshipNotifier,
+    IDistributedCache cache
+) : ICommandHandler<CreateFriendshipRequestCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(CreateFriendshipRequestCommand request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Friendship request command is null");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Invalid friend request."));
+        }
+
+        if (request.RequesterId == request.TargetUserId)
+        {
+            logger.LogWarning("User {UserId} tried to send a friend request to themselves", request.RequesterId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "You can't send a friend request to yourself."));
+        }
+
+        var requester = await userRepository.GetByIdAsync(request.RequesterId, cancellationToken);
+        var targetUser = await userRepository.GetByIdAsync(request.TargetUserId, cancellationToken);
+
+        if (requester is null)
+        {
+            logger.LogWarning("Requester user not found: {UserId}", request.RequesterId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("404", "Requester account not found."));
+        }
+
+        if (targetUser is null)
+        {
+            logger.LogWarning("Target user not found: {UserId}", request.TargetUserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("404", "Target user not found."));
+        }
+
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(request.RequesterId, cancellationToken);
+        if (!accountConfirmed)
+        {
+            logger.LogWarning("User {UserId} tried to send a friend request but the account is not confirmed.", request.RequesterId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "You need to confirm your account before sending a friend request."));
+        }
+
+        var friendshipExists = await friendShipRepository.FriendShipExistAsync(
+            request.RequesterId,
+            request.TargetUserId,
+            cancellationToken
+        );
+
+        if (friendshipExists)
+        {
+            logger.LogWarning("Friendship already exists between {RequesterId} and {TargetUserId}",
+                request.RequesterId, request.TargetUserId);
+
+            return ResultT<ResponseDto>.Failure(Error.Failure("409", "A friend request has already been sent to this user."));
+        }
+
+        var friendship = new FriendShip
+        {
+            RequesterId = request.RequesterId,
+            TargetUserId = request.TargetUserId,
+            Status = RequestStatus.Pending.ToString(),
+            CreatedAt = DateTime.UtcNow
+        };
+
+        await friendShipRepository.CreateAsync(friendship, cancellationToken);
+        
+        await cache.IncrementVersionAsync("friends", request.TargetUserId, logger, cancellationToken);
+        logger.LogInformation("Cache invalidated for friends of UserId: {UserId}", request.TargetUserId);
+
+        var metadata = new
+        {
+            RequesterId = requester.Id,
+            RequesterName = $"{requester.FirstName} {requester.LastName}"
+        };
+
+        var notification = new Notification
+        {
+            Title = "New Friend Request",
+            Description = $"{requester.FirstName} {requester.LastName} sent you a friend request.",
+            UserId = requester.Id,
+            RecipientType = TargetType.User.ToString(),         
+            RecipientId = targetUser.Id,   
+            MetadataJson = JsonSerializer.Serialize(metadata),
+            CreatedAt = DateTime.UtcNow
+        };
+
+        await friendshipNotifier.SendFriendRequestNotification(notification, cancellationToken);
+        
+        logger.LogInformation("Friendship request {FriendshipId} sent from {RequesterId} to {TargetUserId}",
+            friendship.Id, request.RequesterId, request.TargetUserId);
+
+        return ResultT<ResponseDto>.Success(new ResponseDto("Friendship request sent successfully."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Friendships/Commands/DeleteFriendship/DeleteFriendshipCommand.cs b/Rex.Application/Modules/Friendships/Commands/DeleteFriendship/DeleteFriendshipCommand.cs
new file mode 100644
index 0000000..dfd81d5
--- /dev/null
+++ b/Rex.Application/Modules/Friendships/Commands/DeleteFriendship/DeleteFriendshipCommand.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Friendships.Commands.DeleteFriendship;
+
+public record DeleteFriendshipCommand(
+    Guid RequesterId,
+    Guid TargetUserId
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Friendships/Commands/DeleteFriendship/DeleteFriendshipCommandHandler.cs b/Rex.Application/Modules/Friendships/Commands/DeleteFriendship/DeleteFriendshipCommandHandler.cs
new file mode 100644
index 0000000..616f36f
--- /dev/null
+++ b/Rex.Application/Modules/Friendships/Commands/DeleteFriendship/DeleteFriendshipCommandHandler.cs
@@ -0,0 +1,79 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Friendships.Commands.DeleteFriendship;
+
+public class DeleteFriendshipCommandHandler(
+    ILogger<DeleteFriendshipCommandHandler> logger,
+    IChatRepository chatRepository,
+    IFriendShipRepository friendShipRepository,
+    IDistributedCache cache
+) : ICommandHandler<DeleteFriendshipCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(DeleteFriendshipCommand request, CancellationToken cancellationToken)
+    {
+        var friendship = await friendShipRepository.GetFriendShipBetweenUsersAsync(
+            request.RequesterId, request.TargetUserId, cancellationToken);
+
+        if (friendship is null)
+        {
+            logger.LogWarning("Friendship not found between users {RequesterId} and {TargetUserId}.",
+                request.RequesterId, request.TargetUserId);
+
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404",
+                "Friendship between these users does not exist."));
+        }
+
+        if (friendship.RequesterId != request.RequesterId && friendship.TargetUserId != request.RequesterId)
+        {
+            logger.LogWarning("User {UserId} attempted to delete a friendship they are not part of.",
+                request.RequesterId);
+
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "You are not part of this friendship."));
+        }
+
+        var chat = await chatRepository.GetOneToOneChat(request.RequesterId, request.TargetUserId, cancellationToken);
+        if (chat is null)
+        {
+            logger.LogWarning("No chat found for users {RequesterId} and {TargetUserId}.",
+                request.RequesterId, request.TargetUserId);
+
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404",
+                "No chat exists between these users."));
+        }
+
+        if (chat.Deleted || friendship.Deleted)
+        {
+            logger.LogWarning(
+                "Attempt to delete friendship or chat between users {RequesterId} and {TargetUserId} which is already deleted.",
+                request.RequesterId, request.TargetUserId);
+
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "This friendship and its chat have already been deleted."));
+        }
+
+        chat.Deleted = true;
+        chat.DeletedAt = DateTime.UtcNow;
+
+        friendship.Deleted = true;
+        friendship.DeletedAt = DateTime.UtcNow;
+
+        await friendShipRepository.UpdateAsync(friendship, cancellationToken);
+        await chatRepository.UpdateAsync(chat, cancellationToken);
+
+        await cache.IncrementVersionAsync("friends", request.RequesterId, logger, cancellationToken);
+        await cache.IncrementVersionAsync("friends", request.TargetUserId, logger, cancellationToken);
+        logger.LogInformation("Cache invalidated for friends of UserIds: {RequesterId}, {TargetUserId}", request.RequesterId, request.TargetUserId);
+
+        logger.LogInformation(
+            "Friendship and associated chat between users {RequesterId} and {TargetUserId} marked as deleted.",
+            request.RequesterId, request.TargetUserId);
+
+        return ResultT<ResponseDto>.Success(
+            new ResponseDto("Friendship successfully deleted and chat deactivated."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Friendships/Commands/ManageFriendshipRequest/ManageFriendshipRequestCommand.cs b/Rex.Application/Modules/Friendships/Commands/ManageFriendshipRequest/ManageFriendshipRequestCommand.cs
new file mode 100644
index 0000000..cf2f557
--- /dev/null
+++ b/Rex.Application/Modules/Friendships/Commands/ManageFriendshipRequest/ManageFriendshipRequestCommand.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Friendships.Commands.ManageFriendshipRequest;
+
+public record ManageFriendshipRequestCommand(
+    Guid RequesterId,
+    Guid TargetUserId,
+    ManageRequestStatus Status
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Friendships/Commands/ManageFriendshipRequest/ManageFriendshipRequestCommandHandler.cs b/Rex.Application/Modules/Friendships/Commands/ManageFriendshipRequest/ManageFriendshipRequestCommandHandler.cs
new file mode 100644
index 0000000..af48c85
--- /dev/null
+++ b/Rex.Application/Modules/Friendships/Commands/ManageFriendshipRequest/ManageFriendshipRequestCommandHandler.cs
@@ -0,0 +1,99 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Friendships.Commands.ManageFriendshipRequest;
+
+public class ManageFriendshipRequestCommandHandler(
+    ILogger<ManageFriendshipRequestCommandHandler> logger,
+    IFriendShipRepository friendShipRepository,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : ICommandHandler<ManageFriendshipRequestCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(ManageFriendshipRequestCommand request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received a null ManageFriendshipRequestCommand");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Invalid request. Please try again."));
+        }
+
+        if (request.RequesterId == request.TargetUserId)
+        {
+            logger.LogWarning("User {UserId} attempted to respond to their own friend request", request.RequesterId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "You cannot respond to your own friend request."));
+        }
+
+        var requester = await userRepository.GetByIdAsync(request.RequesterId, cancellationToken);
+        var targetUser = await userRepository.GetByIdAsync(request.TargetUserId, cancellationToken);
+        
+        if (requester is null)
+        {
+            logger.LogWarning("Requester user {UserId} not found", request.RequesterId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("404", "Your account could not be found."));
+        }
+
+        if (targetUser is null)
+        {
+            logger.LogWarning("Target user {UserId} not found", request.TargetUserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("404",
+                "The user you are trying to respond to could not be found."));
+        }
+
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(request.RequesterId, cancellationToken);
+        if (!accountConfirmed)
+        {
+            logger.LogWarning("User with ID {UserId} tried to respond but the account is not confirmed.", request.RequesterId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "You need to confirm your account first."));
+        }
+        
+        var friendship = await friendShipRepository.GetFriendShipInPendingAsync(request.RequesterId,
+            request.TargetUserId,
+            cancellationToken
+        );
+
+        if (friendship is null)
+        {
+            logger.LogWarning(
+                "No pending friendship request found between requester {RequesterId} and target {TargetUserId}",
+                request.RequesterId, request.TargetUserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("404",
+                "No pending friend request was found between these users."));
+        }
+
+        if (friendship.Status != RequestStatus.Pending.ToString())
+        {
+            logger.LogWarning("Friendship request between {RequesterId} and {TargetUserId} has already been processed",
+                request.RequesterId, request.TargetUserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("409",
+                "This friend request has already been responded to."));
+        }
+
+        friendship.Status = request.Status.ToString();
+        friendship.UpdatedAt = DateTime.UtcNow;
+        await friendShipRepository.UpdateAsync(friendship, cancellationToken);
+
+        logger.LogInformation(
+            "Friendship request from {RequesterId} to {TargetUserId} was {Status}",
+            request.RequesterId,
+            request.TargetUserId,
+            request.Status
+        );
+
+        await cache.IncrementVersionAsync("friends", request.RequesterId, logger, cancellationToken);
+        await cache.IncrementVersionAsync("friends", request.TargetUserId, logger, cancellationToken);
+        logger.LogInformation("Cache invalidated for friends of UserIds: {RequesterId}, {TargetUserId}", request.RequesterId, request.TargetUserId);
+
+        var message = request.Status == ManageRequestStatus.Accepted
+            ? "Friend request accepted successfully."
+            : "Friend request rejected successfully.";
+
+        return ResultT<ResponseDto>.Success(new ResponseDto(message));
+    }
+}
diff --git a/Rex.Application/Modules/Friendships/Queries/GetFriendshipsRequest/GetFriendshipsRequestQuery.cs b/Rex.Application/Modules/Friendships/Queries/GetFriendshipsRequest/GetFriendshipsRequestQuery.cs
new file mode 100644
index 0000000..ee68d25
--- /dev/null
+++ b/Rex.Application/Modules/Friendships/Queries/GetFriendshipsRequest/GetFriendshipsRequestQuery.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Friendship;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Friendships.Queries.GetFriendshipsRequest;
+
+public record GetFriendshipsRequestQuery(
+    Guid UserId,
+    int PageNumber,
+    int PageSize
+    ): IQuery<PagedResult<FriendshipRequestDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Friendships/Queries/GetFriendshipsRequest/GetFriendshipsRequestQueryHandler.cs b/Rex.Application/Modules/Friendships/Queries/GetFriendshipsRequest/GetFriendshipsRequestQueryHandler.cs
new file mode 100644
index 0000000..bdaa5a6
--- /dev/null
+++ b/Rex.Application/Modules/Friendships/Queries/GetFriendshipsRequest/GetFriendshipsRequestQueryHandler.cs
@@ -0,0 +1,79 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Friendship;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Friendships.Queries.GetFriendshipsRequest;
+
+public class GetFriendshipsRequestQueryHandler(
+    ILogger<GetFriendshipsRequestQueryHandler> logger,
+    IFriendShipRepository friendShipRepository,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetFriendshipsRequestQuery, PagedResult<FriendshipRequestDto>>
+{
+    public async Task<ResultT<PagedResult<FriendshipRequestDto>>> Handle(GetFriendshipsRequestQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("GetFriendshipsRequestQuery is null");
+            return ResultT<PagedResult<FriendshipRequestDto>>.Failure(
+                Error.Failure("400", "Oops! Something went wrong with your request. Please try again."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User {UserId} not found", request.UserId);
+            return ResultT<PagedResult<FriendshipRequestDto>>.Failure(
+                Error.NotFound("404", "We couldn't find your account. Please log in again."));
+        }
+
+        var version = await cache.GetVersionAsync("friends", request.UserId, cancellationToken);
+        var cacheKey = $"get:friendships:by:{request.UserId}:{request.PageNumber}:{request.PageSize}:version:{version}";
+        
+        var friendship = await cache.GetOrCreateAsync(
+            cacheKey,
+            async () => await friendShipRepository.GetFriendShipRequestsByUserIdAsync(request.UserId,
+                request.PageNumber, request.PageSize, RequestStatus.Pending,
+                cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+        
+        if (!friendship.Items.Any())
+        {
+            logger.LogInformation("No pending friend requests found for user {UserId}", request.UserId);
+            return ResultT<PagedResult<FriendshipRequestDto>>.Success(
+                new PagedResult<FriendshipRequestDto>([], friendship.TotalItems, friendship.ActualPage,
+                    request.PageSize));
+        }
+
+        var elements = friendship.Items.Select(c => new FriendshipRequestDto(
+                c.Id,
+                c.Requester.Id,
+                $"{c.Requester.FirstName} {c.Requester.LastName}",
+                c.Status.ToString(),
+                c.Requester.ProfilePhoto,
+                c.CreatedAt
+            ))
+            .ToList();
+
+        var result = new PagedResult<FriendshipRequestDto>(
+            items: elements,
+            totalItems: friendship.TotalItems,
+            actualPage: friendship.ActualPage,
+            pageSize: request.PageSize
+        );
+        
+        logger.LogInformation("Successfully retrieved {Count} friend requests for user {UserId}", 
+            elements.Count, request.UserId);
+        
+        return ResultT<PagedResult<FriendshipRequestDto>>.Success(result);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/CreateGroup/CreateGroupCommand.cs b/Rex.Application/Modules/Groups/Commands/CreateGroup/CreateGroupCommand.cs
new file mode 100644
index 0000000..662347d
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/CreateGroup/CreateGroupCommand.cs
@@ -0,0 +1,15 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Commands;
+
+public record CreateGroupCommand(
+    Guid UserId,
+    IFormFile ProfilePhoto,
+    IFormFile? CoverPhoto,
+    string Title,
+    string Description,
+    GroupVisibility Visibility
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/CreateGroup/CreateGroupCommandHandler.cs b/Rex.Application/Modules/Groups/Commands/CreateGroup/CreateGroupCommandHandler.cs
new file mode 100644
index 0000000..58e7d80
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/CreateGroup/CreateGroupCommandHandler.cs
@@ -0,0 +1,95 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+using GroupRole = Rex.Enum.GroupRole;
+
+namespace Rex.Application.Modules.Groups.Commands;
+
+public class CreateGroupCommandHandler(
+    ILogger<CreateGroupCommandHandler> logger,
+    IGroupRepository groupRepository,
+    ICloudinaryService cloudinaryService,
+    IGroupRoleRepository groupRoleRepository,
+    IUserGroupRepository userGroupRepository,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : ICommandHandler<CreateGroupCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(CreateGroupCommand request, CancellationToken cancellationToken)
+    {
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User with ID {UserId} not found.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "The user does not exist or could not be found."));
+        }
+
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(request.UserId, cancellationToken);
+        if (!accountConfirmed)
+        {
+            logger.LogWarning("User with ID {UserId} tried to create a group but the account is not confirmed.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "You need to confirm your account before creating a group."));
+        }
+
+        string profileUrl = "";
+        if (request.ProfilePhoto != null)
+        {
+            logger.LogInformation("Uploading profile image for group '{GroupTitle}'...", request.Title);
+            await using var stream = request.ProfilePhoto.OpenReadStream();
+            profileUrl = await cloudinaryService.UploadImageAsync(stream, request.ProfilePhoto.FileName, cancellationToken);
+            logger.LogInformation("Profile image uploaded successfully for group '{GroupTitle}'", request.Title);
+        }
+
+        string coverUrl = "";
+        if (request.CoverPhoto != null)
+        {
+            logger.LogInformation("Uploading banner image for group '{GroupTitle}'...", request.Title);
+            await using var stream = request.CoverPhoto.OpenReadStream();
+            coverUrl = await cloudinaryService.UploadImageAsync(stream, request.CoverPhoto.FileName, cancellationToken);
+            logger.LogInformation("Banner image uploaded successfully for group '{GroupTitle}'", request.Title);
+        }
+
+        Group group = new()
+        {
+            Id = Guid.NewGuid(),
+            Title = request.Title,
+            Description = request.Description,
+            Visibility = request.Visibility.ToString(),
+            ProfilePhoto = profileUrl,
+            CoverPhoto = coverUrl
+        };
+
+        await groupRepository.CreateAsync(group, cancellationToken);
+        logger.LogInformation("Group '{GroupTitle}' created successfully with ID {GroupId}", group.Title, group.Id);
+
+        var leaderRole = await groupRoleRepository.GetRoleByNameAsync(GroupRole.Leader, cancellationToken);
+        if (leaderRole == null)
+        {
+            logger.LogError("Group role 'Leader' not found for group '{GroupTitle}'", group.Title);
+            return ResultT<ResponseDto>.Failure(Error.Failure("404", "Leader role not found to assign."));
+        }
+
+        UserGroup userGroup = new()
+        {
+            UserId = request.UserId,
+            GroupId = group.Id,
+            GroupRoleId = leaderRole.Id,
+            Status = RequestStatus.Accepted.ToString(),
+            RequestedAt = DateTime.UtcNow
+        };
+
+        await userGroupRepository.CreateAsync(userGroup, cancellationToken);
+        logger.LogInformation("User with ID {UserId} assigned as Leader to group '{GroupTitle}'", request.UserId, group.Title);
+        
+        await cache.IncrementVersionAsync("groups", request.UserId, logger, cancellationToken);
+
+        return ResultT<ResponseDto>.Success(new ResponseDto("Group created successfully! You are now the leader of the group."));
+    }
+}
diff --git a/Rex.Application/Modules/Groups/Commands/DeleteGroup/DeleteGroupCommand.cs b/Rex.Application/Modules/Groups/Commands/DeleteGroup/DeleteGroupCommand.cs
new file mode 100644
index 0000000..a9e6860
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/DeleteGroup/DeleteGroupCommand.cs
@@ -0,0 +1,10 @@
+using System.Windows.Input;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Groups.Commands.DeleteGroup;
+
+public record DeleteGroupCommand(
+    Guid GroupId,
+    Guid UserId
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/DeleteGroup/DeleteGroupCommandHandler.cs b/Rex.Application/Modules/Groups/Commands/DeleteGroup/DeleteGroupCommandHandler.cs
new file mode 100644
index 0000000..0b72a09
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/DeleteGroup/DeleteGroupCommandHandler.cs
@@ -0,0 +1,62 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Commands.DeleteGroup;
+
+public class DeleteGroupCommandHandler(
+    ILogger<DeleteGroupCommandHandler> logger,
+    IGroupRepository groupRepository,
+    IUserRepository userRepository,
+    IUserGroupRepository userGroupRepository,
+    IDistributedCache cache
+) : ICommandHandler<DeleteGroupCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(DeleteGroupCommand request, CancellationToken cancellationToken)
+    {
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("We couldn't find the group with ID {GroupId}.", request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("404", "Oops! We couldn't find the group you're looking for."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("We couldn't find the user with ID {UserId}.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("404", "Oops! We couldn't find the user."));
+        }
+
+        var userInGroup = await userGroupRepository.IsUserInGroupAsync(request.UserId, request.GroupId,
+            RequestStatus.Accepted, cancellationToken);
+        if (!userInGroup)
+        {
+            logger.LogWarning("User with ID {UserId} is not a member of the group with ID {GroupId}.", request.UserId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "It seems you're not part of this group."));
+        }
+
+        var isUserGroupLeader =
+            await userGroupRepository.GetMemberAsync(request.UserId, request.GroupId, cancellationToken);
+        
+        if (isUserGroupLeader.GroupRole.Role == GroupRole.Leader.ToString())
+        {
+            logger.LogWarning("User with ID {UserId} does not have permission to delete group {GroupId}.", request.UserId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "Only the group leader can delete the group."));
+        }
+
+        logger.LogInformation("Deleting the group with ID {GroupId}.", request.GroupId);
+        await groupRepository.DeleteAsync(group, cancellationToken);
+        
+        await cache.IncrementVersionAsync("groups", request.UserId, logger, cancellationToken);
+        await cache.IncrementVersionAsync("groups-user", request.UserId, logger, cancellationToken);
+        await cache.IncrementVersionAsync("group-members", request.GroupId, logger, cancellationToken);
+        await cache.IncrementVersionAsync("group-requests", request.GroupId, logger, cancellationToken);
+
+        return ResultT<ResponseDto>.Success(new ResponseDto("The group has been successfully deleted!"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/GroupUserModeration/GroupUserModerationCommand.cs b/Rex.Application/Modules/Groups/Commands/GroupUserModeration/GroupUserModerationCommand.cs
new file mode 100644
index 0000000..63a9705
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/GroupUserModeration/GroupUserModerationCommand.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Commands.GroupUserModeration;
+
+public record GroupUserModerationCommand(
+    Guid MemberId,
+    Guid GroupId,
+    GroupUserModerationStatus Status
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/GroupUserModeration/GroupUserModerationCommandHandler.cs b/Rex.Application/Modules/Groups/Commands/GroupUserModeration/GroupUserModerationCommandHandler.cs
new file mode 100644
index 0000000..5891ff5
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/GroupUserModeration/GroupUserModerationCommandHandler.cs
@@ -0,0 +1,65 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Commands.GroupUserModeration;
+
+public class GroupUserModerationCommandHandler(
+    ILogger<GroupUserModerationCommandHandler> logger,
+    IUserGroupRepository userGroupRepository,
+    IGroupRepository groupRepository,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : ICommandHandler<GroupUserModerationCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(GroupUserModerationCommand request, CancellationToken cancellationToken)
+    {
+        var user = await userRepository.GetByIdAsync(request.MemberId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("Tried to update status, but user {UserId} does not exist", request.MemberId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Oops! We couldnt find that user."));
+        }
+
+        var group = await groupRepository.GetGroupByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Tried to update status in group {GroupId}, but the group does not exist", request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Hmm that group doesnt exist."));
+        }
+
+        var member = await userGroupRepository.GetMemberAsync(request.MemberId, request.GroupId, cancellationToken);
+        if (member is null)
+        {
+            logger.LogWarning("User {UserId} is not part of group {GroupId}", request.MemberId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Looks like this user isnt part of the group."));
+        }
+
+        var alreadyBanned = await userGroupRepository.IsUserBannedAsync(request.MemberId, request.GroupId, cancellationToken);
+        if (alreadyBanned)
+        {
+            logger.LogWarning("User {UserId} is already banned from group {GroupId}", request.MemberId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "This user is already banned from the group."));
+        }
+
+        if (member.Status == GroupUserModerationStatus.Removed.ToString())
+        {
+            logger.LogWarning("User {UserId} is already removed from group {GroupId}", request.MemberId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "This user has already been removed from the group."));
+        }
+
+        member.Status = request.Status.ToString();
+        member.UpdatedAt = DateTime.UtcNow;
+        await userGroupRepository.UpdateAsync(member, cancellationToken);
+        
+        await cache.IncrementVersionAsync("group-members", request.GroupId, logger, cancellationToken);
+        await cache.IncrementVersionAsync("groups-user", request.MemberId, logger, cancellationToken);
+
+        logger.LogInformation("User {UserId} status updated to {Status} in group {GroupId}", request.MemberId, request.Status, request.GroupId);
+        return ResultT<ResponseDto>.Success(new ResponseDto($"Great! The user is now {request.Status}"));
+    }
+}
diff --git a/Rex.Application/Modules/Groups/Commands/ManageRequest/ManageRequestCommand.cs b/Rex.Application/Modules/Groups/Commands/ManageRequest/ManageRequestCommand.cs
new file mode 100644
index 0000000..155796f
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/ManageRequest/ManageRequestCommand.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Commands.ManageRequest;
+
+public record ManageRequestCommand(
+    Guid UserId,
+    Guid GroupId,
+    ManageRequestStatus Status
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/ManageRequest/ManageRequestCommandHandler.cs b/Rex.Application/Modules/Groups/Commands/ManageRequest/ManageRequestCommandHandler.cs
new file mode 100644
index 0000000..e47a4f2
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/ManageRequest/ManageRequestCommandHandler.cs
@@ -0,0 +1,76 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Commands.ManageRequest;
+
+public class ManageRequestCommandHandler(
+    ILogger<ManageRequestCommandHandler> logger,
+    IGroupRepository groupRepository,
+    IUserRepository userRepository,
+    IUserGroupRepository userGroupRepository,
+    IDistributedCache cache
+) : ICommandHandler<ManageRequestCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(ManageRequestCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("ApproveRequestCommand received is null");
+            return ResultT<ResponseDto>.Failure(
+                Error.Failure("400", "Oops! We didn't receive a valid request to approve."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User with ID {UserId} not found", request.UserId);
+            return ResultT<ResponseDto>.Failure(
+                Error.NotFound("404", "We couldn't find the user youre trying to approve."));
+        }
+
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Group with ID {GroupId} not found", request.GroupId);
+            return ResultT<ResponseDto>.Failure(
+                Error.NotFound("404", "The group youre trying to approve a member for does not exist."));
+        }
+
+        var requestExists =
+            await userGroupRepository.GetGroupRequestAsync(request.UserId, request.GroupId, cancellationToken);
+        if (requestExists is null)
+        {
+            logger.LogWarning("No pending request found for user {UserId} in group {GroupId}", request.UserId,
+                request.GroupId);
+            return ResultT<ResponseDto>.Failure(
+                Error.NotFound("404", "There is no pending join request from this user to approve."));
+        }
+        
+        if (requestExists.Status != RequestStatus.Pending.ToString())
+        {
+            logger.LogWarning("Cannot approve request for user {UserId} in group {GroupId} because it is {Status}", 
+                request.UserId, request.GroupId, requestExists.Status);
+
+            return ResultT<ResponseDto>.Failure(
+                Error.Conflict("409", $"Cannot approve this request because it is already {requestExists.Status}."));
+        }
+
+        requestExists.Status = request.Status.ToString();
+        await userGroupRepository.UpdateAsync(requestExists, cancellationToken);
+
+        logger.LogInformation("Join request from user {UserId} for group {GroupId} approved successfully",
+            request.UserId, request.GroupId);
+        
+        await cache.IncrementVersionAsync("group-members", request.GroupId, logger, cancellationToken);
+        await cache.IncrementVersionAsync("group-requests", request.GroupId, logger, cancellationToken);
+        await cache.IncrementVersionAsync("group", request.GroupId, logger, cancellationToken);
+
+        return ResultT<ResponseDto>.Success(
+            new ResponseDto("The user's request to join the group has been approved successfully!"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/RequestToJoinGroup/RequestToJoinGroupCommand.cs b/Rex.Application/Modules/Groups/Commands/RequestToJoinGroup/RequestToJoinGroupCommand.cs
new file mode 100644
index 0000000..03233cf
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/RequestToJoinGroup/RequestToJoinGroupCommand.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Groups.Commands.RequestToJoinGroupCommand;
+
+public record RequestToJoinGroupCommand(
+    Guid UserId,
+    Guid GroupId
+    ):ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/RequestToJoinGroup/RequestToJoinGroupCommandHandler.cs b/Rex.Application/Modules/Groups/Commands/RequestToJoinGroup/RequestToJoinGroupCommandHandler.cs
new file mode 100644
index 0000000..ddce15a
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/RequestToJoinGroup/RequestToJoinGroupCommandHandler.cs
@@ -0,0 +1,101 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+using GroupRole = Rex.Enum.GroupRole;
+
+namespace Rex.Application.Modules.Groups.Commands.RequestToJoinGroupCommand;
+
+public class RequestToJoinGroupCommandHandler(
+    ILogger<RequestToJoinGroupCommandHandler> logger,
+    IUserRepository userRepository,
+    IGroupRepository groupRepository,
+    IUserGroupRepository userGroupRepository,
+    IGroupRoleRepository groupRoleRepository,
+    IDistributedCache cache
+) : ICommandHandler<RequestToJoinGroupCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(RequestToJoinGroupCommand request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Request to join group command is null");
+            return ResultT<ResponseDto>.Failure(
+                Error.Failure("400", "Oops! No request data was provided."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User with ID {UserId} not found", request.UserId);
+            return ResultT<ResponseDto>.Failure(
+                Error.NotFound("404", "We couldnt find your account."));
+        }
+
+        var group = await groupRepository.GetGroupByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Group with ID {GroupId} not found", request.GroupId);
+            return ResultT<ResponseDto>.Failure(
+                Error.NotFound("404", "The group you are trying to join does not exist."));
+        }
+
+        var isUserInGroup = await userGroupRepository.IsUserInGroupAsync(
+            request.UserId, request.GroupId, RequestStatus.Accepted, cancellationToken);
+        if (isUserInGroup)
+        {
+            logger.LogWarning("User {UserId} is already a member of group {GroupId}", request.UserId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(
+                Error.Conflict("409", "You are already a member of this group."));
+        }
+
+        var isUserBanned =
+            await userGroupRepository.IsUserBannedAsync(request.UserId, request.GroupId, cancellationToken);
+        if (isUserBanned)
+        {
+            logger.LogWarning("User {UserId} is banned from group {GroupId}", request.UserId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(
+                Error.Conflict("409", "You cant join this group because youve been banned."));
+        }
+
+        var pendingRequest =
+            await userGroupRepository.RequestExistsAsync(request.UserId, request.GroupId, cancellationToken);
+        if (pendingRequest)
+        {
+            logger.LogWarning("User {UserId} already has a pending request to join group {GroupId}", request.UserId,
+                request.GroupId);
+            return ResultT<ResponseDto>.Failure(
+                Error.Conflict("409", "You already have a pending request for this group. Please wait for approval."));
+        }
+
+        var role = await groupRoleRepository.GetRoleByNameAsync(GroupRole.Member, cancellationToken);
+        if (role is null)
+        {
+            logger.LogError("Group role 'Member' not found in the database");
+            return ResultT<ResponseDto>.Failure(
+                Error.Failure("400", "Something went wrong. Group role 'Member' is missing."));
+        }
+
+        var userGroup = new UserGroup
+        {
+            UserId = request.UserId,
+            GroupId = request.GroupId,
+            GroupRoleId = role.Id,
+            Status = RequestStatus.Pending.ToString(),
+            RequestedAt = DateTime.UtcNow
+        };
+
+        await userGroupRepository.CreateAsync(userGroup, cancellationToken);
+        logger.LogInformation("User {UserId} requested to join group {GroupId}", request.UserId, request.GroupId);
+        
+        await cache.IncrementVersionAsync("group-requests", request.GroupId, logger, cancellationToken);
+        
+        return ResultT<ResponseDto>.Success(
+            new ResponseDto("Your request to join the group has been sent! The admin will review it shortly."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/UpdateGroup/UpdateGroupCommand.cs b/Rex.Application/Modules/Groups/Commands/UpdateGroup/UpdateGroupCommand.cs
new file mode 100644
index 0000000..3b80120
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/UpdateGroup/UpdateGroupCommand.cs
@@ -0,0 +1,15 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Commands.UpdateGroup;
+
+public record UpdateGroupCommand(
+    Guid GroupId,
+    IFormFile? ProfilePhoto,
+    IFormFile? CoverPhoto,
+    string? Title,
+    string? Description,
+    GroupVisibility? Visibility
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/UpdateGroup/UpdateGroupCommandHandler.cs b/Rex.Application/Modules/Groups/Commands/UpdateGroup/UpdateGroupCommandHandler.cs
new file mode 100644
index 0000000..b53244a
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/UpdateGroup/UpdateGroupCommandHandler.cs
@@ -0,0 +1,68 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Groups.Commands.UpdateGroup;
+
+public class UpdateGroupCommandHandler(
+    ILogger<UpdateGroupCommandHandler> logger,
+    IGroupRepository groupRepository,
+    ICloudinaryService cloudinaryService,
+    IDistributedCache cache
+) : ICommandHandler<UpdateGroupCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(UpdateGroupCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("UpdateGroupCommand request is null.");
+            return ResultT<ResponseDto>.Failure(
+                Error.Failure("400", "Oops! No data was provided to update the group."));
+        }
+
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Group with ID {GroupId} not found.", request.GroupId);
+            return ResultT<ResponseDto>.Failure(
+                Error.Failure("404", "We couldnt find the group you want to update."));
+        }
+
+        if (request.ProfilePhoto is not null)
+        {
+            logger.LogInformation("Uploading new profile image for group {GroupId}...", request.GroupId);
+            await using var stream = request.ProfilePhoto.OpenReadStream();
+            var profileUrl =
+                await cloudinaryService.UploadImageAsync(stream, request.ProfilePhoto.FileName, cancellationToken);
+            group.ProfilePhoto = profileUrl;
+            logger.LogInformation("Profile image uploaded successfully for group {GroupId}.", request.GroupId);
+        }
+
+        if (request.CoverPhoto is not null)
+        {
+            logger.LogInformation("Uploading new banner image for group {GroupId}...", request.GroupId);
+            await using var stream = request.CoverPhoto.OpenReadStream();
+            var coverUrl =
+                await cloudinaryService.UploadImageAsync(stream, request.CoverPhoto.FileName, cancellationToken);
+            group.CoverPhoto = coverUrl;
+            logger.LogInformation("Banner image uploaded successfully for group {GroupId}.", request.GroupId);
+        }
+
+        group.Title = request.Title;
+        group.Description = request.Description;
+        group.Visibility = request.Visibility.ToString();
+        group.UpdatedAt = DateTime.UtcNow;
+
+        await groupRepository.UpdateAsync(group, cancellationToken);
+        
+        await cache.IncrementVersionAsync("group", group.Id, logger, cancellationToken);
+
+        logger.LogInformation("Group with ID {GroupId} updated successfully.", request.GroupId);
+        return ResultT<ResponseDto>.Success(
+            new ResponseDto("The group has been updated successfully!"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/UpdateGroupRoleMember/UpdateGroupRoleMemberCommand.cs b/Rex.Application/Modules/Groups/Commands/UpdateGroupRoleMember/UpdateGroupRoleMemberCommand.cs
new file mode 100644
index 0000000..053b75a
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/UpdateGroupRoleMember/UpdateGroupRoleMemberCommand.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Commands.UpdateGroupRoleMember;
+
+public record UpdateGroupRoleMemberCommand(
+    Guid UserId,
+    Guid GroupId,
+    GroupRole Role
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Commands/UpdateGroupRoleMember/UpdateGroupRoleMemberCommandHandler.cs b/Rex.Application/Modules/Groups/Commands/UpdateGroupRoleMember/UpdateGroupRoleMemberCommandHandler.cs
new file mode 100644
index 0000000..9566068
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Commands/UpdateGroupRoleMember/UpdateGroupRoleMemberCommandHandler.cs
@@ -0,0 +1,64 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Groups.Commands.UpdateGroupRoleMember;
+
+public class UpdateGroupRoleMemberCommandHandler(
+    ILogger<UpdateGroupRoleMemberCommandHandler> logger,
+    IUserGroupRepository userGroupRepository,
+    IGroupRepository groupRepository,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : ICommandHandler<UpdateGroupRoleMemberCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(UpdateGroupRoleMemberCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("UpdateGroupRoleMemberCommand received a null request.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Oops! Something went wrong with the request. Please try again."));
+        }
+
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Group with ID {GroupId} was not found.", request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "The group you're trying to update doesn't exist."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User with ID {UserId} was not found.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "The user was not found."));
+        }
+
+        var member = await userGroupRepository.GetMemberAsync(request.UserId, request.GroupId, cancellationToken);
+        if (member is null)
+        {
+            logger.LogWarning("User {UserId} is not a member of group {GroupId}.", request.UserId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "This user is not part of the selected group."));
+        }
+
+        if (member.GroupRole is null)
+        {
+            logger.LogWarning("GroupRole is null for member {UserId} in group {GroupId}.", request.UserId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("500", "We couldn't retrieve the user's role in the group. Please try again later."));
+        }
+
+        member.GroupRole.Role = request.Role.ToString();
+        member.UpdatedAt = DateTime.UtcNow;
+
+        await userGroupRepository.UpdateAsync(member, cancellationToken);
+        
+        await cache.IncrementVersionAsync("group-members", request.GroupId, logger, cancellationToken);
+
+        logger.LogInformation("Successfully updated role of user {UserId} in group {GroupId} to {Role}.", request.UserId, request.GroupId, request.Role);
+
+        return ResultT<ResponseDto>.Success(new ResponseDto("The user's role was successfully updated."));
+    }
+}
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupByGroupId/GetGroupByGroupIdQuery.cs b/Rex.Application/Modules/Groups/Queries/GetGroupByGroupId/GetGroupByGroupIdQuery.cs
new file mode 100644
index 0000000..e11eb17
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupByGroupId/GetGroupByGroupIdQuery.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Group;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupById;
+
+public record GetGroupByGroupIdQuery(
+    Guid GroupId,
+    Guid UserId
+    ): IQuery<GroupDetailsDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupByGroupId/GetGroupByGroupIdQueryHandler.cs b/Rex.Application/Modules/Groups/Queries/GetGroupByGroupId/GetGroupByGroupIdQueryHandler.cs
new file mode 100644
index 0000000..4954595
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupByGroupId/GetGroupByGroupIdQueryHandler.cs
@@ -0,0 +1,98 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Group;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupById;
+
+public class GetGroupByGroupIdQueryHandler(
+    ILogger<GetGroupByGroupIdQueryHandler> logger,
+    IGroupRepository groupRepository,
+    IUserGroupRepository userGroupRepository,
+    IUserRepository userRepository,
+    IDistributedCache distributedCache
+) : IQueryHandler<GetGroupByGroupIdQuery, GroupDetailsDto>
+{
+    public async Task<ResultT<GroupDetailsDto>> Handle(GetGroupByGroupIdQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received a null request for GetGroupByIdQuery.");
+            return ResultT<GroupDetailsDto>.Failure(
+                Error.Failure("400", "Oops! No request data was provided."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("Could not find a user with ID {UserId}.", request.UserId);
+            return ResultT<GroupDetailsDto>.Failure(
+                Error.NotFound("404", "We couldn't find the user making the request."));
+        }
+
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(request.UserId, cancellationToken);
+        if (!accountConfirmed)
+        {
+            logger.LogWarning("User with ID {UserId} tried to access group {GroupId} but the account is not confirmed.",
+                request.UserId, request.GroupId);
+            return ResultT<GroupDetailsDto>.Failure(
+                Error.Failure("403", "You need to confirm your account before accessing groups."));
+        }
+
+        var isUserBanned =
+            await userGroupRepository.IsUserBannedAsync(request.UserId, request.GroupId, cancellationToken);
+        if (isUserBanned)
+        {
+            logger.LogWarning("User {UserId} is banned from group {GroupId}.", request.UserId, request.GroupId);
+            return ResultT<GroupDetailsDto>.Failure(
+                Error.Failure("403", "You can't access this group because you're banned."));
+        }
+
+        var isGroupPrivate = await userGroupRepository.IsGroupPrivateAsync(request.GroupId, cancellationToken);
+        var isUserInGroup = await userGroupRepository.IsUserInGroupAsync(
+            request.UserId, request.GroupId, RequestStatus.Accepted, cancellationToken);
+
+        if (isGroupPrivate && !isUserInGroup)
+        {
+            logger.LogWarning("User {UserId} tried to view private group {GroupId} without membership.",
+                request.UserId, request.GroupId);
+            return ResultT<GroupDetailsDto>.Failure(
+                Error.Failure("403", "This group is private, and you're not a member."));
+        }
+
+        logger.LogInformation("Returning details for group {GroupId} to user {UserId}. Membership: {IsJoined}",
+            request.GroupId, request.UserId, isUserInGroup);
+
+        var version = await distributedCache.GetVersionAsync("group", request.GroupId, cancellationToken);
+        var cacheKey = $"group:{request.GroupId}:version:{version}";
+
+        var result = await distributedCache.GetOrCreateAsync(
+            cacheKey,
+            async () => await groupRepository.GetGroupByIdAsync(request.GroupId, cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (result is null)
+        {
+            logger.LogWarning("Could not find group with ID {GroupId}.", request.GroupId);
+            return ResultT<GroupDetailsDto>.Failure(
+                Error.NotFound("404", "We couldn't find the group you're looking for."));
+        }
+
+        return ResultT<GroupDetailsDto>.Success(new GroupDetailsDto(
+            GroupId: result.Id,
+            ProfilePicture: result.ProfilePhoto,
+            CoverPicture: result.CoverPhoto ?? string.Empty,
+            Title: result.Title,
+            Description: result.Description,
+            Visibility: result.Visibility,
+            MemberCount: result.UserGroups.Count,
+            IsJoined: isUserInGroup
+        ));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupJoinRequests/GetGroupJoinRequestsCommand.cs b/Rex.Application/Modules/Groups/Queries/GetGroupJoinRequests/GetGroupJoinRequestsCommand.cs
new file mode 100644
index 0000000..26a025d
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupJoinRequests/GetGroupJoinRequestsCommand.cs
@@ -0,0 +1,12 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.User;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupJoinRequests;
+
+public record GetGroupJoinRequestsCommand(
+    Guid GroupId,
+    int PageNumber,
+    int PageSize,
+    string? SearchTerm
+    ): IQuery<PagedResult<UserGroupRequestDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupJoinRequests/GetGroupJoinRequestsCommandHandler.cs b/Rex.Application/Modules/Groups/Queries/GetGroupJoinRequests/GetGroupJoinRequestsCommandHandler.cs
new file mode 100644
index 0000000..75fa72c
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupJoinRequests/GetGroupJoinRequestsCommandHandler.cs
@@ -0,0 +1,88 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.User;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupJoinRequests;
+
+public class GetGroupJoinRequestsCommandHandler(
+    ILogger<GetGroupJoinRequestsCommandHandler> logger,
+    IUserGroupRepository userGroupRepository,
+    IGroupRepository groupRepository,
+    IDistributedCache distributedCache
+) : IQueryHandler<GetGroupJoinRequestsCommand, PagedResult<UserGroupRequestDto>>
+{
+    public async Task<ResultT<PagedResult<UserGroupRequestDto>>> Handle(GetGroupJoinRequestsCommand request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received a null GetGroupJoinRequestsCommand.");
+            return ResultT<PagedResult<UserGroupRequestDto>>.Failure(
+                Error.Failure("400", "We couldn't process your request. Please try again.")
+            );
+        }
+
+        var group = await groupRepository.GetGroupByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("No group found with ID {GroupId}.", request.GroupId);
+            return ResultT<PagedResult<UserGroupRequestDto>>.Failure(
+                Error.NotFound("404", "The group you're looking for doesn't exist.")
+            );
+        }
+
+        var searchTerm = string.IsNullOrEmpty(request.SearchTerm) ? "all" : request.SearchTerm;
+        var version = await distributedCache.GetVersionAsync("group-requests", request.GroupId, cancellationToken);
+        var cacheKey = $"group-requests:group:{request.GroupId}:search:{searchTerm}:page:{request.PageNumber}:size:{request.PageSize}:version:{version}";
+
+        var result = await distributedCache.GetOrCreateAsync(
+            cacheKey,
+            async () => await userGroupRepository.GetGroupRequestsAsync(
+                request.GroupId, 
+                RequestStatus.Pending, 
+                request.SearchTerm,
+                request.PageNumber, 
+                request.PageSize, 
+                cancellationToken
+            ),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+
+        if (!result.Items.Any())
+        {
+            logger.LogInformation("No join requests found for group {GroupId}", request.GroupId);
+            return ResultT<PagedResult<UserGroupRequestDto>>.Success(
+                new PagedResult<UserGroupRequestDto>([], result.TotalItems, result.ActualPage, result.TotalPages)
+            );
+        }
+
+        var elements = result.Items
+            .Select(c => new UserGroupRequestDto(
+                c.User.FirstName,
+                c.User.LastName,
+                c.User.ProfilePhoto,
+                c.Status?.ToString() ?? "Unknown",
+                DateTime.UtcNow - c.RequestedAt
+            ))
+            .ToList();
+
+        var pagedResult = new PagedResult<UserGroupRequestDto>(
+            elements,
+            result.TotalItems,
+            result.ActualPage,
+            result.TotalPages
+        );
+
+        logger.LogInformation("Successfully retrieved {Count} join requests for group {GroupId}", 
+            elements.Count, request.GroupId);
+
+        return ResultT<PagedResult<UserGroupRequestDto>>.Success(pagedResult);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupMembers/GetGroupMembersQuery.cs b/Rex.Application/Modules/Groups/Queries/GetGroupMembers/GetGroupMembersQuery.cs
new file mode 100644
index 0000000..a21fb6e
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupMembers/GetGroupMembersQuery.cs
@@ -0,0 +1,14 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.User;
+using Rex.Application.Pagination;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupMembers;
+
+public record GetGroupMembersQuery(
+    Guid GroupId,
+    int PageNumber,
+    int PageSize,
+    string? SearchTerm,
+    GroupRole? RoleFilter
+    ): IQuery<PagedResult<UserGroupDetailsDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupMembers/GetGroupMembersQueryHandler.cs b/Rex.Application/Modules/Groups/Queries/GetGroupMembers/GetGroupMembersQueryHandler.cs
new file mode 100644
index 0000000..ec62ace
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupMembers/GetGroupMembersQueryHandler.cs
@@ -0,0 +1,79 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.User;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupMembers;
+
+public class GetGroupMembersQueryHandler(
+    ILogger<GetGroupMembersQueryHandler> logger,
+    IGroupRepository groupRepository,
+    IUserGroupRepository userGroupRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetGroupMembersQuery, PagedResult<UserGroupDetailsDto>>
+{
+    public async Task<ResultT<PagedResult<UserGroupDetailsDto>>> Handle(GetGroupMembersQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("GetGroupMembersQueryHandler: Request is null");
+            return ResultT<PagedResult<UserGroupDetailsDto>>.Failure(
+                Error.Failure("400", "Oops! No data was provided to fetch group members."));
+        }
+
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("GetGroupMembersQueryHandler: Group with Id {GroupId} not found", request.GroupId);
+            return ResultT<PagedResult<UserGroupDetailsDto>>.Failure(
+                Error.NotFound("404", "We couldn't find the group you're looking for."));
+        }
+
+        var searchTerm = request.SearchTerm ?? "";
+        var roleFilter = request.RoleFilter?.ToString() ?? "all";
+
+        var version = await cache.GetVersionAsync("group-members", request.GroupId, cancellationToken);
+        var cacheKey = $"group-members:group:{request.GroupId}:role:{roleFilter}:search:{searchTerm}:page:{request.PageNumber}:size:{request.PageSize}:version:{version}";
+        
+        var result = await cache.GetOrCreateAsync(
+            cacheKey,
+            async () => await userGroupRepository.GetMembersAsync(request.GroupId, request.RoleFilter, request.SearchTerm, request.PageNumber, request.PageSize, cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+
+        if (!result.Items.Any())
+        {
+            logger.LogInformation("No members found for group {GroupId}", request.GroupId);
+            return ResultT<PagedResult<UserGroupDetailsDto>>.Success(
+                new PagedResult<UserGroupDetailsDto>([], result.TotalItems, result.ActualPage, result.TotalPages)
+            );
+        }
+
+        var elements = result.Items
+            .Select(ug => new UserGroupDetailsDto(
+                ug.UserId,
+                ug.User.FirstName,
+                ug.User.LastName,
+                ug.GroupRole.Role,
+                ug.User.ProfilePhoto
+            ))
+            .ToList();
+
+        var pagedResult = new PagedResult<UserGroupDetailsDto>(
+            elements,
+            result.TotalItems,
+            result.ActualPage,
+            result.TotalPages
+        );
+
+        logger.LogInformation("Successfully retrieved {Count} members for group {GroupId}", elements.Count,
+            request.GroupId);
+        return ResultT<PagedResult<UserGroupDetailsDto>>.Success(pagedResult);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupsByUserId/GetGroupsByUserIdQuery.cs b/Rex.Application/Modules/Groups/Queries/GetGroupsByUserId/GetGroupsByUserIdQuery.cs
new file mode 100644
index 0000000..911af3e
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupsByUserId/GetGroupsByUserIdQuery.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Group;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupsByUserId;
+
+public record GetGroupsByUserIdQuery(
+    Guid UserId,
+    int pageNumber,
+    int pageSize
+    ): IQuery<PagedResult<GroupDetailsDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupsByUserId/GetGroupsByUserIdQueryHandler.cs b/Rex.Application/Modules/Groups/Queries/GetGroupsByUserId/GetGroupsByUserIdQueryHandler.cs
new file mode 100644
index 0000000..b3f1637
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupsByUserId/GetGroupsByUserIdQueryHandler.cs
@@ -0,0 +1,84 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Group;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupsByUserId;
+
+public class GetGroupsByUserIdQueryHandler(
+    ILogger<GetGroupsByUserIdQueryHandler> logger,
+    IGroupRepository groupRepository,
+    IDistributedCache distributedCache,
+    IUserRepository userRepository
+) : IQueryHandler<GetGroupsByUserIdQuery, PagedResult<GroupDetailsDto>>
+{
+    public async Task<ResultT<PagedResult<GroupDetailsDto>>> Handle(GetGroupsByUserIdQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("GetGroupsByUserIdQuery: Request is null.");
+            return ResultT<PagedResult<GroupDetailsDto>>.Failure(
+                Error.Failure("400", "Oops! We didn't receive any data to fetch groups."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("GetGroupsByUserIdQuery: User with ID {UserId} not found.", request.UserId);
+            return ResultT<PagedResult<GroupDetailsDto>>.Failure(
+                Error.Failure("404", "We couldn't find your user account."));
+        }
+
+        var version = await distributedCache.GetVersionAsync("groups-user", request.UserId, cancellationToken);
+        var cacheKey = $"groups:user:{request.UserId}:page:{request.pageNumber}:size:{request.pageSize}:version:{version}";
+        
+        var result = await distributedCache.GetOrCreateAsync(
+            cacheKey,
+            async () => await groupRepository.GetGroupsByUserIdAsync(
+                request.UserId,
+                request.pageNumber,
+                request.pageSize,
+                cancellationToken
+            ),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (!result.Items.Any())
+        {
+            logger.LogInformation("No groups found for user {UserId}", request.UserId);
+            return ResultT<PagedResult<GroupDetailsDto>>.Success(
+                new PagedResult<GroupDetailsDto>([], result.TotalItems, result.ActualPage, result.TotalPages)
+            );
+        }
+
+        var elements = result.Items
+            .Select(c => new GroupDetailsDto(
+                GroupId: c.Id,
+                ProfilePicture: c.ProfilePhoto,
+                CoverPicture: c.CoverPhoto ?? string.Empty,
+                Title: c.Title,
+                Description: c.Description,
+                Visibility: c.Visibility,
+                MemberCount: c.UserGroups.Count,
+                IsJoined: c.UserGroups.Any(ug => ug.UserId == request.UserId)
+            ))
+            .ToList();
+
+        var pagedResult = new PagedResult<GroupDetailsDto>(
+            elements,
+            result.TotalItems,
+            result.ActualPage,
+            result.TotalPages
+        );
+
+        logger.LogInformation("Successfully retrieved {Count} groups for user {UserId}", 
+            elements.Count, request.UserId);
+
+        return ResultT<PagedResult<GroupDetailsDto>>.Success(pagedResult);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupsPaginated/GetGroupsPaginatedQuery.cs b/Rex.Application/Modules/Groups/Queries/GetGroupsPaginated/GetGroupsPaginatedQuery.cs
new file mode 100644
index 0000000..498b266
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupsPaginated/GetGroupsPaginatedQuery.cs
@@ -0,0 +1,12 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs;
+using Rex.Application.DTOs.Group;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupsPaginated;
+
+public record GetGroupsPaginatedQuery(
+    Guid UserId,
+    int PageNumber,
+    int PageSize
+    ): IQuery<PagedResult<GroupDetailsDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Groups/Queries/GetGroupsPaginated/GetGroupsPaginatedQueryHandler.cs b/Rex.Application/Modules/Groups/Queries/GetGroupsPaginated/GetGroupsPaginatedQueryHandler.cs
new file mode 100644
index 0000000..10f5629
--- /dev/null
+++ b/Rex.Application/Modules/Groups/Queries/GetGroupsPaginated/GetGroupsPaginatedQueryHandler.cs
@@ -0,0 +1,78 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Group;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Groups.Queries.GetGroupsPaginated;
+
+public class GetGroupsPaginatedQueryHandler(
+    ILogger<GetGroupsPaginatedQueryHandler> logger,
+    IGroupRepository groupRepository,
+    IDistributedCache distributedCache,
+    IUserRepository userRepository
+) : IQueryHandler<GetGroupsPaginatedQuery, PagedResult<GroupDetailsDto>>
+{
+    public async Task<ResultT<PagedResult<GroupDetailsDto>>> Handle(GetGroupsPaginatedQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("GetGroupsPaginatedQuery: Request is null.");
+            return ResultT<PagedResult<GroupDetailsDto>>.Failure(
+                Error.Failure("400", "Oops! No data provided to fetch groups."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("GetGroupsPaginatedQuery: User with ID {UserId} not found.", request.UserId);
+            return ResultT<PagedResult<GroupDetailsDto>>.Failure(
+                Error.Failure("404", "We couldn't find your account."));
+        }
+
+        var version = await distributedCache.GetVersionAsync("groups", request.UserId, cancellationToken);
+        var cacheKey = $"groups:available:user:{request.UserId}:page:{request.PageNumber}:size:{request.PageSize}:version:{version}";
+        var groups = await distributedCache.GetOrCreateAsync(
+            cacheKey,
+            async () => await groupRepository.GetGroupsPaginatedAsync(request.UserId, request.PageNumber, request.PageSize, cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (!groups.Items.Any())
+        {
+            logger.LogInformation("No available groups to join for user {UserId}", request.UserId);
+            return ResultT<PagedResult<GroupDetailsDto>>.Success(
+                new PagedResult<GroupDetailsDto>([], groups.TotalItems, groups.ActualPage, groups.TotalPages)
+            );
+        }
+
+        var elements = groups.Items
+            .Select(g => new GroupDetailsDto(
+                g.Id,
+                g.ProfilePhoto,
+                g.CoverPhoto ?? string.Empty,
+                g.Title,
+                g.Description,
+                g.Visibility,
+                g.UserGroups.Count,
+                false  
+            ))
+            .ToList();
+
+        var result = new PagedResult<GroupDetailsDto>(
+            items: elements,
+            totalItems: groups.TotalItems,
+            actualPage: groups.ActualPage,
+            pageSize: groups.TotalPages
+        );
+
+        logger.LogInformation("Successfully retrieved {Count} available groups for user {UserId}", 
+            elements.Count, request.UserId);
+
+        return ResultT<PagedResult<GroupDetailsDto>>.Success(result);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Messages/Commands/SendFileMessage/SendFileMessageCommand.cs b/Rex.Application/Modules/Messages/Commands/SendFileMessage/SendFileMessageCommand.cs
new file mode 100644
index 0000000..6e658b6
--- /dev/null
+++ b/Rex.Application/Modules/Messages/Commands/SendFileMessage/SendFileMessageCommand.cs
@@ -0,0 +1,12 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Message;
+
+namespace Rex.Application.Modules.Messages.Commands.SendFileMessage;
+
+public record SendFileMessageCommand(
+    Guid ChatId,
+    Guid UserId,
+    string? Message,
+    List<IFormFile> Files
+) : ICommand<MessageDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Messages/Commands/SendFileMessage/SendFileMessageCommandHandler.cs b/Rex.Application/Modules/Messages/Commands/SendFileMessage/SendFileMessageCommandHandler.cs
new file mode 100644
index 0000000..49fad15
--- /dev/null
+++ b/Rex.Application/Modules/Messages/Commands/SendFileMessage/SendFileMessageCommandHandler.cs
@@ -0,0 +1,22 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Message;
+using Rex.Application.Interfaces;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Messages.Commands.SendFileMessage;
+
+public class SendFileMessageCommandHandler(
+    ILogger<SendFileMessageCommandHandler> logger,
+    IMessageService messageService
+    ): ICommandHandler<SendFileMessageCommand, MessageDto>
+{
+    public async Task<ResultT<MessageDto>> Handle(SendFileMessageCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+            return ResultT<MessageDto>.Failure(Error.Failure("400", "Invalid request. Please try again."));
+        
+        return await messageService.SendMessageAsync(request.ChatId, request.UserId, request.Message, request.Files, cancellationToken);
+        
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Messages/Commands/SendMessage/SendMessageCommand.cs b/Rex.Application/Modules/Messages/Commands/SendMessage/SendMessageCommand.cs
new file mode 100644
index 0000000..7689d39
--- /dev/null
+++ b/Rex.Application/Modules/Messages/Commands/SendMessage/SendMessageCommand.cs
@@ -0,0 +1,10 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Message;
+
+namespace Rex.Application.Modules.Messages.Commands.SendMessage;
+
+public record SendMessageCommand(
+    Guid ChatId,
+    string Message,
+    Guid UserId
+) : ICommand<MessageDto>;
diff --git a/Rex.Application/Modules/Messages/Commands/SendMessage/SendMessageCommandHandler.cs b/Rex.Application/Modules/Messages/Commands/SendMessage/SendMessageCommandHandler.cs
new file mode 100644
index 0000000..6921559
--- /dev/null
+++ b/Rex.Application/Modules/Messages/Commands/SendMessage/SendMessageCommandHandler.cs
@@ -0,0 +1,19 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Message;
+using Rex.Application.Interfaces;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Messages.Commands.SendMessage;
+
+public class SendMessageCommandHandler(
+    IMessageService messageService
+) : ICommandHandler<SendMessageCommand, MessageDto>
+{
+    public async Task<ResultT<MessageDto>> Handle(SendMessageCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+            return ResultT<MessageDto>.Failure(Error.Failure("400", "Invalid request. Please try again."));
+
+        return await messageService.SendMessageAsync(request.ChatId, request.UserId, request.Message, cancellationToken: cancellationToken);
+    }
+}
diff --git a/Rex.Application/Modules/Messages/Queries/GetMessagesByChatId/GetMessagesByChatIdQuery.cs b/Rex.Application/Modules/Messages/Queries/GetMessagesByChatId/GetMessagesByChatIdQuery.cs
new file mode 100644
index 0000000..d6b282d
--- /dev/null
+++ b/Rex.Application/Modules/Messages/Queries/GetMessagesByChatId/GetMessagesByChatIdQuery.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Message;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Messages.Queries.GetMessagesByChatId;
+
+public record GetMessagesByChatIdQuery(
+    Guid ChatId,
+    int PageNumber,
+    int PageSize
+    ): IQuery<PagedResult<MessageDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Messages/Queries/GetMessagesByChatId/GetMessagesByChatIdQueryHandler.cs b/Rex.Application/Modules/Messages/Queries/GetMessagesByChatId/GetMessagesByChatIdQueryHandler.cs
new file mode 100644
index 0000000..9ffe81f
--- /dev/null
+++ b/Rex.Application/Modules/Messages/Queries/GetMessagesByChatId/GetMessagesByChatIdQueryHandler.cs
@@ -0,0 +1,81 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.File;
+using Rex.Application.DTOs.Message;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Messages.Queries.GetMessagesByChatId;
+
+public class GetMessagesByChatIdQueryHandler(
+    ILogger<GetMessagesByChatIdQueryHandler> logger,
+    IMessageRepository messageRepository,
+    IDistributedCache cache,
+    IFileRepository fileRepository
+) : IQueryHandler<GetMessagesByChatIdQuery, PagedResult<MessageDto>>
+{
+    public async Task<ResultT<PagedResult<MessageDto>>> Handle(GetMessagesByChatIdQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received null request for GetMessagesByUserIdQuery.");
+            return ResultT<PagedResult<MessageDto>>.Failure(Error.Failure("400", "Request cannot be null."));
+        }
+
+        var result = await messageRepository.GetMessagesByChatIdAsync(request.ChatId, request.PageNumber,
+            request.PageSize, cancellationToken
+        );
+
+        if (!result.Items.Any())
+        {
+            logger.LogInformation("No messages found for chat ID {ChatId}", request.ChatId);
+            return ResultT<PagedResult<MessageDto>>.Success(
+                new PagedResult<MessageDto>([], result.TotalItems, result.ActualPage, result.TotalPages)
+            );
+        }
+
+        var version = await cache.GetVersionAsync("chat-messages", request.ChatId, cancellationToken);
+        var cacheKey = $"files:chat:{request.ChatId}:v{version}:page:{request.PageNumber}:size:{request.PageSize}:version:{version}";
+        
+        var files = await cache.GetOrCreateAsync(
+            cacheKey,
+            async () => await fileRepository.GetFilesByTargetIdsAsync(result.Items.Select(m => m.Id).ToList(),
+                TargetType.Message, cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        var filesByMessageId = files
+            .SelectMany(f => f.EntityFiles, (file, entityFile) => new
+            {
+                entityFile.TargetId,
+                File = new FileDetailDto(file.Id, file.Url, file.Type)
+            })
+            .GroupBy(x => x.TargetId)
+            .ToDictionary(g => g.Key, g => g.Select(x => x.File).ToList());
+
+        var elements = result.Items.Select(m => new MessageDto(
+            m.Id,
+            m.ChatId,
+            m.SenderId,
+            m.Sender.FirstName,
+            m.Sender.ProfilePhoto,
+            m.Description,
+            m.CreatedAt,
+            filesByMessageId.GetValueOrDefault(m.Id) ?? []
+        )).ToList();
+
+        var pagedResult = new PagedResult<MessageDto>(
+            elements,
+            result.TotalItems,
+            result.ActualPage,
+            result.TotalPages
+        );
+
+        return ResultT<PagedResult<MessageDto>>.Success(pagedResult);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Notifications/Commands/MarkNotificationAsRead/MarkNotificationAsReadCommand.cs b/Rex.Application/Modules/Notifications/Commands/MarkNotificationAsRead/MarkNotificationAsReadCommand.cs
new file mode 100644
index 0000000..d5b1acb
--- /dev/null
+++ b/Rex.Application/Modules/Notifications/Commands/MarkNotificationAsRead/MarkNotificationAsReadCommand.cs
@@ -0,0 +1,6 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Notifications.Commands.MarkNotificationAsRead;
+
+public record MarkNotificationAsReadCommand(Guid NotificationId): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Notifications/Commands/MarkNotificationAsRead/MarkNotificationAsReadCommandHandler.cs b/Rex.Application/Modules/Notifications/Commands/MarkNotificationAsRead/MarkNotificationAsReadCommandHandler.cs
new file mode 100644
index 0000000..f7f4c7e
--- /dev/null
+++ b/Rex.Application/Modules/Notifications/Commands/MarkNotificationAsRead/MarkNotificationAsReadCommandHandler.cs
@@ -0,0 +1,45 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Notifications.Commands.MarkNotificationAsRead;
+
+public class MarkNotificationAsReadCommandHandler(
+    ILogger<MarkNotificationAsReadCommandHandler> logger,
+    INotificationRepository notificationRepository,
+    IDistributedCache cache
+) : ICommandHandler<MarkNotificationAsReadCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(MarkNotificationAsReadCommand request,
+        CancellationToken cancellationToken)
+    {
+        logger.LogInformation("Starting process to mark notification {NotificationId} as read.",
+            request.NotificationId);
+
+        var notification = await notificationRepository.GetByIdAsync(request.NotificationId, cancellationToken);
+        if (notification is null)
+        {
+            logger.LogWarning("Notification {NotificationId} not found in the system.", request.NotificationId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404",
+                "The notification you are trying to mark as read does not exist."));
+        }
+
+        if (notification.Read)
+        {
+            logger.LogInformation("Notification {NotificationId} is already marked as read.", request.NotificationId);
+            return ResultT<ResponseDto>.Success(new ResponseDto("This notification was already marked as read."));
+        }
+
+        notification.Read = true;
+        notification.UpdatedAt = DateTime.UtcNow;
+
+        logger.LogInformation("Notification {NotificationId} successfully marked as read.", request.NotificationId);
+        await notificationRepository.UpdateAsync(notification, cancellationToken);
+
+        return ResultT<ResponseDto>.Success(new ResponseDto("The notification has been marked as read successfully."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Notifications/Queries/GetNotificationsByUserId/GetNotificationsByUserIdCommand.cs b/Rex.Application/Modules/Notifications/Queries/GetNotificationsByUserId/GetNotificationsByUserIdCommand.cs
new file mode 100644
index 0000000..59de2a5
--- /dev/null
+++ b/Rex.Application/Modules/Notifications/Queries/GetNotificationsByUserId/GetNotificationsByUserIdCommand.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Notification;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Notifications.Queries.GetNotificationsByUserId;
+
+public record GetNotificationsByUserIdCommand(
+    Guid UserId,
+    int PageNumber,
+    int PageSize
+    ): IQuery<PagedResult<NotificationDto>>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Notifications/Queries/GetNotificationsByUserId/GetNotificationsByUserIdCommandHandler.cs b/Rex.Application/Modules/Notifications/Queries/GetNotificationsByUserId/GetNotificationsByUserIdCommandHandler.cs
new file mode 100644
index 0000000..e67ba77
--- /dev/null
+++ b/Rex.Application/Modules/Notifications/Queries/GetNotificationsByUserId/GetNotificationsByUserIdCommandHandler.cs
@@ -0,0 +1,71 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Notification;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Notifications.Queries.GetNotificationsByUserId;
+
+public class GetNotificationsByUserIdCommandHandler(
+    ILogger<GetNotificationsByUserIdCommandHandler> logger,
+    INotificationRepository notificationRepository,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetNotificationsByUserIdCommand, PagedResult<NotificationDto>>
+{
+    public async Task<ResultT<PagedResult<NotificationDto>>> Handle(GetNotificationsByUserIdCommand request,
+        CancellationToken cancellationToken)
+    {
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User {UserId} not found in the system.", request.UserId);
+            return ResultT<PagedResult<NotificationDto>>.Failure(Error.NotFound("404",
+                "The user for whom notifications are being requested does not exist."));
+        }
+
+        logger.LogInformation("Fetching notifications for user {UserId}.", request.UserId);
+        
+        var notifications = await cache.GetOrCreateAsync(
+            $"notifications:user:{request.UserId}:page:{request.PageNumber}:size:{request.PageSize}",
+            async () =>
+                await notificationRepository.GetNotificationsByUserIdAsync(
+                    request.UserId,
+                    request.PageNumber,
+                    request.PageSize,
+                    cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (notifications is null)
+        {
+            logger.LogWarning("No notifications found for user {UserId}.", request.UserId);
+            return ResultT<PagedResult<NotificationDto>>.Success(new PagedResult<NotificationDto>([],
+                notifications.TotalItems, notifications.ActualPage, notifications.TotalPages));
+        }
+
+        var notificationDtos = notifications.Items.Select(n => new NotificationDto(
+            n.Id,
+            n.Title,
+            n.Description,
+            n.UserId,
+            n.RecipientType,
+            n.RecipientId,
+            n.MetadataJson,
+            n.CreatedAt,
+            n.Read
+        )).ToList();
+        
+        logger.LogInformation("Fetched {Count} notifications for user {UserId}.", notificationDtos.Count,
+            request.UserId);
+        
+        return ResultT<PagedResult<NotificationDto>>.Success(new PagedResult<NotificationDto>(
+            notificationDtos,
+            notifications.TotalItems,
+            notifications.ActualPage,
+            notifications.TotalPages));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Posts/Commands/CreatePost/CreatePostCommand.cs b/Rex.Application/Modules/Posts/Commands/CreatePost/CreatePostCommand.cs
new file mode 100644
index 0000000..1a18f02
--- /dev/null
+++ b/Rex.Application/Modules/Posts/Commands/CreatePost/CreatePostCommand.cs
@@ -0,0 +1,14 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Posts.Commands;
+
+public record CreatePostCommand(
+    Guid GroupId,
+    Guid UserId,
+    Guid? ChallengeId,
+    string Title,
+    string Description,
+    List<IFormFile>? Files = null
+) : ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Posts/Commands/CreatePost/CreatePostCommandHandler.cs b/Rex.Application/Modules/Posts/Commands/CreatePost/CreatePostCommandHandler.cs
new file mode 100644
index 0000000..f3ab17a
--- /dev/null
+++ b/Rex.Application/Modules/Posts/Commands/CreatePost/CreatePostCommandHandler.cs
@@ -0,0 +1,141 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Helpers;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Modules.Posts.Commands;
+
+public class CreatePostCommandHandler(
+    ILogger<CreatePostCommandHandler> logger,
+    IGroupRepository groupRepository,
+    IUserRepository userRepository,
+    IPostRepository postRepository,
+    IUserGroupRepository userGroupRepository,
+    IUserChallengeRepository userChallengeRepository,
+    IChallengeRepository challengeRepository,
+    IFileRepository fileRepository,
+    IEntityFileRepository entityFileRepository,
+    ICloudinaryService cloudinaryService,
+    IDistributedCache cache
+) : ICommandHandler<CreatePostCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(CreatePostCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request for creating a post.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "Oops! We couldn't process your request. Please provide the post details."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("No user found with UserId {UserId}.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404",
+                "We couldn't find your account. Please log in again."));
+        }
+        
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(request.UserId, cancellationToken);
+        if (!accountConfirmed)
+        {
+            logger.LogWarning("User with ID {UserId} tried to create a group but the account is not confirmed.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "You need to confirm your account before creating a group."));
+        }
+
+        var group = await groupRepository.GetGroupByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("No group found with GroupId {GroupId}.", request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404",
+                "We couldn't find the group you're trying to post in."));
+        }
+
+        var isUserInGroup = await userGroupRepository.IsUserInGroupAsync(
+            request.UserId, request.GroupId, RequestStatus.Accepted, cancellationToken);
+
+        if (!isUserInGroup)
+        {
+            logger.LogWarning("User {UserId} is not a member of group {GroupId}.", request.UserId, request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403",
+                "You need to be a member of this group to create posts."));
+        }
+
+        if (request.ChallengeId.HasValue)
+        {
+            var userChallenge = await userChallengeRepository.GetByUserAndChallengeAsync(
+                request.UserId, request.ChallengeId.Value, cancellationToken);
+
+            if (userChallenge is null)
+            {
+                logger.LogWarning("User {UserId} is not enrolled in challenge {ChallengeId}.",
+                    request.UserId, request.ChallengeId);
+                return ResultT<ResponseDto>.Failure(Error.NotFound("404",
+                    "You're not enrolled in this challenge. Please join it first."));
+            }
+
+            var belongsToGroup = await challengeRepository.ChallengeBelongsToGroup(
+                request.GroupId, userChallenge.ChallengeId, cancellationToken);
+
+            if (!belongsToGroup)
+            {
+                logger.LogWarning("Challenge {ChallengeId} doesn't belong to group {GroupId}.",
+                    userChallenge.ChallengeId, request.GroupId);
+                return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                    "This challenge doesn't belong to the group you're posting in."));
+            }
+
+            if (userChallenge.Status == UserChallengeStatus.Completed.ToString())
+            {
+                logger.LogWarning("User {UserId} attempted to complete already completed challenge {ChallengeId}.",
+                    request.UserId, request.ChallengeId);
+                return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                    "You've already completed this challenge!"));
+            }
+
+            userChallenge.Status = UserChallengeStatus.Completed.ToString();
+            await userChallengeRepository.UpdateAsync(userChallenge, cancellationToken);
+
+            logger.LogInformation("User {UserId} completed challenge {ChallengeId}.",
+                request.UserId, userChallenge.ChallengeId);
+        }
+
+        Post post = new()
+        {
+            Id = Guid.NewGuid(),
+            Title = request.Title,
+            Description = request.Description,
+            CreatedAt = DateTime.UtcNow,
+            GroupId = request.GroupId,
+            UserId = request.UserId,
+            ChallengeId = request.ChallengeId
+        };
+
+        await postRepository.CreateAsync(post, cancellationToken);
+        logger.LogInformation("Post '{PostTitle}' created successfully in group {GroupId} by user {UserId}.",
+            request.Title, request.GroupId, request.UserId);
+
+        if (request.Files is not null && request.Files.Any())
+        {
+            var filesResult = await ProcessFiles.ProcessFilesAsync(
+                logger, request.Files, post.Id, fileRepository,
+                entityFileRepository, cloudinaryService, TargetType.Post, cancellationToken);
+
+            if (!filesResult.IsSuccess)
+                return filesResult;
+        }
+        
+        await cache.IncrementVersionAsync("group-posts", request.GroupId, logger, cancellationToken);
+        logger.LogInformation("Cache invalidated for posts of GroupId: {GroupId}", request.GroupId);
+        
+        await userGroupRepository.ResetWarningStatus(post.UserId, post.GroupId, cancellationToken);
+
+        return ResultT<ResponseDto>.Success(new ResponseDto("Your post has been created successfully!"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Posts/Commands/DeletePost/DeletePostCommand.cs b/Rex.Application/Modules/Posts/Commands/DeletePost/DeletePostCommand.cs
new file mode 100644
index 0000000..64988ee
--- /dev/null
+++ b/Rex.Application/Modules/Posts/Commands/DeletePost/DeletePostCommand.cs
@@ -0,0 +1,10 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Posts.Commands.DeletePost;
+
+public record DeletePostCommand(
+    Guid PostId,
+    Guid GroupId,
+    Guid UserId
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Posts/Commands/DeletePost/DeletePostCommandHandler.cs b/Rex.Application/Modules/Posts/Commands/DeletePost/DeletePostCommandHandler.cs
new file mode 100644
index 0000000..60bab08
--- /dev/null
+++ b/Rex.Application/Modules/Posts/Commands/DeletePost/DeletePostCommandHandler.cs
@@ -0,0 +1,82 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Posts.Commands.DeletePost;
+
+public class DeletePostCommandHandler(
+    ILogger<DeletePostCommandHandler> logger,
+    IUserGroupRepository userGroupRepository,
+    IUserRepository userRepository,
+    IPostRepository postRepository,
+    IGroupRepository groupRepository,
+    IDistributedCache cache
+) : ICommandHandler<DeletePostCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(DeletePostCommand request, CancellationToken cancellationToken)
+    {
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found. UserId: {UserId}", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "User not found."));
+        }
+
+        var post = await postRepository.GetByIdAsync(request.PostId, cancellationToken);
+        if (post is null)
+        {
+            logger.LogWarning("Post not found. PostId: {PostId}", request.PostId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Post not found."));
+        }
+
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Group not found. GroupId: {GroupId}", request.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Group not found."));
+        }
+
+        var userGroup = await userGroupRepository.GetMemberAsync(request.UserId, group.Id, cancellationToken);
+        if (userGroup is null)
+        {
+            logger.LogWarning("User is not a member of the group. UserId: {UserId}, GroupId: {GroupId}",
+                request.UserId, group.Id);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "You are not a member of this group."));
+        }
+
+        var role = userGroup.GroupRole.Role;
+
+        if (!CanDeletePost(role, request.UserId, post.UserId))
+        {
+            logger.LogWarning("User {UserId} with role {Role} attempted to delete post {PostId} without permission.",
+                request.UserId, role, post.Id);
+
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "You can only delete your own posts."));
+        }
+
+        await postRepository.DeleteAsync(post, cancellationToken);
+
+        logger.LogInformation("Cache invalidated for posts of GroupId: {GroupId}", group.Id);
+        await cache.IncrementVersionAsync("group-posts", group.Id, logger, cancellationToken);
+
+        logger.LogInformation("Post {PostId} deleted by User {UserId} with role {Role}", post.Id, request.UserId, role);
+
+        return ResultT<ResponseDto>.Success(new ResponseDto("Post deleted successfully."));
+    }
+
+    private bool CanDeletePost(string role, Guid userId, Guid authorId)
+    {
+        if (userId == authorId)
+            return true;
+
+        return role == GroupRole.Leader.ToString() ||
+               role == GroupRole.Mentor.ToString() ||
+               role == GroupRole.Moderator.ToString();
+    }
+}
+
+
diff --git a/Rex.Application/Modules/Posts/Queries/GetPostsByGroupId/GetPostsByGroupIdQuery.cs b/Rex.Application/Modules/Posts/Queries/GetPostsByGroupId/GetPostsByGroupIdQuery.cs
new file mode 100644
index 0000000..8911139
--- /dev/null
+++ b/Rex.Application/Modules/Posts/Queries/GetPostsByGroupId/GetPostsByGroupIdQuery.cs
@@ -0,0 +1,12 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Post;
+using Rex.Application.Pagination;
+
+namespace Rex.Application.Modules.Posts.Queries.GetPostsByGroupId;
+
+public record GetPostsByGroupIdQuery(
+    Guid GroupId,
+    Guid UserId,
+    int PageNumber,
+    int PageSize
+) : IQuery<PagedResult<PostDetailsDto>>;
diff --git a/Rex.Application/Modules/Posts/Queries/GetPostsByGroupId/GetPostsByGroupIdQueryHandler.cs b/Rex.Application/Modules/Posts/Queries/GetPostsByGroupId/GetPostsByGroupIdQueryHandler.cs
new file mode 100644
index 0000000..d1c5fc4
--- /dev/null
+++ b/Rex.Application/Modules/Posts/Queries/GetPostsByGroupId/GetPostsByGroupIdQueryHandler.cs
@@ -0,0 +1,117 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.File;
+using Rex.Application.DTOs.Post;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Posts.Queries.GetPostsByGroupId;
+
+public class GetPostsByGroupIdQueryHandler(
+    ILogger<GetPostsByGroupIdQueryHandler> logger,
+    IPostRepository postRepository,
+    IGroupRepository groupRepository,
+    IFileRepository fileRepository,
+    ICommentRepository commentRepository,
+    IUserRepository userRepository,
+    IReactionRepository reactionRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetPostsByGroupIdQuery, PagedResult<PostDetailsDto>>
+{
+    public async Task<ResultT<PagedResult<PostDetailsDto>>> Handle(GetPostsByGroupIdQuery request,
+        CancellationToken cancellationToken)
+    {
+        var group = await groupRepository.GetByIdAsync(request.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("No group found with GroupId: {GroupId}.", request.GroupId);
+            return ResultT<PagedResult<PostDetailsDto>>.Failure(Error.NotFound("404",
+                "We couldn't find the group you're looking for."));
+        }
+        
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("No user found with UserId: {UserId}.", request.UserId);
+            return ResultT<PagedResult<PostDetailsDto>>.Failure(Error.NotFound("404",
+                "We couldn't find the user."));
+        }
+        
+        var version = await cache.GetVersionAsync("group-posts", request.GroupId, cancellationToken);
+        var cacheKey = $"posts:group:{request.GroupId}:user:{request.UserId}:page:{request.PageNumber}:size:{request.PageSize}:version:{version}";
+
+        var posts = await cache.GetOrCreateAsync(
+            cacheKey,
+            async () => await postRepository.GetPostsByGroupIdAsync(
+                request.GroupId, request.PageNumber, request.PageSize, cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (!posts.Items.Any())
+        {
+            logger.LogInformation("No posts found for group {GroupId}.", request.GroupId);
+            return ResultT<PagedResult<PostDetailsDto>>.Success(
+                new PagedResult<PostDetailsDto>([], posts.TotalItems, posts.ActualPage, posts.TotalPages)
+            );
+        }
+
+        var postIds = posts.Items.Select(p => p.Id).ToList();
+
+        var commentCounts = await commentRepository.GetCommentsCountByPostIdsAsync(postIds, cancellationToken);
+        var likeCounts = await reactionRepository.GetLikesCountByPostIdsAsync(postIds, TargetType.Post, cancellationToken);
+        var files = await fileRepository.GetFilesByTargetIdsAsync(postIds, TargetType.Post, cancellationToken);
+        var userLikes = await reactionRepository.GetUserLikesForTargetsAsync(
+            request.UserId, postIds, ReactionTargetType.Post, cancellationToken);
+
+        var filesByPostId = files
+            .SelectMany(f => f.EntityFiles, (file, entityFile) =>
+                new
+                {
+                    entityFile.TargetId,
+                    File = new FileDetailDto(file.Id,file.Url, file.Type)
+                })
+            .GroupBy(c => c.TargetId)
+            .ToDictionary(g => g.Key, g => g.Select(x => x.File).ToList());
+
+        var elements = posts.Items.Select(p =>
+        {
+            commentCounts.TryGetValue(p.Id, out var commentCount);
+            likeCounts.TryGetValue(p.Id, out var likeCount);
+            var hasUserLiked = userLikes.Contains(p.Id);
+            var fileUrls = filesByPostId.GetValueOrDefault(p.Id) ?? [];
+
+            var hasCompletedChallenge = p.ChallengeId.HasValue &&
+                                        p.User.UserChallenges.Any(uc =>
+                                            uc.ChallengeId == p.ChallengeId &&
+                                            uc.Status == UserChallengeStatus.Completed.ToString()
+                                        );
+
+            return new PostDetailsDto(
+                p.Id,
+                p.UserId,
+                p.GroupId,
+                $"{p.User.FirstName} {p.User.LastName}",
+                p.Title,
+                p.Description,
+                p.User.ProfilePhoto,
+                likeCount,
+                commentCount,
+                hasUserLiked,
+                p.CreatedAt,
+                hasCompletedChallenge,
+                fileUrls
+            );
+        }).ToList();
+
+        var result = new PagedResult<PostDetailsDto>(elements, posts.TotalItems, posts.ActualPage, posts.TotalPages);
+
+        logger.LogInformation("Successfully retrieved {Count} posts for group {GroupId}.",
+            elements.Count, request.GroupId);
+
+        return ResultT<PagedResult<PostDetailsDto>>.Success(result);
+    }
+}
diff --git a/Rex.Application/Modules/Reactions/Commands/AddLike/AddLikeCommand.cs b/Rex.Application/Modules/Reactions/Commands/AddLike/AddLikeCommand.cs
new file mode 100644
index 0000000..7ad99bf
--- /dev/null
+++ b/Rex.Application/Modules/Reactions/Commands/AddLike/AddLikeCommand.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Reactions.Commands.AddLike;
+
+public record AddLikeCommand(
+    Guid UserId,
+    Guid PostId,
+    ReactionTargetType ReactionTargetType
+) : ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Reactions/Commands/AddLike/AddLikeCommandHandler.cs b/Rex.Application/Modules/Reactions/Commands/AddLike/AddLikeCommandHandler.cs
new file mode 100644
index 0000000..9f3b754
--- /dev/null
+++ b/Rex.Application/Modules/Reactions/Commands/AddLike/AddLikeCommandHandler.cs
@@ -0,0 +1,141 @@
+using System.Text.Json;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.DTOs.Reaction;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Modules.Reactions.Commands.AddLike;
+
+public class AddLikeCommandHandler(
+    ILogger<AddLikeCommandHandler> logger,
+    IReactionRepository reactionRepository,
+    IUserRepository userRepository,
+    IGroupRepository groupRepository,
+    IUserGroupRepository userGroupRepository,
+    IPostRepository postRepository,
+    IReactionNotifier reactionNotifier
+) : ICommandHandler<AddLikeCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(AddLikeCommand request, CancellationToken cancellationToken)
+    {
+        logger.LogInformation("Processing like for PostId: {PostId} by UserId: {UserId}", request.PostId, request.UserId);
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found: {UserId}", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "We couldn't find your account."));
+        }
+
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(request.UserId, cancellationToken);
+        if (!accountConfirmed)
+        {
+            logger.LogWarning("User {UserId} tried to react but account is not confirmed.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "Please confirm your account to give an impulse."));
+        }
+
+        var post = await postRepository.GetByIdAsync(request.PostId, cancellationToken);
+        if (post is null)
+        {
+            logger.LogWarning("Post not found: {PostId}", request.PostId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Oops! The post doesn't exist."));
+        }
+
+        var group = await groupRepository.GetByIdAsync(post.GroupId, cancellationToken);
+        if (group is null)
+        {
+            logger.LogWarning("Group not found for PostId {PostId}", request.PostId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "The group for this post doesn't exist."));
+        }
+
+        var isMember = await userGroupRepository.IsUserInGroupAsync(
+            request.UserId, post.GroupId, RequestStatus.Accepted, cancellationToken);
+        if (!isMember)
+        {
+            logger.LogWarning("User {UserId} tried to react but is not a member of group {GroupId}", request.UserId, post.GroupId);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403", "You need to join the group to give an impulse."));
+        }
+
+        var existingReaction = await reactionRepository.HasLikedAsync(request.PostId, request.UserId, cancellationToken);
+
+        if (existingReaction is not null && existingReaction.Like)
+        {
+            logger.LogInformation("User {UserId} already liked PostId {PostId}", request.UserId, request.PostId);
+            return ResultT<ResponseDto>.Success(new ResponseDto("You already gave an impulse to this post."));
+        }
+
+        if (existingReaction is not null)
+        {
+            existingReaction.Like = true;
+            existingReaction.UpdatedAt = DateTime.UtcNow;
+            await reactionRepository.UpdateAsync(existingReaction, cancellationToken);
+
+            logger.LogInformation("User {UserId} restored like on PostId {PostId}", request.UserId, request.PostId);
+
+            var totalLikes = await reactionRepository.CountLikesAsync(request.PostId, request.ReactionTargetType, cancellationToken);
+            await reactionNotifier.LikeChangedNotificationAsync(new LikeChangedDto(
+                PostId: request.PostId,
+                TotalLikes: totalLikes,
+                UserId: request.UserId,
+                Liked: true
+            ), cancellationToken);
+
+            return ResultT<ResponseDto>.Success(new ResponseDto("You just gave an impulse!"));
+        }
+
+        var reaction = new Reaction
+        {
+            Id = Guid.NewGuid(),
+            UserId = request.UserId,
+            TargetId = request.PostId,
+            TargetType = request.ReactionTargetType.ToString(),
+            Like = true,
+            CreatedAt = DateTime.UtcNow
+        };
+
+        await reactionRepository.CreateAsync(reaction, cancellationToken);
+        logger.LogInformation("User {UserId} liked PostId {PostId}", request.UserId, request.PostId);
+
+        if (post.UserId != request.UserId)
+        {
+            var metadata = new
+            {
+                GroupId = group.Id,
+                PostId = post.Id,
+                PostTitle = post.Title,
+                LikedBy = $"{user.FirstName} {user.LastName}"
+            };
+
+            var notification = new Notification
+            {
+                Title = "New Impulse!",
+                Description = $"{user.FirstName} {user.LastName} just gave an impulse to your post in '{group.Title}'",
+                UserId = user.Id,
+                RecipientType = TargetType.User.ToString(),
+                RecipientId = post.UserId,
+                MetadataJson = JsonSerializer.Serialize(metadata),
+                Read = false,
+                CreatedAt = DateTime.UtcNow
+            };
+
+            await reactionNotifier.ReactionPostNotificationAsync(notification, cancellationToken);
+            logger.LogInformation("Notification sent to UserId {RecipientId} for PostId {PostId}", post.UserId, request.PostId);
+        }
+
+        var totalLikesFinal = await reactionRepository.CountLikesAsync(request.PostId, request.ReactionTargetType, cancellationToken);
+        await reactionNotifier.LikeChangedNotificationAsync(new LikeChangedDto(
+            PostId: request.PostId,
+            TotalLikes: totalLikesFinal,
+            UserId: request.UserId,
+            Liked: true
+        ), cancellationToken);
+
+        logger.LogInformation("Like process completed for PostId {PostId} by UserId {UserId}", request.PostId, request.UserId);
+        return ResultT<ResponseDto>.Success(new ResponseDto("You just gave an impulse!"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Reactions/Commands/RemoveLike/RemoveLikeCommand.cs b/Rex.Application/Modules/Reactions/Commands/RemoveLike/RemoveLikeCommand.cs
new file mode 100644
index 0000000..dde9b7e
--- /dev/null
+++ b/Rex.Application/Modules/Reactions/Commands/RemoveLike/RemoveLikeCommand.cs
@@ -0,0 +1,11 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Reactions.Commands.RemoveLike;
+
+public record RemoveLikeCommand(
+    Guid UserId,
+    Guid PostId,
+    ReactionTargetType ReactionTargetType
+) : ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Reactions/Commands/RemoveLike/RemoveLikeCommandHandler.cs b/Rex.Application/Modules/Reactions/Commands/RemoveLike/RemoveLikeCommandHandler.cs
new file mode 100644
index 0000000..dba1cfa
--- /dev/null
+++ b/Rex.Application/Modules/Reactions/Commands/RemoveLike/RemoveLikeCommandHandler.cs
@@ -0,0 +1,48 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.DTOs.Reaction;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Reactions.Commands.RemoveLike;
+
+public class RemoveLikeCommandHandler(
+    ILogger<RemoveLikeCommandHandler> logger,
+    IReactionRepository reactionRepository,
+    IPostRepository postRepository,
+    IReactionNotifier reactionNotifier
+) : ICommandHandler<RemoveLikeCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(RemoveLikeCommand request, CancellationToken cancellationToken)
+    {
+        var post = await postRepository.GetByIdAsync(request.PostId, cancellationToken);
+        if (post is null)
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Post not found."));
+
+        var reaction = await reactionRepository.HasLikedAsync(request.PostId, request.UserId, cancellationToken);
+        
+        if (reaction is null || !reaction.Like)
+        {
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Like not found."));
+        }
+
+        reaction.Like = false;
+        reaction.UpdatedAt = DateTime.UtcNow;
+        await reactionRepository.UpdateAsync(reaction, cancellationToken);
+
+        logger.LogInformation("User {UserId} removed like from post {PostId}", request.UserId, request.PostId);
+
+        var totalLikes = await reactionRepository.CountLikesAsync(request.PostId, request.ReactionTargetType, cancellationToken);
+        var likeChangedDto = new LikeChangedDto(
+            PostId: request.PostId,
+            TotalLikes: totalLikes,
+            UserId: request.UserId,
+            Liked: false
+        );
+        await reactionNotifier.LikeChangedNotificationAsync(likeChangedDto, cancellationToken);
+
+        return ResultT<ResponseDto>.Success(new("Impulse removed successfully"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountCommand.cs b/Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountCommand.cs
new file mode 100644
index 0000000..2cfad42
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountCommand.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.User.Commands.ConfirmAccount;
+
+public record ConfirmAccountCommand(
+    Guid UserId,
+    string Code
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountCommandHandler.cs b/Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountCommandHandler.cs
new file mode 100644
index 0000000..52ab52b
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountCommandHandler.cs
@@ -0,0 +1,42 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.User.Commands.ConfirmAccount;
+
+public class ConfirmAccountCommandHandler(
+    ILogger<ConfirmAccountCommandHandler> logger,
+    IUserRepository userRepository,
+    ICodeService codeService
+) : ICommandHandler<ConfirmAccountCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(ConfirmAccountCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogInformation("Received empty confirm account request.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "Oops! No information was provided to confirm your account."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogInformation("User not found for account confirmation.");
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Hmm, we couldn't find your account."));
+        }
+
+        var confirmUser = await codeService.ConfirmCodeAsync(user.Id, request.Code, cancellationToken);
+        if (!confirmUser.IsSuccess)
+        {
+            logger.LogInformation("Failed to confirm account: {Error}", confirmUser.Error.Description);
+            return ResultT<ResponseDto>.Failure(confirmUser.Error);
+        }
+
+        logger.LogInformation("Account confirmed successfully.");
+        return ResultT<ResponseDto>.Success(new ResponseDto("Great! Your account has been confirmed successfully."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountValidation.cs b/Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountValidation.cs
new file mode 100644
index 0000000..e203d83
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ConfirmAccount/ConfirmAccountValidation.cs
@@ -0,0 +1,15 @@
+using FluentValidation;
+
+namespace Rex.Application.Modules.User.Commands.ConfirmAccount;
+
+public class ConfirmAccountValidation: AbstractValidator<ConfirmAccountCommand>
+{
+    public ConfirmAccountValidation()
+    {
+        RuleFor(c => c.UserId)
+            .NotEmpty().WithMessage("User ID is required");
+        
+        RuleFor(c => c.Code)
+            .NotEmpty().WithMessage("Code is required");
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ConfirmEmailChange/ConfirmEmailChangeCommand.cs b/Rex.Application/Modules/Users/Commands/ConfirmEmailChange/ConfirmEmailChangeCommand.cs
new file mode 100644
index 0000000..72d805c
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ConfirmEmailChange/ConfirmEmailChangeCommand.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.User.Commands.ConfirmEmailChange;
+
+public record ConfirmEmailChangeCommand(
+    Guid UserId,
+    string Code
+    ):ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ConfirmEmailChange/ConfirmEmailChangeCommandHandler.cs b/Rex.Application/Modules/Users/Commands/ConfirmEmailChange/ConfirmEmailChangeCommandHandler.cs
new file mode 100644
index 0000000..d8d8ee3
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ConfirmEmailChange/ConfirmEmailChangeCommandHandler.cs
@@ -0,0 +1,46 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.User.Commands.ConfirmEmailChange;
+
+public class ConfirmEmailChangeCommandHandler(
+    ILogger<ConfirmEmailChangeCommandHandler> logger,
+    IUserRepository userRepository,
+    ICodeService codeService
+) : ICommandHandler<ConfirmEmailChangeCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(ConfirmEmailChangeCommand request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty email confirmation request.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "Oops! No data was provided to confirm your email."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User with ID {UserId} not found for email confirmation.", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404",
+                "Hmm, we couldn't find an account with that email."));
+        }
+
+        var codeResult = await codeService.ConfirmCodeAsync(request.UserId, request.Code, cancellationToken);
+        if (!codeResult.IsSuccess)
+        {
+            logger.LogWarning("Failed to confirm email for user {UserId}: {Error}", request.UserId,
+                codeResult.Error.Description);
+            return ResultT<ResponseDto>.Failure(codeResult.Error ?? Error.Failure("400",
+                "Something went wrong while confirming your email. Please try again."));
+        }
+
+        logger.LogInformation("User {UserId} successfully confirmed email.", request.UserId);
+        return ResultT<ResponseDto>.Success(new ResponseDto("Great! Your email has been confirmed successfully."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ConfirmPasswordChangeByEmail/ConfirmPasswordChangeByEmailCommand.cs b/Rex.Application/Modules/Users/Commands/ConfirmPasswordChangeByEmail/ConfirmPasswordChangeByEmailCommand.cs
new file mode 100644
index 0000000..2f024ec
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ConfirmPasswordChangeByEmail/ConfirmPasswordChangeByEmailCommand.cs
@@ -0,0 +1,10 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Users.Commands.ConfirmPasswordChangeByEmail;
+
+public record ConfirmPasswordChangeByEmailCommand(
+    Guid UserId,
+    string Code, 
+    string NewPassword
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ConfirmPasswordChangeByEmail/ConfirmPasswordChangeByEmailCommandHandler.cs b/Rex.Application/Modules/Users/Commands/ConfirmPasswordChangeByEmail/ConfirmPasswordChangeByEmailCommandHandler.cs
new file mode 100644
index 0000000..14ea321
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ConfirmPasswordChangeByEmail/ConfirmPasswordChangeByEmailCommandHandler.cs
@@ -0,0 +1,47 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Users.Commands.ConfirmPasswordChangeByEmail;
+
+public class ConfirmPasswordChangeByEmailCommandHandler(
+    ILogger<ConfirmPasswordChangeByEmailCommandHandler> logger,
+    IUserRepository userRepository,
+    ICodeService codeService
+) : ICommandHandler<ConfirmPasswordChangeByEmailCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(ConfirmPasswordChangeByEmailCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("ConfirmPasswordChangeByEmailCommand received as null");
+            return ResultT<ResponseDto>.Failure(
+                Error.Failure("400", "Something went wrong with your request. Please try again."));
+        }
+        
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning($"Password reset confirmation requested for non-existing user ID: {request.UserId}");
+            return ResultT<ResponseDto>.Failure(
+                Error.NotFound("404", "We couldnt find an account linked to this request."));
+        }
+        
+        var codeValidation = await codeService.ValidateCodeAsync(request.Code, cancellationToken);
+        if (!codeValidation.IsSuccess)
+        {
+            logger.LogWarning($"Invalid code provided for user ID {request.UserId}: {codeValidation.Error}");
+            return ResultT<ResponseDto>.Failure(
+                Error.Failure("422", "The code you entered is incorrect or has expired. Please request a new one and try again."));
+        }
+
+        var hashedPassword = BCrypt.Net.BCrypt.HashPassword(request.NewPassword);
+        await userRepository.UpdatePasswordAsync(user, hashedPassword, cancellationToken);
+
+        logger.LogInformation($"Password updated successfully for user ID {request.UserId}");
+        return ResultT<ResponseDto>.Success(new("Your password has been updated successfully. You can now sign in with your new password."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/InactiveAccount/InactiveAccountCommand.cs b/Rex.Application/Modules/Users/Commands/InactiveAccount/InactiveAccountCommand.cs
new file mode 100644
index 0000000..2f4b821
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/InactiveAccount/InactiveAccountCommand.cs
@@ -0,0 +1,8 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Users.Commands.InactiveAccount;
+
+public record InactiveAccountCommand(
+    Guid UserId
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/InactiveAccount/InactiveAccountCommandHandler.cs b/Rex.Application/Modules/Users/Commands/InactiveAccount/InactiveAccountCommandHandler.cs
new file mode 100644
index 0000000..19f9ded
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/InactiveAccount/InactiveAccountCommandHandler.cs
@@ -0,0 +1,41 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.Users.Commands.InactiveAccount;
+
+public class InactiveAccountCommandHandler(
+    ILogger<InactiveAccountCommandHandler> logger,
+    IUserRepository userRepository
+    ): ICommandHandler<InactiveAccountCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(InactiveAccountCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Inactive account command is null");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Oops! Something went wrong with your request."));
+        }
+        
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User {UserId} not found", request.UserId);
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "We couldn't find your account"));
+        }
+        
+        if (user.Deleted)
+        {
+            logger.LogWarning("User {UserId} account is already deactivated.", user.Id);
+            return ResultT<ResponseDto>.Failure(Error.Failure("403",
+                "Your account is already deactivated. Please contact support to reactivate your account."));
+        }
+        
+        logger.LogWarning("Deactivating user account {UserId}", user.Id);
+        await userRepository.DeleteAsync(user, cancellationToken);
+        
+        return ResultT<ResponseDto>.Success(new ("Your account has been deactivated. We're sorry to see you go!"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/Login/LoginCommand.cs b/Rex.Application/Modules/Users/Commands/Login/LoginCommand.cs
new file mode 100644
index 0000000..45971f9
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/Login/LoginCommand.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.User.Commands.Login;
+
+public record LoginCommand(
+    string Email,
+    string Password
+    ): ICommand<TokenResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/Login/LoginCommandHandler.cs b/Rex.Application/Modules/Users/Commands/Login/LoginCommandHandler.cs
new file mode 100644
index 0000000..1ecb7c1
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/Login/LoginCommandHandler.cs
@@ -0,0 +1,73 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.User.Commands.Login;
+
+public class LoginCommandHandler(
+    ILogger<LoginCommandHandler> logger,
+    IUserRepository userRepository,
+    IAuthenticationService authenticationService
+) : ICommandHandler<LoginCommand, TokenResponseDto>
+{
+    public async Task<ResultT<TokenResponseDto>> Handle(LoginCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty login request.");
+            return ResultT<TokenResponseDto>.Failure(Error.Failure("400",
+                "Oops! Looks like you didn't enter any login info."));
+        }
+
+        var user = await userRepository.GetByEmailAsync(request.Email, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User with email {Email} not found.", request.Email);
+            return ResultT<TokenResponseDto>.Failure(Error.Failure("404",
+                "Hmm, we couldn't find an account with that email."));
+        }
+
+        if (user.Status == UserStatus.Banned.ToString())
+        {
+            logger.LogWarning("User {UserId} is banned.", user.Id);
+            return ResultT<TokenResponseDto>.Failure(Error.Failure("403",
+                "Your account has been blocked. Please reach out to support for help."));
+        }
+
+        if (user.Deleted)
+        {
+            logger.LogWarning("User {UserId} account is deactivated.", user.Id);
+            return ResultT<TokenResponseDto>.Failure(Error.Failure("403",
+                "Your account is deactivated. Please contact support to reactivate your account."));
+        }
+      
+        if (user.Password is null)
+        {
+            logger.LogWarning("User {UserId} tried to log in with email/password but registered using GitHub.", user.Id);
+            return ResultT<TokenResponseDto>.Failure(Error.Failure("400",
+                "It looks like you signed up using GitHub. Please continue with GitHub to log in."));
+        }
+
+        var verifiedPassword = BCrypt.Net.BCrypt.Verify(request.Password, user.Password);
+        if (!verifiedPassword)
+        {
+            logger.LogWarning("Invalid password for user {UserId}.", user.Id);
+            return ResultT<TokenResponseDto>.Failure(Error.Failure("401",
+                "Oops! That password doesn't look right. Try again."));
+        }
+
+        user.LastLoginAt = DateTime.UtcNow;
+        await userRepository.UpdateAsync(user, cancellationToken);
+
+        var accessToken = await authenticationService.GenerateTokenAsync(user, cancellationToken);
+        var refreshToken = await authenticationService.GenerateRefreshTokenAsync(user, cancellationToken);
+
+        logger.LogInformation("User {UserId} logged in successfully.", user.Id);
+
+        return ResultT<TokenResponseDto>.Success(new TokenResponseDto(accessToken, refreshToken));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/Login/LoginValidation.cs b/Rex.Application/Modules/Users/Commands/Login/LoginValidation.cs
new file mode 100644
index 0000000..999c4e2
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/Login/LoginValidation.cs
@@ -0,0 +1,17 @@
+using FluentValidation;
+
+namespace Rex.Application.Modules.User.Commands.Login;
+
+public class LoginValidation : AbstractValidator<LoginCommand>
+{
+    public LoginValidation()
+    {
+        RuleFor(x => x.Email)
+            .NotEmpty().WithMessage("Email is required")
+            .EmailAddress().WithMessage("Email is invalid");
+
+        RuleFor(x => x.Password)
+            .NotEmpty().WithMessage("Password is required")
+            .MinimumLength(6).WithMessage("Password must be at least 6 characters");
+    }
+}
diff --git a/Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserCommand.cs b/Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserCommand.cs
new file mode 100644
index 0000000..c693532
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserCommand.cs
@@ -0,0 +1,19 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.User;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.User.Commands.RegisterUser;
+
+public record RegisterUserCommand(
+    string FirstName,
+    string LastName,
+    string UserName,
+    string Email,
+    string Password,
+    IFormFile ProfilePhoto,
+    IFormFile? CoverPhoto,
+    string? Biography,
+    Gender Gender,
+    DateTime Birthday
+    ): ICommand<RegisterUserDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserCommandHandler.cs b/Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserCommandHandler.cs
new file mode 100644
index 0000000..17874a3
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserCommandHandler.cs
@@ -0,0 +1,99 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.User;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Modules.User.Commands.RegisterUser;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Users.Commands.RegisterUser;
+
+public class RegisterUserCommandHandler(
+    ILogger<RegisterUserCommandHandler> logger,
+    IUserRepository userRepository,
+    IUserRoleRepository roleRepository,
+    ICloudinaryService cloudinaryService
+) : ICommandHandler<RegisterUserCommand, RegisterUserDto>
+{
+    public async Task<ResultT<RegisterUserDto>> Handle(RegisterUserCommand request, CancellationToken cancellationToken)
+    {
+        var userExists = await userRepository.EmailExistAsync(request.Email, cancellationToken);
+        if (userExists)
+        {
+            logger.LogInformation("Email already exists.");
+            return ResultT<RegisterUserDto>.Failure(Error.Conflict("409",
+                "Looks like this email is already in use. Try logging in or use another email."));
+        }
+
+        var userNameExists = await userRepository.UserNameExistAsync(request.UserName, cancellationToken);
+        if (userNameExists)
+        {
+            logger.LogInformation("Username already exists.");
+            return ResultT<RegisterUserDto>.Failure(Error.Conflict("409",
+                "Oops! This username is already taken. Try another one."));
+        }
+
+        var roleExists = await roleRepository.GetRoleByNameAsync(UserRole.User.ToString(), cancellationToken);
+        if (roleExists is null)
+        {
+            logger.LogWarning("Role does not exist.");
+            return ResultT<RegisterUserDto>.Failure(Error.Failure("400",
+                "Something went wrong: the user role does not exist."));
+        }
+
+        string profilePhotoUrl = "";
+        if (request.ProfilePhoto is not null)
+        {
+            await using var stream = request.ProfilePhoto.OpenReadStream();
+            profilePhotoUrl =
+                await cloudinaryService.UploadImageAsync(stream, request.ProfilePhoto.FileName, cancellationToken);
+            logger.LogInformation("Profile photo uploaded.");
+        }
+
+        string coverPhotoUrl = "";
+        if (request.CoverPhoto is not null)
+        {
+            await using var stream = request.CoverPhoto.OpenReadStream();
+            coverPhotoUrl =
+                await cloudinaryService.UploadImageAsync(stream, request.CoverPhoto.FileName, cancellationToken);
+            logger.LogInformation("Cover photo uploaded.");
+        }
+
+        Models.User user = new()
+        {
+            Id = Guid.NewGuid(),
+            FirstName = request.FirstName,
+            LastName = request.LastName,
+            UserName = request.UserName,
+            Email = request.Email,
+            Password = BCrypt.Net.BCrypt.HashPassword(request.Password),
+            ProfilePhoto = profilePhotoUrl,
+            CoverPhoto = coverPhotoUrl,
+            Biography = request.Biography,
+            Gender = request.Gender.ToString(),
+            Birthday = request.Birthday,
+            Status = UserStatus.Active.ToString(),
+            RoleId = roleExists.Id,
+            ConfirmedAccount = false,
+        };
+
+        await userRepository.CreateAsync(user, cancellationToken);
+        logger.LogInformation("User created successfully in database.");
+        
+        RegisterUserDto userDto = new(
+            UserId: user.Id,
+            FirstName: user.FirstName,
+            LastName: user.LastName,
+            UserName: user.UserName,
+            Email: user.Email,
+            ProfilePhoto: user.ProfilePhoto,
+            CoverPhoto: user.CoverPhoto,
+            Biography: user.Biography,
+            Gender: user.Gender,
+            Birthday: user.Birthday.Value
+        );
+
+        return ResultT<RegisterUserDto>.Success(userDto);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserValidation.cs b/Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserValidation.cs
new file mode 100644
index 0000000..0cec6ab
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/RegisterUser/RegisterUserValidation.cs
@@ -0,0 +1,36 @@
+using FluentValidation;
+
+namespace Rex.Application.Modules.User.Commands.RegisterUser;
+
+public class RegisterUserValidation: AbstractValidator<RegisterUserCommand>
+{
+    private readonly string[] _allowedExtensions = [".jpg", ".jpeg", ".png"];
+
+    public RegisterUserValidation()
+    {
+        RuleFor(n => n.FirstName)
+            .NotEmpty().WithMessage("Name is required");
+        
+        RuleFor(n => n.LastName)
+            .NotEmpty().WithMessage("Lastname is required");
+        
+        RuleFor(n => n.Email)
+            .NotEmpty().WithMessage("Email is required")
+            .EmailAddress().WithMessage("Email is invalid");
+
+        RuleFor(n => n.Password)
+            .NotEmpty().WithMessage("Password is required")
+            .MinimumLength(6).WithMessage("Password must be at least 6 characters long")
+            .MaximumLength(30).WithMessage("Password cannot be longer than 30 characters");
+        
+        When(n => n.ProfilePhoto is not null, () =>
+        {
+            RuleFor(n => n.ProfilePhoto)
+                .Must(n => n.Length > 0).WithMessage("Profile photo is required")
+                .Must(n => _allowedExtensions.Contains(Path.GetExtension(n.FileName).ToLower()))
+                .WithMessage("Profile photo extension is not supported")
+                .Must(n => n.Length <= 5 * 1024 * 1024)
+                .WithMessage("Profile photo size is too big");
+        });
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeCommand.cs b/Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeCommand.cs
new file mode 100644
index 0000000..44e40ab
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeCommand.cs
@@ -0,0 +1,8 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.User.Commands.ResendCode;
+
+public record ResendCodeCommand(
+    string Email
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeCommandHandler.cs b/Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeCommandHandler.cs
new file mode 100644
index 0000000..3984b63
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeCommandHandler.cs
@@ -0,0 +1,61 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Configs;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.User.Commands.ResendCode;
+
+public class ResendCodeCommandHandler(
+    ILogger<ResendCodeCommandHandler> logger,
+    IUserRepository userRepository,
+    IEmailService emailService,
+    ICodeService codeService
+) : ICommandHandler<ResendCodeCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(ResendCodeCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request to resend code.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "Oops! We didn't get any information to resend the code."));
+        }
+
+        var user = await userRepository.GetByEmailAsync(request.Email, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found when trying to resend code.");
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404",
+                "Hmm, we couldn't find an account with that email."));
+        }
+
+        var accountConfirmed = await userRepository.ConfirmedAccountAsync(user.Id, cancellationToken);
+        if (accountConfirmed)
+        {
+            logger.LogInformation("Account already confirmed. No need to resend code.");
+            return ResultT<ResponseDto>.Failure(Error.Conflict("409",
+                "Your account is already confirmed. No need to resend the code."));
+        }
+
+        var code = await codeService.CreateCodeAsync(user.Id, CodeType.ConfirmAccount, cancellationToken);
+        if (!code.IsSuccess)
+        {
+            logger.LogWarning("Failed to create confirmation code.");
+            return ResultT<ResponseDto>.Failure(code.Error!);
+        }
+
+        await emailService.SendEmailAsync(new EmailDto(
+            request.Email,
+            EmailTemplate.ConfirmAccountTemplate(user.FirstName, user.LastName, code.Value),
+            "Confirm Your Account"
+        ));
+
+        logger.LogInformation("Confirmation email sent.");
+        return ResultT<ResponseDto>.Success(
+            new ResponseDto("Great! We've sent a new confirmation code to your email."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeValidation.cs b/Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeValidation.cs
new file mode 100644
index 0000000..d94c11e
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/ResendCode/ResendCodeValidation.cs
@@ -0,0 +1,13 @@
+using FluentValidation;
+
+namespace Rex.Application.Modules.User.Commands.ResendCode;
+
+public class ResendCodeValidation : AbstractValidator<ResendCodeCommand>
+{
+    public ResendCodeValidation()
+    {
+        RuleFor(x => x.Email)
+            .NotEmpty().WithMessage("Email is required")
+            .EmailAddress().WithMessage("Email is invalid");
+    }
+}
diff --git a/Rex.Application/Modules/Users/Commands/UpdateEmail/UpdateEmailCommand.cs b/Rex.Application/Modules/Users/Commands/UpdateEmail/UpdateEmailCommand.cs
new file mode 100644
index 0000000..dc113fe
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdateEmail/UpdateEmailCommand.cs
@@ -0,0 +1,10 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.User.Commands.UpdateEmail;
+
+public record UpdateEmailCommand(
+    Guid UserId,
+    string Email,
+    string NewEmail
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/UpdateEmail/UpdateEmailCommandHandler.cs b/Rex.Application/Modules/Users/Commands/UpdateEmail/UpdateEmailCommandHandler.cs
new file mode 100644
index 0000000..099c04e
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdateEmail/UpdateEmailCommandHandler.cs
@@ -0,0 +1,80 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Configs;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.User.Commands.UpdateEmail;
+
+public class UpdateEmailCommandHandler(
+    ILogger<UpdateEmailCommandHandler> logger,
+    IUserRepository userRepository,
+    IEmailService emailService,
+    ICodeService codeService,
+    IDistributedCache cache
+) : ICommandHandler<UpdateEmailCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(UpdateEmailCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request to update email.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "Oops! We didn't get the information needed to update your email."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found for email update.");
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Hmm, we couldn't find your account."));
+        }
+
+        var isEmailInUseByYou =
+            await userRepository.EmailInUseByYouAsync(request.UserId, request.Email, cancellationToken);
+        if (!isEmailInUseByYou)
+        {
+            logger.LogWarning("Current email mismatch.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "The current email you provided doesn't match our records."));
+        }
+
+        var emailExists = await userRepository.EmailInUseAsync(request.NewEmail, request.UserId, cancellationToken);
+        if (emailExists)
+        {
+            logger.LogWarning("New email already in use.");
+            return ResultT<ResponseDto>.Failure(Error.Conflict("409", "Oops! That new email is already being used."));
+        }
+
+        var codeResult =
+            await codeService.CreateCodeAsync(request.UserId, CodeType.EmailConfirmation, cancellationToken);
+        if (!codeResult.IsSuccess)
+        {
+            logger.LogWarning("Failed to create confirmation code.");
+            return ResultT<ResponseDto>.Failure(codeResult.Error ??
+                                                Error.Failure("400", 
+                                                    "Something went wrong while generating the confirmation code."));
+        }
+
+        user.Email = request.NewEmail;
+        user.ConfirmedAccount = false;
+
+        await emailService.SendEmailAsync(new EmailDto(
+            user.Email,
+            EmailTemplate.ConfirmEmailChangeTemplate(user.FirstName, user.Email, request.NewEmail, codeResult.Value),
+            "Confirm Your New Email"
+        ));
+
+        await userRepository.UpdateAsync(user, cancellationToken);
+
+        await cache.IncrementVersionAsync("user", request.UserId, logger, cancellationToken);
+        
+        logger.LogInformation("Confirmation email sent for new email.");
+        return ResultT<ResponseDto>.Success(
+            new ResponseDto("Great! A confirmation email has been sent to your new address."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/UpdatePassword/UpdatePasswordCommand.cs b/Rex.Application/Modules/Users/Commands/UpdatePassword/UpdatePasswordCommand.cs
new file mode 100644
index 0000000..1a002d0
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdatePassword/UpdatePasswordCommand.cs
@@ -0,0 +1,10 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.User.Commands.UpdatePassword;
+
+public record UpdatePasswordCommand(
+    Guid UserId,
+    string CurrentPassword,
+    string NewPassword
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/UpdatePassword/UpdatePasswordCommandHandler.cs b/Rex.Application/Modules/Users/Commands/UpdatePassword/UpdatePasswordCommandHandler.cs
new file mode 100644
index 0000000..1b1e59f
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdatePassword/UpdatePasswordCommandHandler.cs
@@ -0,0 +1,43 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.User.Commands.UpdatePassword;
+
+public class UpdatePasswordCommandHandler(
+    ILogger<UpdatePasswordCommandHandler> logger,
+    IUserRepository userRepository
+): ICommandHandler<UpdatePasswordCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(UpdatePasswordCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request to update password.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Oops! We didn't get the information needed to update your password."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found for password update.");
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Hmm, we couldn't find your account."));
+        }
+
+        var passwordCheck = BCrypt.Net.BCrypt.Verify(request.CurrentPassword, user.Password);
+        if (!passwordCheck)
+        {
+            logger.LogInformation("Current password is incorrect.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Oops! The current password you entered is incorrect."));
+        }
+
+        var hashedPassword = BCrypt.Net.BCrypt.HashPassword(request.NewPassword);
+        await userRepository.UpdatePasswordAsync(user, hashedPassword, cancellationToken);
+
+        logger.LogInformation("Password updated successfully.");
+        return ResultT<ResponseDto>.Success(new ResponseDto("Great! Your password has been updated successfully."));
+    }
+
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/UpdatePasswordByEmail/UpdatePasswordByEmailCommand.cs b/Rex.Application/Modules/Users/Commands/UpdatePasswordByEmail/UpdatePasswordByEmailCommand.cs
new file mode 100644
index 0000000..b298223
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdatePasswordByEmail/UpdatePasswordByEmailCommand.cs
@@ -0,0 +1,8 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.Users.Commands.UpdatePasswordByEmail;
+
+public record UpdatePasswordByEmailCommand(
+    string Email
+    ):ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/UpdatePasswordByEmail/UpdatePasswordByEmailCommandHandler.cs b/Rex.Application/Modules/Users/Commands/UpdatePasswordByEmail/UpdatePasswordByEmailCommandHandler.cs
new file mode 100644
index 0000000..b769a9b
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdatePasswordByEmail/UpdatePasswordByEmailCommandHandler.cs
@@ -0,0 +1,54 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.Configs;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Modules.Users.Commands.UpdatePasswordByEmail;
+
+public class UpdatePasswordByEmailCommandHandler(
+    ILogger<UpdatePasswordByEmailCommandHandler> logger,
+    IUserRepository userRepository,
+    IEmailService emailService,
+    ICodeService codeService
+    ): ICommandHandler<UpdatePasswordByEmailCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(UpdatePasswordByEmailCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("UpdatePasswordByEmailCommand received as null");
+            return ResultT<ResponseDto>.Failure(
+                Error.Failure("400", "We couldnt process your request. Please try again."));
+        }
+
+        var user = await userRepository.GetByEmailAsync(request.Email, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning($"Password reset requested for non-existing email: {request.Email}");
+            return ResultT<ResponseDto>.Failure(
+                Error.NotFound("404", "We couldnt find an account with this email address."));
+        }
+
+        var code = await codeService.CreateCodeAsync(user.Id, CodeType.ForgotPassword, cancellationToken);
+        if (!code.IsSuccess)
+        {
+            logger.LogWarning($"Could not generate password reset code for user ID {user.Id}: {code.Error}");
+            return ResultT<ResponseDto>.Failure(
+                Error.Failure("422", "We couldnt generate a reset code at this time. Please try again."));
+        }
+
+        await emailService.SendEmailAsync(new EmailDto(
+            request.Email,
+            EmailTemplate.ConfirmForgotPasswordTemplate(user.FirstName, user.LastName, code.Value),
+            "Your Rex Password Reset Code")
+        );
+
+        logger.LogInformation($"Password reset code sent to {user.Email}");
+        return ResultT<ResponseDto>.Success(new("Weve sent a verification code to your email. Enter it in the app to reset your password."));
+    }
+
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/UpdateUserInformation/UpdateUserInformationCommand.cs b/Rex.Application/Modules/Users/Commands/UpdateUserInformation/UpdateUserInformationCommand.cs
new file mode 100644
index 0000000..4898977
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdateUserInformation/UpdateUserInformationCommand.cs
@@ -0,0 +1,13 @@
+using Microsoft.AspNetCore.Http;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.User.Commands.UpdateUserInformation;
+
+public record UpdateUserInformationCommand(
+    Guid UserId,
+    IFormFile? ProfilePhoto,
+    string? Firstname,
+    string? Lastname,
+    string? Biography
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/UpdateUserInformation/UpdateUserInformationCommandHandler.cs b/Rex.Application/Modules/Users/Commands/UpdateUserInformation/UpdateUserInformationCommandHandler.cs
new file mode 100644
index 0000000..457a7c6
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdateUserInformation/UpdateUserInformationCommandHandler.cs
@@ -0,0 +1,54 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.User.Commands.UpdateUserInformation;
+
+public class UpdateUserInformationCommandHandler(
+    ILogger<UpdateUserInformationCommandHandler> logger,
+    IUserRepository userRepository,
+    ICloudinaryService cloudinaryService,
+    IDistributedCache cache
+) : ICommandHandler<UpdateUserInformationCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(UpdateUserInformationCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request to update user information.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400", "Oops! We didn't get the information needed to update your profile."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found for profile update.");
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Hmm, we couldn't find your account."));
+        }
+
+        string profilePhoto = "";
+        if (request.ProfilePhoto != null)
+        {
+            logger.LogInformation("Uploading new profile photo.");
+            await using var stream = request.ProfilePhoto.OpenReadStream();
+            profilePhoto = await cloudinaryService.UploadImageAsync(stream, request.ProfilePhoto.FileName, cancellationToken);
+        }
+
+        user.ProfilePhoto = profilePhoto;
+        user.FirstName = request.Firstname;
+        user.LastName = request.Lastname;
+        user.Biography = request.Biography;
+
+        await userRepository.UpdateAsync(user, cancellationToken);
+        
+        await cache.IncrementVersionAsync("user", request.UserId, logger, cancellationToken);
+
+        logger.LogInformation("User information updated successfully.");
+        return ResultT<ResponseDto>.Success(new ResponseDto("Great! Your profile has been updated successfully."));
+    }
+    
+}
diff --git a/Rex.Application/Modules/Users/Commands/UpdateUsername/UpdateUsernameCommand.cs b/Rex.Application/Modules/Users/Commands/UpdateUsername/UpdateUsernameCommand.cs
new file mode 100644
index 0000000..0f693bd
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdateUsername/UpdateUsernameCommand.cs
@@ -0,0 +1,9 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+
+namespace Rex.Application.Modules.User.Commands.UpdateUsername;
+
+public record UpdateUsernameCommand(
+    Guid UserId,
+    string Username
+    ): ICommand<ResponseDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Commands/UpdateUsername/UpdateUsernameCommandHandler.cs b/Rex.Application/Modules/Users/Commands/UpdateUsername/UpdateUsernameCommandHandler.cs
new file mode 100644
index 0000000..ab0384c
--- /dev/null
+++ b/Rex.Application/Modules/Users/Commands/UpdateUsername/UpdateUsernameCommandHandler.cs
@@ -0,0 +1,49 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.User.Commands.UpdateUsername;
+
+public class UpdateUsernameCommandHandler(
+    ILogger<UpdateUsernameCommandHandler> logger,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : ICommandHandler<UpdateUsernameCommand, ResponseDto>
+{
+    public async Task<ResultT<ResponseDto>> Handle(UpdateUsernameCommand request, CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request to update username.");
+            return ResultT<ResponseDto>.Failure(Error.Failure("400",
+                "Oops! We didn't get the information needed to update your username."));
+        }
+
+        var user = await userRepository.GetByIdAsync(request.UserId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning("User not found for username update.");
+            return ResultT<ResponseDto>.Failure(Error.NotFound("404", "Hmm, we couldn't find your account."));
+        }
+
+        var usernameInUse =
+            await userRepository.UserNameInUseAsync(request.UserId, request.Username, cancellationToken);
+        if (usernameInUse)
+        {
+            logger.LogWarning("Username '{Username}' is already in use.", request.Username);
+            return ResultT<ResponseDto>.Failure(Error.Conflict("409",
+                "Oops! This username is already taken. Try another one."));
+        }
+
+        user.UserName = request.Username;
+        await userRepository.UpdateAsync(user, cancellationToken);
+        
+        await cache.IncrementVersionAsync("user", request.UserId, logger, cancellationToken);
+
+        logger.LogInformation("Username updated successfully.");
+        return ResultT<ResponseDto>.Success(new ResponseDto("Great! Your username has been updated successfully."));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Queries/GetUserDetails/GetUserDetailsByIdQuery.cs b/Rex.Application/Modules/Users/Queries/GetUserDetails/GetUserDetailsByIdQuery.cs
new file mode 100644
index 0000000..15a559e
--- /dev/null
+++ b/Rex.Application/Modules/Users/Queries/GetUserDetails/GetUserDetailsByIdQuery.cs
@@ -0,0 +1,8 @@
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.User;
+
+namespace Rex.Application.Modules.User.Queries.GetUserDetails;
+
+public record GetUserDetailsByIdQuery(
+    Guid UserId
+    ): IQuery<UserProfileDto>;
\ No newline at end of file
diff --git a/Rex.Application/Modules/Users/Queries/GetUserDetails/GetUserDetailsByIdQueryHandler.cs b/Rex.Application/Modules/Users/Queries/GetUserDetails/GetUserDetailsByIdQueryHandler.cs
new file mode 100644
index 0000000..a82d1e2
--- /dev/null
+++ b/Rex.Application/Modules/Users/Queries/GetUserDetails/GetUserDetailsByIdQueryHandler.cs
@@ -0,0 +1,62 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Abstractions.Messages;
+using Rex.Application.DTOs.User;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Modules.User.Queries.GetUserDetails;
+
+public class GetUserDetailsByIdQueryHandler(
+    ILogger<GetUserDetailsByIdQueryHandler> logger,
+    IUserRepository userRepository,
+    IDistributedCache cache
+) : IQueryHandler<GetUserDetailsByIdQuery, UserProfileDto>
+{
+    public async Task<ResultT<UserProfileDto>> Handle(GetUserDetailsByIdQuery request,
+        CancellationToken cancellationToken)
+    {
+        if (request is null)
+        {
+            logger.LogWarning("Received empty request for user details.");
+            return ResultT<UserProfileDto>.Failure(Error.Failure("400",
+                "Oops! We didn't get the information needed to fetch your profile."));
+        }
+
+        var version = await cache.GetVersionAsync("user", request.UserId, cancellationToken);
+        var cacheKey = $"get:user:details:{request.UserId.ToString().ToLower()}:version:{version}";
+        
+        var userCache = await cache.GetOrCreateAsync(
+            cacheKey,
+            async () => await userRepository.GetUserDetailsAsync(request.UserId, cancellationToken),
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        if (userCache is null)
+        {
+            logger.LogWarning("User not found when retrieving details.");
+            return ResultT<UserProfileDto>.Failure(Error.NotFound("404", "Hmm, we couldn't find your profile."));
+        }
+
+        UserProfileDto userDto = new(
+            userCache.FirstName,
+            userCache.LastName,
+            userCache.Email,
+            userCache.UserName,
+            userCache.ProfilePhoto,
+            userCache.CoverPhoto,
+            userCache.Birthday ?? DateTime.MinValue,
+            userCache.CreatedAt,
+            userCache.Biography,
+            userCache.Gender,
+            userCache.LastLoginAt,
+            userCache.UserGroups?.Count ?? 0,
+            userCache.Reactions?.Count ?? 0,
+            userCache.UserChallenges?.Count ?? 0
+        );
+
+        logger.LogInformation("User details retrieved successfully.");
+        return ResultT<UserProfileDto>.Success(userDto);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Pagination/PagedResult.cs b/Rex.Application/Pagination/PagedResult.cs
new file mode 100644
index 0000000..83d3c7c
--- /dev/null
+++ b/Rex.Application/Pagination/PagedResult.cs
@@ -0,0 +1,24 @@
+namespace Rex.Application.Pagination;
+
+public class PagedResult<T>
+{
+    public PagedResult()
+    {
+        
+    }
+    public PagedResult(IEnumerable<T>? items, int totalItems, int actualPage, int pageSize)
+    {
+        Items = items;
+        TotalItems = totalItems;
+        ActualPage = actualPage;
+        TotalPages = pageSize > 0
+            ? (int)Math.Ceiling(totalItems / (double)pageSize)
+            : 0;
+    }
+    
+    public IEnumerable<T> Items { get; set; }
+    public int TotalItems { get; set; }
+    public int ActualPage { get; set; }
+    public int TotalPages { get; set; }
+    
+}
\ No newline at end of file
diff --git a/Rex.Application/Rex.Application.csproj b/Rex.Application/Rex.Application.csproj
new file mode 100644
index 0000000..d8d4c63
--- /dev/null
+++ b/Rex.Application/Rex.Application.csproj
@@ -0,0 +1,31 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+    <PropertyGroup>
+        <TargetFramework>net8.0</TargetFramework>
+        <ImplicitUsings>enable</ImplicitUsings>
+        <Nullable>enable</Nullable>
+    </PropertyGroup>
+
+    <ItemGroup>
+      <PackageReference Include="BCrypt.Net-Next" Version="4.0.3" />
+      <PackageReference Include="FluentValidation" Version="11.10.0" />
+      <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.10.0" />
+      <PackageReference Include="Hangfire.Core" Version="1.8.0" />
+      <PackageReference Include="MediatR" Version="12.2.0" />
+      <PackageReference Include="MediatR.Extensions.Microsoft.DependencyInjection" Version="11.0.0" />
+      <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.10" />
+      <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" Version="8.0.10" />
+      <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.1" />
+      <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.10" />
+      <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <ProjectReference Include="..\Rex.Domain\Rex.Domain.csproj" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <Folder Include="Modules\Reactions\Queries\" />
+    </ItemGroup>
+
+</Project>
diff --git a/Rex.Application/Services/ChallengeExpirationService.cs b/Rex.Application/Services/ChallengeExpirationService.cs
new file mode 100644
index 0000000..1a6d6e1
--- /dev/null
+++ b/Rex.Application/Services/ChallengeExpirationService.cs
@@ -0,0 +1,39 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+
+namespace Rex.Application.Services;
+
+public class ChallengeExpirationService(
+    ILogger<ChallengeExpirationService> logger,
+    IChallengeRepository challengeRepository
+) : IChallengeExpirationService
+{
+    public async Task<ResultT<ResponseDto>> MarkChallengeExpired(CancellationToken cancellationToken)
+    {
+        var challenges = await challengeRepository.GetExpiredChallenges(cancellationToken);
+
+        if (challenges is null || !challenges.Any())
+        {
+            logger.LogInformation("No expired challenges found to process");
+            return ResultT<ResponseDto>.Success(new ResponseDto("No expired challenges found at this time"));
+        }
+
+        foreach (var challenge in challenges)
+        {
+            challenge.Status = ChallengeStatus.Ended.ToString();
+            challenge.UpdatedAt = DateTime.UtcNow;
+        }
+
+        await challengeRepository.UpdateRangeAsync(challenges, cancellationToken);
+
+        logger.LogInformation("Successfully marked {Count} challenge(s) as expired", challenges.Count());
+
+        return ResultT<ResponseDto>.Success(
+            new ResponseDto($"Successfully marked {challenges.Count()} challenge(s) as expired")
+        );
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Services/CodeService.cs b/Rex.Application/Services/CodeService.cs
new file mode 100644
index 0000000..2ddf456
--- /dev/null
+++ b/Rex.Application/Services/CodeService.cs
@@ -0,0 +1,172 @@
+using Microsoft.Extensions.Logging;
+using Rex.Application.DTOs.Code;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Services;
+
+public class CodeService(
+    ICodeRepository codeRepository,
+    IUserRepository userRepository,
+    ILogger<CodeService> logger
+    ): ICodeService
+{
+    public async Task<ResultT<string>> CreateCodeAsync(Guid userId, CodeType codeType, CancellationToken cancellationToken)
+    {
+        var user = await userRepository.GetByIdAsync(userId, cancellationToken);
+
+        if (user is null)
+        {
+            logger.LogWarning($"User with ID {userId} not found");
+            return ResultT<string>.Failure(Error.NotFound("404", "User not found"));
+        }
+
+        if (codeType == CodeType.ConfirmAccount && user.ConfirmedAccount)
+        {
+            logger.LogWarning($"User with ID {userId} already has a confirmed account");
+            return ResultT<string>.Failure(Error.Failure("409", "Account already confirmed"));
+        }
+    
+        string generatedCode = CodeGenerator.GenerateCode();
+
+        Code code = new()
+        {
+            Id = Guid.NewGuid(),
+            UserId = user.Id,
+            Value = generatedCode,
+            Expiration = DateTime.UtcNow.AddMinutes(15),
+            Type = codeType.ToString()
+        };
+    
+        await codeRepository.CreateCodeAsync(code, cancellationToken);
+        logger.LogInformation($"Code {generatedCode} created for user ID {userId} with type {codeType}");
+
+        return ResultT<string>.Success(code.Value);
+    }
+
+
+    public async Task<ResultT<CodeDto>> GetCodeByIdAsync(Guid id, CancellationToken cancellationToken)
+    {
+        var code = await codeRepository.GetCodeByIdAsync(id, cancellationToken);
+
+        if (code is null)
+        {
+            logger.LogWarning("Code with the given ID does not exist");
+            return ResultT<CodeDto>.Failure(Error.NotFound("404", "Code with the specified ID does not exist"));
+        }
+
+        CodeDto codeDto = new
+        (
+            CodeId: code.Id,
+            UserId: code.UserId,
+            Code: code.Value,
+            IsUsed: code.Used,
+            Expiration: code.Expiration
+        );
+    
+        logger.LogInformation($"Code with ID {id} retrieved successfully");
+        return ResultT<CodeDto>.Success(codeDto);
+    }
+
+
+    public async Task<Result> ConfirmCodeAsync(Guid userId, string code, CancellationToken cancellationToken)
+    {
+        var user = await userRepository.GetByIdAsync(userId, cancellationToken);
+        if (user is null)
+        {
+            logger.LogWarning($"User with ID {userId} not found");
+            return ResultT<string>.Failure(Error.NotFound("404", "User not found"));
+        }
+    
+        var codeEntity = await codeRepository.GetCodeByValueAsync(code, cancellationToken);
+        if (codeEntity is null)
+        {
+            logger.LogWarning($"Code '{code}' does not exist");
+            return Result.Failure(Error.NotFound("404", "Code with the specified value does not exist"));
+        }
+
+        if (codeEntity.UserId != userId)
+        {
+            logger.LogWarning($"Code '{code}' does not belong to user ID {userId}");
+            return Result.Failure(Error.Failure("403", "Code does not belong to the specified user"));
+        }
+
+        if (codeEntity.Used)
+        {
+            logger.LogWarning($"Code '{code}' has already been used");
+            return Result.Failure(Error.Failure("400", "Code has already been used"));
+        }
+    
+        var isValidCode = await codeRepository.IsCodeValidAsync(code, cancellationToken);
+        if (!isValidCode)
+        {
+            logger.LogWarning($"Code '{code}' is expired or invalid");
+            return Result.Failure(Error.Failure("400", "Code is invalid or expired"));
+        }
+
+        if (codeEntity.Type == CodeType.EmailConfirmation.ToString())
+        {
+            user.ConfirmedAccount = true;
+            await userRepository.UpdateAsync(user, cancellationToken);
+            
+            await codeRepository.MarkCodeAsUsedAsync(code, cancellationToken);
+            logger.LogInformation("User {UserId} successfully changed email", user.Id);
+            
+            return Result.Success();
+        }
+
+        user.ConfirmedAccount = true;
+        await userRepository.UpdateAsync(user, cancellationToken);
+        
+        await codeRepository.MarkCodeAsUsedAsync(code, cancellationToken);
+        
+        logger.LogInformation("User {UserId} account confirmed successfully", user.Id);
+        return Result.Success();
+    }
+
+
+    public async Task<Result> IsCodeValidAsync(string code, CancellationToken cancellationToken)
+    {
+        if (string.IsNullOrEmpty(code))
+        {
+            logger.LogWarning("The provided code is null or empty");
+            return ResultT<string>.Failure(Error.Failure("400", "The code cannot be empty"));
+        }
+    
+        var isUsed = await codeRepository.IsCodeUsedAsync(code, cancellationToken);
+
+        if (isUsed)
+        {
+            logger.LogWarning("The code has already been used");
+            return ResultT<string>.Failure(Error.Conflict("409", "This code has already been used"));
+        }
+    
+        logger.LogInformation("The code is valid and available");
+        return Result.Success();
+    }
+
+
+    public async Task<ResultT<string>> ValidateCodeAsync(string code, CancellationToken cancellationToken)
+    {
+        if (string.IsNullOrEmpty(code))
+        {
+            logger.LogWarning("The code provided is null or empty");
+            return ResultT<string>.Failure(Error.Failure("400", "The code cannot be empty"));
+        }
+    
+        var isValid = await codeRepository.IsCodeValidAsync(code, cancellationToken);
+
+        if (!isValid)
+        {
+            logger.LogWarning("The code is either used or expired");
+            return ResultT<string>.Failure(Error.Conflict("409", "The code is invalid, either used or expired"));
+        }
+    
+        logger.LogInformation("The code is valid and can be used");
+        return ResultT<string>.Success("The code is valid");
+    }
+
+}
\ No newline at end of file
diff --git a/Rex.Application/Services/MessageService.cs b/Rex.Application/Services/MessageService.cs
new file mode 100644
index 0000000..a898cc1
--- /dev/null
+++ b/Rex.Application/Services/MessageService.cs
@@ -0,0 +1,87 @@
+using Microsoft.AspNetCore.Http;
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.DTOs.Message;
+using Rex.Application.Helpers;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Services;
+
+public class MessageService(
+    ILogger<MessageService> logger,
+    IUserChatRepository userChatRepository,
+    IMessageRepository messageRepository,
+    IUserRepository userRepository,
+    IChatRepository chatRepository,
+    IChatNotifier chatNotifier,
+    IFileRepository fileRepository,
+    IEntityFileRepository entityFileRepository,
+    ICloudinaryService cloudinaryService,
+    IDistributedCache cache
+) : IMessageService
+{
+    public async Task<ResultT<MessageDto>> SendMessageAsync(Guid chatId, Guid userId, string messageText,
+        IEnumerable<IFormFile?> files = null, CancellationToken cancellationToken = default)
+    {
+        var chat = await chatRepository.GetByIdAsync(chatId, cancellationToken);
+        if (chat is null)
+        {
+            logger.LogWarning("Chat {ChatId} not found for user {UserId}", chatId, userId);
+            return ResultT<MessageDto>.Failure(Error.Failure("404", "Chat not found."));
+        }
+
+        if (chat.Deleted)
+        {
+            logger.LogWarning("User {UserId} attempted to send a message to deleted chat {ChatId}.", userId, chatId);
+            return ResultT<MessageDto>.Failure(Error.Failure("403", "You cannot send messages to a chat that has been deactivated."));
+        }
+
+        var belongs = await userChatRepository.IsUserInChatAsync(userId, chatId, cancellationToken);
+        if (!belongs)
+            return ResultT<MessageDto>.Failure(Error.Failure("403", "You don't have access to this chat."));
+
+        var sender = await userRepository.GetByIdAsync(userId, cancellationToken);
+        if (sender is null)
+            return ResultT<MessageDto>.Failure(Error.Failure("404", "User not found."));
+
+        var message = new Message
+        {
+            ChatId = chatId,
+            SenderId = userId,
+            Description = messageText
+        };
+
+        await messageRepository.CreateAsync(message, cancellationToken);
+        
+        await cache.IncrementVersionAsync("chat-messages", chatId, logger, cancellationToken);
+        logger.LogInformation("Cache invalidated for chat messages of ChatId: {ChatId}", chatId);
+
+        if (files is not null)
+        {
+            await ProcessFiles.ProcessFilesAsync(logger, files, chatId,
+                fileRepository, entityFileRepository,
+                cloudinaryService, TargetType.Message, cancellationToken);
+        }
+
+        var dto = new MessageDto(
+            message.Id,
+            message.ChatId,
+            message.SenderId,
+            $"{sender.FirstName} {sender.LastName}",
+            sender.ProfilePhoto,
+            message.Description,
+            message.CreatedAt
+        );
+
+        await chatNotifier.NotifyMessageAsync(chatId, dto);
+
+        logger.LogInformation("User {UserId} sent message to chat {ChatId}", userId, chatId);
+
+        return ResultT<MessageDto>.Success(dto);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Services/RemoveUserService.cs b/Rex.Application/Services/RemoveUserService.cs
new file mode 100644
index 0000000..abe1059
--- /dev/null
+++ b/Rex.Application/Services/RemoveUserService.cs
@@ -0,0 +1,76 @@
+using System.Text.Json;
+using Microsoft.Extensions.Logging;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Helpers;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Services;
+
+public class RemoveUserService(
+    ILogger<RemoveUserService> logger,
+    IUserGroupRepository userGroupRepository,
+    IInactiveUserNotifier notifier
+) : IRemoveUserService
+{
+    public async Task<ResultT<ResponseDto>> ProcessRemoval(CancellationToken cancellationToken)
+    {
+        var users = await userGroupRepository.GetInactiveUserGroupsForRemoval(
+            InactivityThresholds.RemovalDays,
+            cancellationToken
+        );
+
+        var validUsers = users?.Where(u => u.User != null).ToList();
+
+        if (validUsers == null || !validUsers.Any())
+        {
+            logger.LogInformation("No inactive users found for removal.");
+            return ResultT<ResponseDto>.Success(new ResponseDto("No inactive users to remove"));
+        }
+
+        var processedCount = 0;
+
+        foreach (var user in validUsers)
+        {
+            var metadata = new
+            {
+                GroupId = user.GroupId,
+                UserId = user.UserId,
+                RemovalDays = InactivityThresholds.RemovalDays
+            };
+
+            var notification = new Notification
+            {
+                Title = "Removed from Group Due to Inactivity",
+                Description =
+                    $"Hi {user.User.FirstName}, you have been removed from '{user.Group?.Title ?? "the group"}' due to {InactivityThresholds.RemovalDays} days of inactivity. You're welcome to rejoin if you wish to participate again.",
+                UserId = user.UserId,
+                RecipientType = TargetType.User.ToString(),
+                RecipientId = user.UserId,
+                MetadataJson = JsonSerializer.Serialize(metadata),
+                Read = false,
+                CreatedAt = DateTime.UtcNow
+            };
+
+            await notifier.SendBanNotification(notification, cancellationToken);
+
+            user.Status = RequestStatus.Removed.ToString();
+            await userGroupRepository.UpdateAsync(user, cancellationToken);
+
+            processedCount++;
+
+            logger.LogInformation("User {UserId} removed from group {GroupId} due to inactivity",
+                user.UserId, user.GroupId);
+        }
+
+        logger.LogInformation("Removal process completed for {Count} users", processedCount);
+
+        return ResultT<ResponseDto>.Success(
+            new ResponseDto($"Users removed: {processedCount}")
+        );
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Services/UserInGroupService.cs b/Rex.Application/Services/UserInGroupService.cs
new file mode 100644
index 0000000..08951a9
--- /dev/null
+++ b/Rex.Application/Services/UserInGroupService.cs
@@ -0,0 +1,56 @@
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+
+namespace Rex.Application.Services;
+
+public class UserInGroupService(
+    ILogger<UserInGroupService> logger,
+    IDistributedCache cache,
+    IUserGroupRepository userGroupRepository,
+    IUserRepository userRepository
+) : IUserInGroupService
+{
+    public async Task<ResultT<string>> GetUserRoleInGroupAsync(Guid userId, Guid groupId,
+        CancellationToken cancellationToken)
+    {
+        var version = await cache.GetVersionAsync("group-members", groupId, cancellationToken);
+        var cacheKey = $"group-members:{userId}:{groupId}:version:{version}";
+
+        var userGroup = await cache.GetOrCreateAsync(
+            cacheKey, async () =>
+            {
+                var user = await userRepository.GetByIdAsync(userId, cancellationToken);
+                if (user is null)
+                {
+                    logger.LogWarning("User with ID {UserId} was not found in the system.", userId);
+                    return ResultT<string>.Failure(
+                        Error.NotFound("404", "The specified user does not exist.")
+                    );
+                }
+
+                var userGroup = await userGroupRepository.GetMemberAsync(userId, groupId, cancellationToken);
+                if (userGroup is null)
+                {
+                    logger.LogWarning(
+                        "User with ID {UserId} is not associated with group ID {GroupId}.",
+                        userId,
+                        groupId
+                    );
+
+                    return ResultT<string>.Failure(
+                        Error.NotFound("404", "The user is not a member of this group.")
+                    );
+                }
+
+                return userGroup.GroupRole.Role;
+            },
+            logger,
+            cancellationToken: cancellationToken
+        );
+
+        return ResultT<string>.Success(userGroup.Value);
+    }
+}
diff --git a/Rex.Application/Services/WarnUserService.cs b/Rex.Application/Services/WarnUserService.cs
new file mode 100644
index 0000000..bfead61
--- /dev/null
+++ b/Rex.Application/Services/WarnUserService.cs
@@ -0,0 +1,74 @@
+using System.Text.Json;
+using Microsoft.Extensions.Logging;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Helpers;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Rex.Models;
+
+namespace Rex.Application.Services;
+
+public class WarnUserService(
+    ILogger<WarnUserService> logger,
+    IUserGroupRepository userGroupRepository,
+    IInactiveUserNotifier notifier
+) : IWarnUserService
+{
+    public async Task<ResultT<ResponseDto>> ProcessWarning(CancellationToken cancellationToken)
+    {
+        var users = await userGroupRepository.GetInactiveUserGroupsForWarning(
+            InactivityThresholds.WarningDays,
+            cancellationToken
+        );
+
+        var validUsers = users?.Where(u => u.User != null).ToList();
+
+        if (validUsers == null || !validUsers.Any())
+        {
+            logger.LogInformation("No inactive users found for warning.");
+            return ResultT<ResponseDto>.Success(new ResponseDto("No inactive users to warn"));
+        }
+
+        var now = DateTime.UtcNow;
+        var userIds = new List<Guid>();
+
+        foreach (var user in validUsers)
+        {
+            var metadata = new
+            {
+                GroupId = user.GroupId,
+                UserId = user.UserId,
+                WarningDays = InactivityThresholds.WarningDays
+            };
+
+            var notification = new Notification
+            {
+                Title = "We Miss You in the Group!",
+                Description =
+                    $"Hi {user.User.FirstName}, it's been over {InactivityThresholds.WarningDays} days since your last post in '{user.Group?.Title ?? "the group"}'. Please participate soonif you remain inactive for {InactivityThresholds.RemovalDays} days, you will be automatically removed from the group.",
+                UserId = user.UserId,
+                RecipientType = TargetType.User.ToString(),
+                RecipientId = user.UserId,
+                MetadataJson = JsonSerializer.Serialize(metadata),
+                Read = false,
+                CreatedAt = now
+            };
+
+            await notifier.SendWarnNotification(notification, cancellationToken);
+
+            logger.LogInformation("Warning sent to user {UserId} in group {GroupId}", user.UserId, user.GroupId);
+
+            userIds.Add(user.UserId);
+        }
+
+        if (userIds.Any())
+            await userGroupRepository.MarkMultipleAsWarned(userIds, cancellationToken);
+
+        logger.LogInformation("Warning process completed for {Count} users", userIds.Count);
+
+        return ResultT<ResponseDto>.Success(new ResponseDto($"Warnings sent to {userIds.Count} users"));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Utilities/CodeGenerator.cs b/Rex.Application/Utilities/CodeGenerator.cs
new file mode 100644
index 0000000..9788053
--- /dev/null
+++ b/Rex.Application/Utilities/CodeGenerator.cs
@@ -0,0 +1,30 @@
+using System.Security.Cryptography;
+
+namespace Rex.Application.Utilities;
+
+/// <summary>
+/// Static class for generating secure numeric codes.
+/// </summary>
+public static class CodeGenerator
+{
+    /// <summary>
+    /// Generates a random numeric code with the specified number of digits.
+    /// </summary>
+    /// <param name="digits">The number of digits for the code (default is 6, valid range 1-9).</param>
+    /// <returns>A numeric code as a string.</returns>
+    /// <exception cref="ArgumentOutOfRangeException">
+    /// Thrown when digits is less than 1 or greater than 9.
+    /// </exception>
+    public static string GenerateCode(int digits = 6)
+    {
+        if (digits <= 0 || digits > 9)
+            throw new ArgumentOutOfRangeException(nameof(digits), "Digits must be between 1 and 9");
+
+        int min = (int)Math.Pow(10, digits - 1);
+        int max = (int)Math.Pow(10, digits);
+
+        int number = RandomNumberGenerator.GetInt32(min, max);
+
+        return number.ToString();
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Utilities/DistributedCache.cs b/Rex.Application/Utilities/DistributedCache.cs
new file mode 100644
index 0000000..0c8cdea
--- /dev/null
+++ b/Rex.Application/Utilities/DistributedCache.cs
@@ -0,0 +1,84 @@
+using System.Text.Json;
+using Microsoft.Extensions.Caching.Distributed;
+using Microsoft.Extensions.Logging;
+
+namespace Rex.Application.Utilities;
+
+public static class DistributedCache
+{
+    private static DistributedCacheEntryOptions CacheExpiration => new()
+    {
+        SlidingExpiration = TimeSpan.FromMinutes(1)
+    };
+
+    public static async Task<T> GetOrCreateAsync<T>(
+        this IDistributedCache cache,
+        string key,
+        Func<Task<T>> factory,
+        ILogger logger,
+        DistributedCacheEntryOptions options = null!,
+        CancellationToken cancellationToken = default
+    )
+    {
+        var cachedData = await cache.GetStringAsync(key, cancellationToken);
+
+        if (!string.IsNullOrEmpty(cachedData))
+        {
+            logger.LogInformation("Cache hit for key '{Key}'", key);
+            return JsonSerializer.Deserialize<T>(cachedData)!;
+        }
+
+        logger.LogInformation("Cache miss for key '{Key}', fetching data...", key);
+        var data = await factory();
+
+        await cache.SetStringAsync(
+            key,
+            JsonSerializer.Serialize(data),
+            options ?? CacheExpiration,
+            cancellationToken
+        );
+
+        logger.LogInformation("Data cached for key '{Key}'", key);
+
+        return data;
+    }
+
+    public static async Task<int> GetVersionAsync(
+        this IDistributedCache cache,
+        string resourceType,
+        Guid resourceId,
+        CancellationToken cancellationToken = default
+    )
+    {
+        var versionKey = $"cache-version:{resourceType}:{resourceId}";
+        var versionStr = await cache.GetStringAsync(versionKey, cancellationToken);
+
+        if (string.IsNullOrEmpty(versionStr))
+        {
+            await cache.SetStringAsync(versionKey, "1", CacheExpiration, cancellationToken);
+            return 1;
+        }
+
+        return int.Parse(versionStr);
+    }
+
+    public static async Task IncrementVersionAsync(
+        this IDistributedCache cache,
+        string resourceType,
+        Guid resourceId,
+        ILogger logger,
+        CancellationToken cancellationToken = default
+    )
+    {
+        var versionKey = $"cache-version:{resourceType}:{resourceId}";
+        var current = await cache.GetVersionAsync(resourceType, resourceId, cancellationToken);
+        var newVersion = current + 1;
+
+        await cache.SetStringAsync(versionKey, newVersion.ToString(), CacheExpiration, cancellationToken);
+
+        logger.LogInformation(
+            "Cache version incremented from {OldVersion} to {NewVersion} for {ResourceType}:{ResourceId}",
+            current, newVersion, resourceType, resourceId
+        );
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Utilities/EmailTemplate.cs b/Rex.Application/Utilities/EmailTemplate.cs
new file mode 100644
index 0000000..3aaa561
--- /dev/null
+++ b/Rex.Application/Utilities/EmailTemplate.cs
@@ -0,0 +1,556 @@
+namespace Rex.Application.Utilities;
+
+public static class EmailTemplate
+{
+    public static string ConfirmAccountTemplate(string firstName, string lastName, string code)
+    {
+        return $@"<!DOCTYPE html>
+		<html lang=""en"">
+
+		<head>
+			<meta charset=""UTF-8"">
+			<meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
+			<title>Confirm Your Rex Account</title>
+			<style>
+				body {{
+					margin: 0;
+					padding: 0;
+					font-family: Arial, Helvetica, sans-serif;
+					background-color: #f3f4f6;
+					color: #1f2937;
+					line-height: 1.6;
+				}}
+
+				.container {{
+					max-width: 600px;
+					margin: 40px auto;
+					background-color: #ffffff;
+					border-radius: 16px;
+					overflow: hidden;
+					box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
+				}}
+
+				.hero {{
+					background: linear-gradient(135deg, #EF4444 0%, #F97316 100%);
+					padding: 40px 20px;
+					color: white;
+					text-align: center;
+					border-bottom-left-radius: 16px;
+					border-bottom-right-radius: 16px;
+				}}
+
+				.hero-title {{
+					font-size: 30px;
+					font-weight: bold;
+					margin: 0 0 15px 0;
+				}}
+
+				.hero-subtitle {{
+					font-size: 18px;
+					margin: 0;
+					font-weight: 500;
+					opacity: 0.95;
+				}}
+
+				.content {{
+					padding: 30px;
+				}}
+
+				.text {{
+					font-size: 17px;
+					margin: 0 0 20px 0;
+					font-weight: 500;
+					color: #111827;
+				}}
+
+				.code-container {{
+					background-color: #f9fafb;
+					border-radius: 12px;
+					padding: 25px;
+					text-align: center;
+					margin: 25px 0;
+					border: 1px solid #e5e7eb;
+					box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
+				}}
+
+				.code {{
+					font-size: 34px;
+					font-weight: bold;
+					letter-spacing: 6px;
+					color: #EF4444;
+					margin: 15px 0;
+					padding: 12px 18px;
+					background-color: #ffffff;
+					border: 2px dashed #EF4444;
+					border-radius: 12px;
+					display: inline-block;
+				}}
+
+				.code-expiry {{
+					font-size: 14px;
+					color: #6b7280;
+					margin: 10px 0 0 0;
+					font-weight: 500;
+				}}
+
+				.features {{
+					background-color: #f9fafb;
+					border-radius: 12px;
+					padding: 20px;
+					margin-top: 30px;
+				}}
+
+				.feature {{
+					margin-bottom: 15px;
+					font-weight: 500;
+					display: flex;
+					align-items: center;
+				}}
+
+				.feature-icon {{
+					width: 24px;
+					height: 24px;
+					background-color: #EF4444;
+					border-radius: 50%;
+					display: inline-block;
+					text-align: center;
+					color: white;
+					line-height: 24px;
+					font-weight: bold;
+					margin-right: 10px;
+				}}
+
+				@media only screen and (max-width: 480px) {{
+					.container {{
+						width: 100% !important;
+						border-radius: 0;
+					}}
+
+					.hero-title {{
+						font-size: 22px;
+					}}
+
+					.code {{
+						font-size: 24px;
+						letter-spacing: 3px;
+						padding: 8px;
+					}}
+				}}
+			</style>
+		</head>
+
+		<body>
+			<center>
+				<table border=""0"" cellpadding=""0"" cellspacing=""0"" height=""100%"" width=""100%"">
+					<tr>
+						<td align=""center"" valign=""top"">
+							<table class=""container"" border=""0"" cellpadding=""0"" cellspacing=""0"" width=""100%"">
+								<tr>
+									<td class=""hero"">
+										<h1 class=""hero-title"">Confirm Your Rex Account</h1>
+										<p class=""hero-subtitle"">You're one step away from pushing your limits</p>
+									</td>
+								</tr>
+								<tr>
+									<td class=""content"">
+										<p class=""text"">Hello {firstName} {lastName},</p>
+										<p class=""text"">Thank you for registering with Rex. To complete your registration, please use the
+											following verification code:</p>
+										<div class=""code-container"">
+											<p style=""margin: 0 0 10px 0; color: #6b7280; font-weight: 500;"">Your confirmation code is:</p>
+											<div class=""code"">{code}</div>
+											<p class=""code-expiry"">This code will expire in 15 minutes for security reasons.</p>
+										</div>
+										<p class=""text"">If you didn't create a Rex account, please ignore this message.</p>
+										<div class=""features"">
+											<div class=""feature"">
+												<span class=""feature-icon""></span>
+												<span>Personalized challenges</span>
+											</div>
+											<div class=""feature"">
+												<span class=""feature-icon""></span>
+												<span>Supportive community</span>
+											</div>
+											<div class=""feature"">
+												<span class=""feature-icon""></span>
+												<span>Progress tracking</span>
+											</div>
+										</div>
+									</td>
+								</tr>
+							</table>
+						</td>
+					</tr>
+				</table>
+			</center>
+		</body>
+
+		</html>";
+    }
+
+    public static string ConfirmEmailChangeTemplate(string firstName, string email,
+        string newEmail, string code)
+    {
+        return $@"<!DOCTYPE html>
+	<html lang=""en"">
+
+	<head>
+	    <meta charset=""UTF-8"">
+	    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
+	    <title>Confirm Your Email Change - Rex</title>
+	    <style>
+	        body {{
+	            margin: 0;
+	            padding: 0;
+	            font-family: Arial, Helvetica, sans-serif;
+	            background-color: #f3f4f6;
+	            color: #1f2937;
+	            line-height: 1.6;
+	        }}
+
+	        .container {{
+	            max-width: 600px;
+	            margin: 40px auto;
+	            background-color: #ffffff;
+	            border-radius: 16px;
+	            overflow: hidden;
+	            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
+	        }}
+
+	        .hero {{
+	            background: linear-gradient(135deg, #EF4444 0%, #F97316 100%);
+	            padding: 40px 20px;
+	            color: white;
+	            text-align: center;
+	            border-bottom-left-radius: 16px;
+	            border-bottom-right-radius: 16px;
+	        }}
+
+	        .hero-title {{
+	            font-size: 30px;
+	            font-weight: bold;
+	            margin: 0 0 15px 0;
+	        }}
+
+	        .hero-subtitle {{
+	            font-size: 18px;
+	            margin: 0;
+	            font-weight: 500;
+	            opacity: 0.95;
+	        }}
+
+	        .content {{
+	            padding: 30px;
+	        }}
+
+	        .text {{
+	            font-size: 17px;
+	            margin: 0 0 20px 0;
+	            font-weight: 500;
+	            color: #111827;
+	        }}
+
+	        .highlight {{
+	            color: #EF4444;
+	            font-weight: bold;
+	        }}
+
+	        .code-container {{
+	            background-color: #f9fafb;
+	            border-radius: 12px;
+	            padding: 25px;
+	            text-align: center;
+	            margin: 25px 0;
+	            border: 1px solid #e5e7eb;
+	            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
+	        }}
+
+	        .code {{
+	            font-size: 34px;
+	            font-weight: bold;
+	            letter-spacing: 6px;
+	            color: #EF4444;
+	            margin: 15px 0;
+	            padding: 12px 18px;
+	            background-color: #ffffff;
+	            border: 2px dashed #EF4444;
+	            border-radius: 12px;
+	            display: inline-block;
+	        }}
+
+	        .code-expiry {{
+	            font-size: 14px;
+	            color: #6b7280;
+	            margin: 10px 0 0 0;
+	            font-weight: 500;
+	        }}
+
+	        .warning {{
+	            background-color: #FEF3C7;
+	            border-left: 4px solid #F59E0B;
+	            padding: 15px;
+	            margin: 20px 0;
+	            border-radius: 4px;
+	        }}
+
+	        .warning-text {{
+	            margin: 0;
+	            color: #92400E;
+	            font-weight: 500;
+	        }}
+
+	        .features {{
+	            background-color: #f9fafb;
+	            border-radius: 12px;
+	            padding: 20px;
+	            margin-top: 30px;
+	        }}
+
+	        .feature {{
+	            margin-bottom: 15px;
+	            font-weight: 500;
+	            display: flex;
+	            align-items: center;
+	        }}
+
+	        .feature-icon {{
+	            width: 24px;
+	            height: 24px;
+	            background-color: #EF4444;
+	            border-radius: 50%;
+	            display: inline-block;
+	            text-align: center;
+	            color: white;
+	            line-height: 24px;
+	            font-weight: bold;
+	            margin-right: 10px;
+	        }}
+
+	        @media only screen and (max-width: 480px) {{
+	            .container {{
+	                width: 100% !important;
+	                border-radius: 0;
+	            }}
+
+	            .hero-title {{
+	                font-size: 22px;
+	            }}
+
+	            .code {{
+	                font-size: 24px;
+	                letter-spacing: 3px;
+	                padding: 8px;
+	            }}
+	        }}
+	    </style>
+	</head>
+
+	<body>
+	    <center>
+	        <table border=""0"" cellpadding=""0"" cellspacing=""0"" height=""100%"" width=""100%"">
+	            <tr>
+	                <td align=""center"" valign=""top"">
+	                    <table class=""container"" border=""0"" cellpadding=""0"" cellspacing=""0"" width=""100%"">
+	                        <tr>
+	                            <td class=""hero"">
+	                                <h1 class=""hero-title"">Confirm Your Email Change</h1>
+	                                <p class=""hero-subtitle"">Security verification for your Rex account</p>
+	                            </td>
+	                        </tr>
+	                        <tr>
+	                            <td class=""content"">
+	                                <p class=""text"">Hello {firstName},</p>
+	                                <p class=""text"">You have requested to change the email address associated with your Rex account from <span class=""highlight"">{email}</span> to <span class=""highlight"">{newEmail}</span>.</p>
+	                                
+	                                <div class=""warning"">
+	                                    <p class=""warning-text""> For security reasons, we need to verify that you authorized this change. If you didn't request this change, please contact our support team immediately.</p>
+	                                </div>
+	                                
+	                                <p class=""text"">To complete the email change process, please use the following verification code:</p>
+	                                
+	                                <div class=""code-container"">
+	                                    <p style=""margin: 0 0 10px 0; color: #6b7280; font-weight: 500;"">Your confirmation code is:</p>
+	                                    <div class=""code"">{code}</div>
+	                                    <p class=""code-expiry"">This code will expire in 15 minutes for security reasons.</p>
+	                                </div>
+	                                
+	                                <p class=""text"">Enter this code in the application to complete the email change process.</p>
+	                                
+	                                <div class=""features"">
+	                                    <div class=""feature"">
+	                                        <span class=""feature-icon""></span>
+	                                        <span>Personalized challenges</span>
+	                                    </div>
+	                                    <div class=""feature"">
+	                                        <span class=""feature-icon""></span>
+	                                        <span>Supportive community</span>
+	                                    </div>
+	                                    <div class=""feature"">
+	                                        <span class=""feature-icon""></span>
+	                                        <span>Progress tracking</span>
+	                                    </div>
+	                                </div>
+	                                
+	                                <p class=""text"">Best regards,<br>The Rex Team</p>
+	                            </td>
+	                        </tr>
+	                    </table>
+	                </td>
+	            </tr>
+	        </table>
+	    </center>
+	</body>
+
+	</html>";
+    }
+
+    public static string ConfirmForgotPasswordTemplate(string firstName, string lastName, string code)
+    {
+        return $@"<!DOCTYPE html>
+	<html lang=""en"">
+
+	<head>
+	    <meta charset=""UTF-8"">
+	    <meta name=""viewport"" content=""width=device-width, initial-scale=1.0"">
+	    <title>Reset Your Rex Password</title>
+	    <style>
+	        body {{
+	            margin: 0;
+	            padding: 0;
+	            font-family: Arial, Helvetica, sans-serif;
+	            background-color: #f3f4f6;
+	            color: #1f2937;
+	            line-height: 1.6;
+	        }}
+
+	        .container {{
+	            max-width: 600px;
+	            margin: 40px auto;
+	            background-color: #ffffff;
+	            border-radius: 16px;
+	            overflow: hidden;
+	            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.08);
+	        }}
+
+	        .hero {{
+	            background: linear-gradient(135deg, #EF4444 0%, #F97316 100%);
+	            padding: 40px 20px;
+	            color: white;
+	            text-align: center;
+	            border-bottom-left-radius: 16px;
+	            border-bottom-right-radius: 16px;
+	        }}
+
+	        .hero-title {{
+	            font-size: 30px;
+	            font-weight: bold;
+	            margin: 0 0 15px 0;
+	        }}
+
+	        .hero-subtitle {{
+	            font-size: 18px;
+	            margin: 0;
+	            font-weight: 500;
+	            opacity: 0.95;
+	        }}
+
+	        .content {{
+	            padding: 30px;
+	        }}
+
+	        .text {{
+	            font-size: 17px;
+	            margin: 0 0 20px 0;
+	            font-weight: 500;
+	            color: #111827;
+	        }}
+
+	        .code-container {{
+	            background-color: #f9fafb;
+	            border-radius: 12px;
+	            padding: 25px;
+	            text-align: center;
+	            margin: 25px 0;
+	            border: 1px solid #e5e7eb;
+	            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
+	        }}
+
+	        .code {{
+	            font-size: 34px;
+	            font-weight: bold;
+	            letter-spacing: 6px;
+	            color: #EF4444;
+	            margin: 15px 0;
+	            padding: 12px 18px;
+	            background-color: #ffffff;
+	            border: 2px dashed #EF4444;
+	            border-radius: 12px;
+	            display: inline-block;
+	        }}
+
+	        .code-expiry {{
+	            font-size: 14px;
+	            color: #6b7280;
+	            margin: 10px 0 0 0;
+	            font-weight: 500;
+	        }}
+
+	        @media only screen and (max-width: 480px) {{
+	            .container {{
+	                width: 100% !important;
+	                border-radius: 0;
+	            }}
+
+	            .hero-title {{
+	                font-size: 22px;
+	            }}
+
+	            .code {{
+	                font-size: 24px;
+	                letter-spacing: 3px;
+	                padding: 8px;
+	            }}
+	        }}
+	    </style>
+	</head>
+
+	<body>
+	    <center>
+	        <table border=""0"" cellpadding=""0"" cellspacing=""0"" height=""100%"" width=""100%"">
+	            <tr>
+	                <td align=""center"" valign=""top"">
+	                    <table class=""container"" border=""0"" cellpadding=""0"" cellspacing=""0"" width=""100%"">
+	                        <tr>
+	                            <td class=""hero"">
+	                                <h1 class=""hero-title"">Reset Your Password</h1>
+	                                <p class=""hero-subtitle"">Securely recover access to your Rex account</p>
+	                            </td>
+	                        </tr>
+	                        <tr>
+	                            <td class=""content"">
+	                                <p class=""text"">Hello {firstName} {lastName},</p>
+	                                <p class=""text"">We received a request to reset the password for your Rex account. 
+	                                Use the following verification code to continue with the reset process:</p>
+
+	                                <div class=""code-container"">
+	                                    <p style=""margin: 0 0 10px 0; color: #6b7280; font-weight: 500;"">Your reset code is:</p>
+	                                    <div class=""code"">{code}</div>
+	                                    <p class=""code-expiry"">This code will expire in 15 minutes for security reasons.</p>
+	                                </div>
+
+	                                <p class=""text"">If you didn't request a password reset, please ignore this email. 
+	                                Your account will remain safe and unchanged.</p>
+
+	                                <p class=""text"">Best regards,<br>The Rex Team</p>
+	                            </td>
+	                        </tr>
+	                    </table>
+	                </td>
+	            </tr>
+	        </table>
+	    </center>
+	</body>
+
+	</html>";
+    }
+}
\ No newline at end of file
diff --git a/Rex.Application/Utilities/Error.cs b/Rex.Application/Utilities/Error.cs
new file mode 100644
index 0000000..244d81d
--- /dev/null
+++ b/Rex.Application/Utilities/Error.cs
@@ -0,0 +1,76 @@
+using Rex.Enum;
+
+namespace Rex.Application.Utilities;
+
+/// <summary>
+/// Represents an error that occurred during an operation, including a code, description, and type.
+/// </summary>
+public class Error
+{
+    /// <summary>
+    /// Initializes a new instance of the <see cref="Error"/> class with the specified code, description, and error type.
+    /// </summary>
+    /// <param name="code">A unique identifier for the error.</param>
+    /// <param name="description">A human-readable description of the error.</param>
+    /// <param name="errorType">The type or category of the error.</param>
+    private Error(
+        string code, 
+        string description, 
+        ErrorType errorType)
+    {
+        Code = code;
+        Description = description;
+        ErrorType = errorType;
+    }
+
+    /// <summary>
+    /// Gets the unique code that identifies the error.
+    /// </summary>
+    public string Code { get; }
+
+    /// <summary>
+    /// Gets the description of the error.
+    /// </summary>
+    public string Description { get; }
+
+    /// <summary>
+    /// Gets the type or category of the error.
+    /// </summary>
+    public ErrorType ErrorType { get; }
+
+    /// <summary>
+    /// Creates a generic failure error.
+    /// </summary>
+    /// <param name="code">The code that identifies the error.</param>
+    /// <param name="description">A description of the failure.</param>
+    /// <returns>An instance of <see cref="Error"/> representing a failure.</returns>
+    public static Error Failure(string code, string description) => 
+        new Error(code, description, ErrorType.Failure);
+
+    /// <summary>
+    /// Creates a not found error.
+    /// </summary>
+    /// <param name="code">The code that identifies the error.</param>
+    /// <param name="description">A description indicating what was not found.</param>
+    /// <returns>An instance of <see cref="Error"/> representing a not found error.</returns>
+    public static Error NotFound(string code, string description) =>
+        new Error(code, description, ErrorType.NotFound);
+    
+    /// <summary>
+    /// Creates a conflict error, typically used when a resource already exists or there is a data conflict.
+    /// </summary>
+    /// <param name="code">The code that identifies the conflict error.</param>
+    /// <param name="description">A description of the conflict.</param>
+    /// <returns>An instance of <see cref="Error"/> representing a conflict.</returns>
+    public static Error Conflict(string code, string description) =>
+        new Error(code, description, ErrorType.Conflict);
+
+    /// <summary>
+    /// Creates an unauthorized error.
+    /// </summary>
+    /// <param name="code">The code that identifies the unauthorized error.</param>
+    /// <param name="description">A description of the unauthorized access.</param>
+    /// <returns>An instance of <see cref="Error"/> representing an unauthorized error.</returns>
+    public static Error Unauthorized(string code, string description) =>
+        new Error(code, description, ErrorType.Unauthorized);
+}
diff --git a/Rex.Application/Utilities/Result.cs b/Rex.Application/Utilities/Result.cs
new file mode 100644
index 0000000..45a7a49
--- /dev/null
+++ b/Rex.Application/Utilities/Result.cs
@@ -0,0 +1,120 @@
+using System.Text.Json.Serialization;
+
+namespace Rex.Application.Utilities;
+
+/// <summary>
+/// Represents the result of an operation that can either succeed or fail.
+/// </summary>
+public class Result
+{
+    /// <summary>
+    /// Indicates whether the operation was successful.
+    /// </summary>
+    public bool IsSuccess { get; set; }
+
+    /// <summary>
+    /// Contains the error information if the operation failed. Ignored during JSON serialization if null.
+    /// </summary>
+    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
+    public Error? Error { get; set; }
+
+    /// <summary>
+    /// Initializes a successful result.
+    /// </summary>
+    protected Result()
+    {
+        IsSuccess = true;
+        Error = default;
+    }
+
+    /// <summary>
+    /// Initializes a failed result with the specified error.
+    /// </summary>
+    /// <param name="error">The error that caused the failure.</param>
+    protected Result(Error error)
+    {
+        IsSuccess = false;
+        Error = error;
+    }
+
+    /// <summary>
+    /// Allows implicit conversion from <see cref="Error"/> to <see cref="Result"/>.
+    /// </summary>
+    /// <param name="error">The error to convert.</param>
+    public static implicit operator Result(Error error) =>
+        new(error);
+
+    /// <summary>
+    /// Creates a successful result.
+    /// </summary>
+    public static Result Success() =>
+        new();
+
+    /// <summary>
+    /// Creates a failed result with the specified error.
+    /// </summary>
+    /// <param name="error">The error to include in the result.</param>
+    public static Result Failure(Error error) =>
+        new(error);
+}
+
+/// <summary>
+/// Represents the result of an operation that can either succeed with a value of type <typeparamref name="TValue"/> or fail with an error.
+/// </summary>
+/// <typeparam name="TValue">The type of value returned if the operation is successful.</typeparam>
+public class ResultT<TValue> : Result
+{
+    private readonly TValue? _value;
+
+    /// <summary>
+    /// Initializes a successful result containing a value.
+    /// </summary>
+    /// <param name="value">The value of the successful result.</param>
+    private ResultT(TValue value) : base()
+    {
+        _value = value;
+    }
+
+    /// <summary>
+    /// Initializes a failed result with the specified error.
+    /// </summary>
+    /// <param name="error">The error that caused the failure.</param>
+    private ResultT(Error error) : base(error)
+    {
+        _value = default;
+    }
+
+    /// <summary>
+    /// Gets the value of the result if successful. Throws <see cref="InvalidOperationException"/> if the result is a failure.
+    /// </summary>
+    public TValue Value =>
+        IsSuccess ? _value! : throw new InvalidOperationException("Cannot access Value when IsSuccess is false");
+
+    /// <summary>
+    /// Allows implicit conversion from <see cref="Error"/> to <see cref="ResultT{TValue}"/>.
+    /// </summary>
+    /// <param name="error">The error to convert.</param>
+    public static implicit operator ResultT<TValue>(Error error) =>
+        new(error);
+
+    /// <summary>
+    /// Allows implicit conversion from <typeparamref name="TValue"/> to <see cref="ResultT{TValue}"/>.
+    /// </summary>
+    /// <param name="value">The value to convert.</param>
+    public static implicit operator ResultT<TValue>(TValue value) =>
+        new(value);
+
+    /// <summary>
+    /// Creates a successful result containing a value.
+    /// </summary>
+    /// <param name="value">The value of the successful result.</param>
+    public static ResultT<TValue> Success(TValue value) =>
+        new(value);
+
+    /// <summary>
+    /// Creates a failed result with the specified error.
+    /// </summary>
+    /// <param name="error">The error to include in the result.</param>
+    public static ResultT<TValue> Failure(Error error) =>
+        new(error);
+}
diff --git a/Rex.Domain/Configurations/CloudinaryConfiguration.cs b/Rex.Domain/Configurations/CloudinaryConfiguration.cs
new file mode 100644
index 0000000..393906b
--- /dev/null
+++ b/Rex.Domain/Configurations/CloudinaryConfiguration.cs
@@ -0,0 +1,6 @@
+namespace Rex.Configurations;
+
+public class CloudinaryConfiguration
+{
+    public string? CloudinaryUrl { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Configurations/EmailConfiguration.cs b/Rex.Domain/Configurations/EmailConfiguration.cs
new file mode 100644
index 0000000..60205d1
--- /dev/null
+++ b/Rex.Domain/Configurations/EmailConfiguration.cs
@@ -0,0 +1,15 @@
+namespace Rex.Configurations;
+
+public class EmailConfiguration
+{
+    public string? EmailFrom { get; set;}
+    
+    public string? SmtpHost { get; set;}
+    
+    public int SmtpPort { get; set;}
+    
+    public string? SmtpUser { get; set;}
+    
+    public string? SmtpPass { get; set;}
+    
+}
\ No newline at end of file
diff --git a/Rex.Domain/Configurations/GithubConfiguration.cs b/Rex.Domain/Configurations/GithubConfiguration.cs
new file mode 100644
index 0000000..a43d3ec
--- /dev/null
+++ b/Rex.Domain/Configurations/GithubConfiguration.cs
@@ -0,0 +1,7 @@
+namespace Rex.Configurations;
+
+public class GithubConfiguration
+{
+    public string? ClientId { get; set; }
+    public string? ClientSecret { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Configurations/JWTConfiguration.cs b/Rex.Domain/Configurations/JWTConfiguration.cs
new file mode 100644
index 0000000..0842d11
--- /dev/null
+++ b/Rex.Domain/Configurations/JWTConfiguration.cs
@@ -0,0 +1,10 @@
+namespace Rex.Configurations;
+
+public class JWTConfiguration
+{
+    public string? Key { get; set; }
+    public string? Issuer { get; set; }       
+    public string? Audience { get; set; }    
+    public int DurationInMinutes { get; set; }
+
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/ChallengeStatus.cs b/Rex.Domain/Enum/ChallengeStatus.cs
new file mode 100644
index 0000000..aa221ea
--- /dev/null
+++ b/Rex.Domain/Enum/ChallengeStatus.cs
@@ -0,0 +1,7 @@
+namespace Rex.Enum;
+
+public enum ChallengeStatus
+{
+    Active,
+    Ended
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/ChatType.cs b/Rex.Domain/Enum/ChatType.cs
new file mode 100644
index 0000000..af157fd
--- /dev/null
+++ b/Rex.Domain/Enum/ChatType.cs
@@ -0,0 +1,7 @@
+namespace Rex.Enum;
+
+public enum ChatType
+{
+    Private,
+    Group
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/CodeType.cs b/Rex.Domain/Enum/CodeType.cs
new file mode 100644
index 0000000..962ec8a
--- /dev/null
+++ b/Rex.Domain/Enum/CodeType.cs
@@ -0,0 +1,8 @@
+namespace Rex.Enum;
+
+public enum CodeType
+{
+    ConfirmAccount,
+    ForgotPassword,
+    EmailConfirmation
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/ErrorType.cs b/Rex.Domain/Enum/ErrorType.cs
new file mode 100644
index 0000000..38e4af0
--- /dev/null
+++ b/Rex.Domain/Enum/ErrorType.cs
@@ -0,0 +1,10 @@
+namespace Rex.Enum;
+
+public enum ErrorType
+{
+    Failure,
+    NotFound,
+    Conflict,
+    Unauthorized
+
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/FileType.cs b/Rex.Domain/Enum/FileType.cs
new file mode 100644
index 0000000..cb20568
--- /dev/null
+++ b/Rex.Domain/Enum/FileType.cs
@@ -0,0 +1,8 @@
+namespace Rex.Enum;
+
+public enum FileType
+{
+    Image,
+    Video,
+    Archive
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/Gender.cs b/Rex.Domain/Enum/Gender.cs
new file mode 100644
index 0000000..bd60506
--- /dev/null
+++ b/Rex.Domain/Enum/Gender.cs
@@ -0,0 +1,8 @@
+namespace Rex.Enum;
+
+public enum Gender
+{
+    Masculine,
+    Feminine,
+    Other
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/GroupRole.cs b/Rex.Domain/Enum/GroupRole.cs
new file mode 100644
index 0000000..97e3134
--- /dev/null
+++ b/Rex.Domain/Enum/GroupRole.cs
@@ -0,0 +1,9 @@
+namespace Rex.Enum;
+
+public enum GroupRole
+{
+    Leader,
+    Mentor,
+    Moderator,
+    Member
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/GroupUserModerationStatus.cs b/Rex.Domain/Enum/GroupUserModerationStatus.cs
new file mode 100644
index 0000000..cb0d610
--- /dev/null
+++ b/Rex.Domain/Enum/GroupUserModerationStatus.cs
@@ -0,0 +1,7 @@
+namespace Rex.Enum;
+
+public enum GroupUserModerationStatus
+{
+    Removed,
+    Banned
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/GroupVisibility.cs b/Rex.Domain/Enum/GroupVisibility.cs
new file mode 100644
index 0000000..4f6a570
--- /dev/null
+++ b/Rex.Domain/Enum/GroupVisibility.cs
@@ -0,0 +1,7 @@
+namespace Rex.Enum;
+
+public enum GroupVisibility
+{
+    Public,
+    Private
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/ManageRequestStatus.cs b/Rex.Domain/Enum/ManageRequestStatus.cs
new file mode 100644
index 0000000..3907eca
--- /dev/null
+++ b/Rex.Domain/Enum/ManageRequestStatus.cs
@@ -0,0 +1,7 @@
+namespace Rex.Enum;
+
+public enum ManageRequestStatus
+{
+    Accepted,
+    Rejected,
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/ReactionTargetType.cs b/Rex.Domain/Enum/ReactionTargetType.cs
new file mode 100644
index 0000000..17734e1
--- /dev/null
+++ b/Rex.Domain/Enum/ReactionTargetType.cs
@@ -0,0 +1,7 @@
+namespace Rex.Enum;
+
+public enum ReactionTargetType
+{
+    Post,
+    Comment
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/RequestStatus.cs b/Rex.Domain/Enum/RequestStatus.cs
new file mode 100644
index 0000000..187b3b1
--- /dev/null
+++ b/Rex.Domain/Enum/RequestStatus.cs
@@ -0,0 +1,9 @@
+namespace Rex.Enum;
+
+public enum RequestStatus
+{
+    Accepted,
+    Pending,
+    Rejected,
+    Removed
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/TargetType.cs b/Rex.Domain/Enum/TargetType.cs
new file mode 100644
index 0000000..50ccdda
--- /dev/null
+++ b/Rex.Domain/Enum/TargetType.cs
@@ -0,0 +1,11 @@
+namespace Rex.Enum;
+
+public enum TargetType
+{
+    Post,
+    Comment,
+    Message,
+    Challenge,
+    Group,
+    User
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/UserChallengeStatus.cs b/Rex.Domain/Enum/UserChallengeStatus.cs
new file mode 100644
index 0000000..9bfb110
--- /dev/null
+++ b/Rex.Domain/Enum/UserChallengeStatus.cs
@@ -0,0 +1,7 @@
+namespace Rex.Enum;
+
+public enum UserChallengeStatus
+{
+    Enrolled,
+    Completed
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/UserRole.cs b/Rex.Domain/Enum/UserRole.cs
new file mode 100644
index 0000000..19e1b0e
--- /dev/null
+++ b/Rex.Domain/Enum/UserRole.cs
@@ -0,0 +1,7 @@
+namespace Rex.Enum;
+
+public enum UserRole
+{
+    User,
+    Admin
+}
\ No newline at end of file
diff --git a/Rex.Domain/Enum/UserStatus.cs b/Rex.Domain/Enum/UserStatus.cs
new file mode 100644
index 0000000..a9514ec
--- /dev/null
+++ b/Rex.Domain/Enum/UserStatus.cs
@@ -0,0 +1,7 @@
+namespace Rex.Enum;
+
+public enum UserStatus
+{
+    Active,
+    Banned
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/AuditableEntity.cs b/Rex.Domain/Models/AuditableEntity.cs
new file mode 100644
index 0000000..b8bdcd9
--- /dev/null
+++ b/Rex.Domain/Models/AuditableEntity.cs
@@ -0,0 +1,9 @@
+namespace Rex.Models;
+
+public class AuditableEntity : EntityBase
+{
+    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
+    public DateTime? UpdatedAt { get; set; }
+    public bool Deleted { get; set; } = false;
+    public DateTime? DeletedAt { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/Challenge.cs b/Rex.Domain/Models/Challenge.cs
new file mode 100644
index 0000000..e35aa7d
--- /dev/null
+++ b/Rex.Domain/Models/Challenge.cs
@@ -0,0 +1,18 @@
+namespace Rex.Models;
+
+public sealed class Challenge: AuditableEntity
+{
+    public string Title { get; set; }
+    public string Description { get; set; }
+    public Guid CreatorId { get; set; }
+    public Guid GroupId { get; set; }
+    public TimeSpan Duration { get; set; }
+    public string Status { get; set; }
+    public string CoverPhoto { get; set; }
+    
+    public ICollection<Post> Posts { get; set; }
+    public ICollection<UserChallenge>? UserChallenges { get; set; }
+    public Group Group { get; set; }
+    public User Creator { get; set; }
+
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/Chat.cs b/Rex.Domain/Models/Chat.cs
new file mode 100644
index 0000000..1b100d8
--- /dev/null
+++ b/Rex.Domain/Models/Chat.cs
@@ -0,0 +1,11 @@
+
+namespace Rex.Models;
+
+public sealed class Chat: AuditableEntity
+{
+    public string Type { get; set; }
+    public string? Name { get; set; }
+    public string? GroupPhoto { get; set; } 
+    public ICollection<UserChat> UserChats { get; set; }
+    public ICollection<Message> Messages { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/Code.cs b/Rex.Domain/Models/Code.cs
new file mode 100644
index 0000000..7386759
--- /dev/null
+++ b/Rex.Domain/Models/Code.cs
@@ -0,0 +1,15 @@
+using Rex.Enum;
+
+namespace Rex.Models;
+
+public sealed class Code: AuditableEntity
+{
+    public Guid UserId { get; set; }
+    public string Value { get; set; }
+    public DateTime Expiration { get; set; }
+    public string Type { get; set; }
+    public bool Revoked { get; set; } = false;
+    public bool Used { get; set; } = false;
+    
+    public User User { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/Comment.cs b/Rex.Domain/Models/Comment.cs
new file mode 100644
index 0000000..4ec6813
--- /dev/null
+++ b/Rex.Domain/Models/Comment.cs
@@ -0,0 +1,17 @@
+namespace Rex.Models;
+
+public sealed class Comment: AuditableEntity
+{
+    public string Description { get; set; }
+    public Guid PostId { get; set; }
+    public Guid UserId { get; set; }
+    public bool IsPinned { get; set; } = false;
+    public Guid? ParentCommentId { get; set; }
+    public bool Edited { get; set; } = false;
+    
+    public ICollection<Comment>? Replies { get; set; }
+    public User? User { get; set; }
+    public Comment? ParentComment { get; set; }
+    public Post Post { get; set; }
+
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/EntityBase.cs b/Rex.Domain/Models/EntityBase.cs
new file mode 100644
index 0000000..8f10768
--- /dev/null
+++ b/Rex.Domain/Models/EntityBase.cs
@@ -0,0 +1,6 @@
+namespace Rex.Models;
+
+public class EntityBase
+{
+    public Guid Id { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/EntityFile.cs b/Rex.Domain/Models/EntityFile.cs
new file mode 100644
index 0000000..4b9d77e
--- /dev/null
+++ b/Rex.Domain/Models/EntityFile.cs
@@ -0,0 +1,12 @@
+using Rex.Enum;
+
+namespace Rex.Models;
+
+public sealed class EntityFile: AuditableEntity
+{
+    public Guid FileId { get; set; }
+    public Guid TargetId { get; set; }
+    public string TargetType { get; set; }
+    
+    public File File { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/File.cs b/Rex.Domain/Models/File.cs
new file mode 100644
index 0000000..02be667
--- /dev/null
+++ b/Rex.Domain/Models/File.cs
@@ -0,0 +1,12 @@
+using Rex.Enum;
+
+namespace Rex.Models;
+
+public sealed class File: AuditableEntity
+{
+    public string Url { get; set; }
+    public string Type { get; set; }
+    public DateTime UploadedAt { get; set; }
+    
+    public ICollection<EntityFile>? EntityFiles { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/FriendShip.cs b/Rex.Domain/Models/FriendShip.cs
new file mode 100644
index 0000000..dee7b97
--- /dev/null
+++ b/Rex.Domain/Models/FriendShip.cs
@@ -0,0 +1,12 @@
+
+namespace Rex.Models;
+
+public sealed class FriendShip: AuditableEntity
+{
+    public Guid TargetUserId { get; set; }
+    public Guid RequesterId { get; set; }
+    public string Status { get; set; }
+    
+    public User Requester { get; set; }
+    public User TargetUser { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/Group.cs b/Rex.Domain/Models/Group.cs
new file mode 100644
index 0000000..29bcd34
--- /dev/null
+++ b/Rex.Domain/Models/Group.cs
@@ -0,0 +1,15 @@
+using Rex.Enum;
+
+namespace Rex.Models;
+
+public sealed class Group: AuditableEntity
+{
+    public string Title { get; set; }
+    public string Description { get; set; }
+    public string Visibility { get; set; }
+    public string ProfilePhoto { get; set; }
+    public string? CoverPhoto { get; set; }
+    public ICollection<Post>? Posts { get; set; }
+    public ICollection<UserGroup> UserGroups { get; set; }
+    public ICollection<Challenge>? Challenges { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/GroupRole.cs b/Rex.Domain/Models/GroupRole.cs
new file mode 100644
index 0000000..406dd7c
--- /dev/null
+++ b/Rex.Domain/Models/GroupRole.cs
@@ -0,0 +1,9 @@
+using Rex.Enum;
+
+namespace Rex.Models;
+
+public sealed class GroupRole: AuditableEntity
+{
+    public string Role { get; set; }
+    public ICollection<UserGroup> UserGroups { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/Message.cs b/Rex.Domain/Models/Message.cs
new file mode 100644
index 0000000..0a9be66
--- /dev/null
+++ b/Rex.Domain/Models/Message.cs
@@ -0,0 +1,11 @@
+namespace Rex.Models;
+
+public sealed class Message: AuditableEntity
+{
+    public string Description { get; set; }
+    public Guid ChatId { get; set; }
+    public Guid SenderId { get; set; }
+    public Chat Chat { get; set; }
+    public User Sender { get; set; }
+
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/Notification.cs b/Rex.Domain/Models/Notification.cs
new file mode 100644
index 0000000..cc5005d
--- /dev/null
+++ b/Rex.Domain/Models/Notification.cs
@@ -0,0 +1,15 @@
+namespace Rex.Models;
+
+public sealed class Notification: AuditableEntity
+{
+    public string Title { get; set; }
+    public string Description { get; set; }
+    public Guid UserId { get; set; }
+    public bool Read { get; set; } = false;
+
+    public string RecipientType { get; set; }
+    public Guid RecipientId { get; set; }
+    public string MetadataJson { get; set; }
+
+    public User User { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/Post.cs b/Rex.Domain/Models/Post.cs
new file mode 100644
index 0000000..80cfc05
--- /dev/null
+++ b/Rex.Domain/Models/Post.cs
@@ -0,0 +1,15 @@
+namespace Rex.Models;
+
+public sealed class Post: AuditableEntity
+{
+    public string Title { get; set; }
+    public string? Description { get; set; }
+    public Guid UserId { get; set; }
+    public Guid GroupId { get; set; }
+    public Guid? ChallengeId { get; set; }
+    
+    public User User { get; set; }
+    public Group Group { get; set; }
+    public Challenge Challenge { get; set; }
+    public ICollection<Comment>? Comments { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/Reaction.cs b/Rex.Domain/Models/Reaction.cs
new file mode 100644
index 0000000..f2798f0
--- /dev/null
+++ b/Rex.Domain/Models/Reaction.cs
@@ -0,0 +1,13 @@
+
+namespace Rex.Models;
+
+public sealed class Reaction: AuditableEntity
+{
+    public Guid UserId { get; set; }
+    public Guid TargetId { get; set; }
+    public bool Like { get; set; }
+
+    public string TargetType { get; set; }
+    public User User { get; set; }
+
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/RefreshToken.cs b/Rex.Domain/Models/RefreshToken.cs
new file mode 100644
index 0000000..44774f6
--- /dev/null
+++ b/Rex.Domain/Models/RefreshToken.cs
@@ -0,0 +1,12 @@
+namespace Rex.Models;
+
+public sealed class RefreshToken: AuditableEntity
+{
+    public Guid UserId { get; set; }
+    public string Value { get; set; }
+    public bool Used { get; set; } = false;
+    public DateTime Expiration { get; set; }
+    public bool Revoked { get; set; } = false;
+    
+    public User User { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/User.cs b/Rex.Domain/Models/User.cs
new file mode 100644
index 0000000..2f4a540
--- /dev/null
+++ b/Rex.Domain/Models/User.cs
@@ -0,0 +1,37 @@
+using Rex.Enum;
+
+namespace Rex.Models;
+
+public sealed class User : AuditableEntity
+{
+    public string FirstName { get; set; } = string.Empty;
+    public string LastName { get; set; } = string.Empty;
+    public string UserName { get; set; } = string.Empty;
+    public string Email { get; set; } = string.Empty;
+    public string? Password { get; set; }
+    public string? ProfilePhoto { get; set; }
+    public string? CoverPhoto { get; set; }
+    public string? Biography { get; set; }
+    public string? Gender { get; set; }
+    public DateTime? Birthday { get; set; }
+    public DateTime? LastLoginAt { get; set; }
+    public bool ConfirmedAccount { get; set; } = false;
+    public string? Status { get; set; }
+    public DateTime? LastConnection { get; set; }
+    public bool IsActive { get; set; } = true;
+    public Guid? RoleId { get; set; }
+    public string? GitHubId { get; set; }
+    
+    public UserRole? Role { get; set; }
+    public ICollection<RefreshToken> RefreshTokens { get; set; } = new List<RefreshToken>();
+    public ICollection<Code> Codes { get; set; } = new List<Code>();
+    public ICollection<Post>? Posts { get; set; }
+    public ICollection<Comment>? Comments { get; set; }
+    public ICollection<Reaction>? Reactions { get; set; }
+    public ICollection<UserGroup>? UserGroups { get; set; }
+    public ICollection<UserChat>? UserChats { get; set; }
+    public ICollection<UserChallenge>? UserChallenges { get; set; }
+    public ICollection<Notification>? SentNotifications { get; set; }
+    public ICollection<FriendShip>? SentFriendRequests { get; set; }
+    public ICollection<FriendShip>? ReceivedFriendRequests { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/UserChallenge.cs b/Rex.Domain/Models/UserChallenge.cs
new file mode 100644
index 0000000..994e7d5
--- /dev/null
+++ b/Rex.Domain/Models/UserChallenge.cs
@@ -0,0 +1,13 @@
+
+namespace Rex.Models;
+
+public sealed class UserChallenge: AuditableEntity
+{
+    public Guid UserId { get; set; }
+    public Guid ChallengeId { get; set; }
+    public string Status { get; set; }
+    
+    public User User { get; set; }
+    public Challenge Challenge { get; set; }
+
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/UserChat.cs b/Rex.Domain/Models/UserChat.cs
new file mode 100644
index 0000000..0541bcd
--- /dev/null
+++ b/Rex.Domain/Models/UserChat.cs
@@ -0,0 +1,11 @@
+namespace Rex.Models;
+
+public sealed class UserChat: AuditableEntity
+{
+    public Guid ChatId { get; set; }
+    public Guid UserId { get; set; }
+    
+    public User User { get; set; }
+    public Chat Chat { get; set; }
+
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/UserGroup.cs b/Rex.Domain/Models/UserGroup.cs
new file mode 100644
index 0000000..bcb5cd4
--- /dev/null
+++ b/Rex.Domain/Models/UserGroup.cs
@@ -0,0 +1,15 @@
+namespace Rex.Models;
+
+public sealed class UserGroup: AuditableEntity
+{
+    public Guid UserId { get; set; }
+    public Guid GroupId { get; set; }
+    public Guid GroupRoleId { get; set; }
+    public string? Status { get; set; }
+    public DateTime? LastWarningAt { get; set; }
+    public bool HasBeenWarned { get; set; }
+    public DateTime RequestedAt { get; set; }
+    public User User { get; set; }
+    public Group Group { get; set; }
+    public GroupRole GroupRole { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Models/UserRole.cs b/Rex.Domain/Models/UserRole.cs
new file mode 100644
index 0000000..d61fb21
--- /dev/null
+++ b/Rex.Domain/Models/UserRole.cs
@@ -0,0 +1,8 @@
+
+namespace Rex.Models;
+
+public sealed class UserRole: AuditableEntity
+{
+    public string Role { get; set; }
+    public ICollection<User> Users { get; set; }
+}
\ No newline at end of file
diff --git a/Rex.Domain/Rex.Domain.csproj b/Rex.Domain/Rex.Domain.csproj
new file mode 100644
index 0000000..67d1d3e
--- /dev/null
+++ b/Rex.Domain/Rex.Domain.csproj
@@ -0,0 +1,10 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+    <PropertyGroup>
+        <TargetFramework>net8.0</TargetFramework>
+        <ImplicitUsings>enable</ImplicitUsings>
+        <Nullable>enable</Nullable>
+        <RootNamespace>Rex</RootNamespace>
+    </PropertyGroup>
+
+</Project>
diff --git a/Rex.Infrastructure.Persistence/Context/RexContext.cs b/Rex.Infrastructure.Persistence/Context/RexContext.cs
new file mode 100644
index 0000000..32a427d
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Context/RexContext.cs
@@ -0,0 +1,937 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Models;
+using File = Rex.Models.File;
+using GroupRole = Rex.Models.GroupRole;
+using UserRole = Rex.Models.UserRole;
+
+namespace Rex.Infrastructure.Persistence.Context;
+
+public class RexContext: DbContext
+{
+    public RexContext(DbContextOptions<RexContext> options) : base(options) {}
+
+    #region Models
+
+    public DbSet<User> User { get; set; }
+    public DbSet<RefreshToken> RefreshToken { get; set; }
+    public DbSet<FriendShip> FriendShip { get; set; }
+    public DbSet<Code> Code { get; set; }
+    public DbSet<UserRole> UserRole { get; set; }
+    public DbSet<GroupRole> GroupRole { get; set; }
+    public DbSet<UserGroup> UserGroup { get; set; }
+    public DbSet<Group> Group { get; set; }
+    public DbSet<Post> Post { get; set; }
+    public DbSet<EntityFile> EntityFile { get; set; }
+    public DbSet<File> File { get; set; }
+    public DbSet<Challenge> Challenge { get; set; }
+    public DbSet<Comment> Comment { get; set; }
+    public DbSet<Reaction> Reaction { get; set; }
+    public DbSet<Chat> Chat { get; set; }
+    public DbSet<UserChat> UserChat { get; set; }
+    public DbSet<Message> Message { get; set; }
+    public DbSet<Notification> Notification { get; set; }
+    
+    #endregion
+    
+    protected override void OnModelCreating(ModelBuilder modelBuilder)
+    {
+        base.OnModelCreating(modelBuilder);
+
+        #region Indexes
+        
+        modelBuilder.Entity<User>(entity =>
+        {
+            entity.HasIndex(u => u.Email)
+                .IsUnique()
+                .HasDatabaseName("UQ_User_Email");
+        });
+
+        modelBuilder.Entity<Post>(entity =>
+        {
+            entity.HasIndex(p => new { p.GroupId, p.CreatedAt })
+                .HasDatabaseName("IX_Post_GroupId_CreatedAt");
+        });
+
+        modelBuilder.Entity<Message>(entity =>
+        {
+            entity.HasIndex(m => new { m.ChatId, m.CreatedAt })
+                .HasDatabaseName("IX_Message_ChatId_CreatedAt");
+        });
+
+        modelBuilder.Entity<UserGroup>(entity =>
+        {
+            entity.HasIndex(ug => new { ug.UserId, ug.GroupId, ug.Status })
+                .HasDatabaseName("IX_UserGroup_UserId_GroupId_Status");
+        });
+
+        modelBuilder.Entity<Reaction>(entity =>
+        {
+            entity.HasIndex(r => new { r.TargetId, r.TargetType, r.Like })
+                .HasDatabaseName("IX_Reaction_TargetId_Type_Like")
+                .HasFilter("\"Like\" = true");
+        });
+
+        modelBuilder.Entity<FriendShip>(entity =>
+        {
+            entity.HasIndex(f => new { f.RequesterId, f.TargetUserId, f.Status })
+                .HasDatabaseName("IX_FriendShip_RequesterId_TargetUserId_Status");
+        });
+
+        modelBuilder.Entity<Code>(entity =>
+        {
+            entity.HasIndex(c => new { c.UserId, c.Type, c.Used, c.Revoked })
+                .HasDatabaseName("IX_Code_UserId_Type_Status");
+        });
+
+        #endregion
+
+        #region Tables
+
+        modelBuilder.Entity<User>()
+            .ToTable("User");
+
+        modelBuilder.Entity<RefreshToken>()
+            .ToTable("RefreshToken");
+
+        modelBuilder.Entity<FriendShip>()
+            .ToTable("FriendShip");
+
+        modelBuilder.Entity<Code>()
+            .ToTable("Code");
+
+        modelBuilder.Entity<UserRole>()
+            .ToTable("UserRole");
+
+        modelBuilder.Entity<GroupRole>()
+            .ToTable("GroupRole");
+
+        modelBuilder.Entity<UserGroup>()
+            .ToTable("UserGroup");
+
+        modelBuilder.Entity<Group>()
+            .ToTable("Group");
+
+        modelBuilder.Entity<Post>()
+            .ToTable("Post");
+
+        modelBuilder.Entity<EntityFile>()
+            .ToTable("EntityFile");
+
+        modelBuilder.Entity<File>()
+            .ToTable("File");
+
+        modelBuilder.Entity<Challenge>()
+            .ToTable("Challenge");
+
+        modelBuilder.Entity<Comment>()
+            .ToTable("Comment");
+
+        modelBuilder.Entity<Reaction>()
+            .ToTable("Reaction");
+
+        modelBuilder.Entity<Chat>()
+            .ToTable("Chat");
+
+        modelBuilder.Entity<UserChat>()
+            .ToTable("UserChat");
+
+        modelBuilder.Entity<Message>()
+            .ToTable("Message");
+
+        modelBuilder.Entity<Notification>()
+            .ToTable("Notification");
+
+        #endregion
+
+        #region Primary Key
+
+        modelBuilder.Entity<User>()
+            .HasKey(u => u.Id)
+            .HasName("PkUserId");
+
+        modelBuilder.Entity<Challenge>()
+            .HasKey(c => c.Id)
+            .HasName("PkChallengeId");
+
+        modelBuilder.Entity<Chat>()
+            .HasKey(c => c.Id)
+            .HasName("PkChatId");
+
+        modelBuilder.Entity<Code>()
+            .HasKey(c => c.Id)
+            .HasName("PkCodeId");
+
+        modelBuilder.Entity<Comment>()
+            .HasKey(c => c.Id)
+            .HasName("PkCommentId");
+
+        modelBuilder.Entity<EntityFile>()
+            .HasKey(c => c.Id)
+            .HasName("PkEntityFileId");
+
+        modelBuilder.Entity<File>()
+            .HasKey(c => c.Id)
+            .HasName("PkFileId");
+
+        modelBuilder.Entity<FriendShip>()
+            .HasKey(c => c.Id)
+            .HasName("PkFriendShipId");
+
+        modelBuilder.Entity<Group>()
+            .HasKey(c => c.Id)
+            .HasName("PkGroupId");
+
+        modelBuilder.Entity<GroupRole>()
+            .HasKey(c => c.Id)
+            .HasName("PkGroupRoleId");
+
+        modelBuilder.Entity<Message>()
+            .HasKey(c => c.Id)
+            .HasName("PkMessageId");
+
+        modelBuilder.Entity<Notification>()
+            .HasKey(c => c.Id)
+            .HasName("PkNotificationId");
+
+        modelBuilder.Entity<Post>()
+            .HasKey(c => c.Id)
+            .HasName("PkPostId");
+
+        modelBuilder.Entity<Reaction>()
+            .HasKey(c => c.Id)
+            .HasName("PkReactionId");
+
+        modelBuilder.Entity<RefreshToken>()
+            .HasKey(c => c.Id)
+            .HasName("PkRefreshTokenId");
+
+        modelBuilder.Entity<UserChat>()
+            .HasKey(c => c.Id)
+            .HasName("PkUserChatId");
+
+        modelBuilder.Entity<UserGroup>()
+            .HasKey(c => c.Id)
+            .HasName("PkUserGroupId");
+
+        modelBuilder.Entity<UserRole>()
+            .HasKey(c => c.Id)
+            .HasName("PkUserRoleId");
+
+        #endregion
+
+        #region Foreign Keys
+
+        modelBuilder.Entity<User>()
+            .Property(c => c.RoleId)
+            .HasColumnName("FkRoleId");
+
+        modelBuilder.Entity<Challenge>()
+            .Property(c => c.CreatorId)
+            .HasColumnName("FkCreatorId");
+
+        modelBuilder.Entity<Challenge>()
+            .Property(c => c.GroupId)
+            .HasColumnName("FkGroupId");
+
+        modelBuilder.Entity<Code>()
+            .Property(c => c.UserId)
+            .HasColumnName("FkUserId");
+
+        modelBuilder.Entity<Comment>()
+            .Property(c => c.UserId)
+            .HasColumnName("FkUserId");
+
+        modelBuilder.Entity<Comment>()
+            .Property(c => c.PostId)
+            .HasColumnName("FkPostId");
+
+        modelBuilder.Entity<EntityFile>()
+            .Property(c => c.FileId)
+            .HasColumnName("FkFileId");
+
+        modelBuilder.Entity<EntityFile>()
+            .Property(c => c.TargetId)
+            .HasColumnName("FkTargetId");
+
+        modelBuilder.Entity<FriendShip>()
+            .Property(c => c.TargetUserId)
+            .HasColumnName("FkTargetUserId");
+
+        modelBuilder.Entity<FriendShip>()
+            .Property(c => c.RequesterId)
+            .HasColumnName("FkRequesterId");
+
+        modelBuilder.Entity<Message>()
+            .Property(c => c.ChatId)
+            .HasColumnName("FkChatId");
+
+        modelBuilder.Entity<Message>()
+            .Property(c => c.SenderId)
+            .HasColumnName("FkSenderId");
+
+        modelBuilder.Entity<Notification>()
+            .Property(c => c.UserId)
+            .HasColumnName("FkUserId");
+
+        modelBuilder.Entity<Post>()
+            .Property(c => c.UserId)
+            .HasColumnName("FkUserId");
+
+        modelBuilder.Entity<Post>()
+            .Property(c => c.GroupId)
+            .HasColumnName("FkGroupId");
+
+        modelBuilder.Entity<Post>()
+            .Property(c => c.ChallengeId)
+            .HasColumnName("FkChallengeId");
+
+        modelBuilder.Entity<Reaction>()
+            .Property(c => c.UserId)
+            .HasColumnName("FkUserId");
+
+        modelBuilder.Entity<Reaction>()
+            .Property(c => c.TargetId)
+            .HasColumnName("FkTargetId");
+
+        modelBuilder.Entity<RefreshToken>()
+            .Property(c => c.UserId)
+            .HasColumnName("FkUserId");
+
+        modelBuilder.Entity<UserChat>()
+            .Property(c => c.ChatId)
+            .HasColumnName("FkChatId");
+
+        modelBuilder.Entity<UserChat>()
+            .Property(c => c.UserId)
+            .HasColumnName("FkUserId");
+
+        modelBuilder.Entity<UserGroup>()
+            .Property(c => c.UserId)
+            .HasColumnName("FkUserId");
+
+        modelBuilder.Entity<UserGroup>()
+            .Property(c => c.GroupId)
+            .HasColumnName("FkGroupId");
+
+        modelBuilder.Entity<UserGroup>()
+            .Property(c => c.GroupRoleId)
+            .HasColumnName("FkGroupRoleId");
+
+        #endregion
+
+        #region Relationships
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.RefreshTokens)
+            .WithOne(c => c.User)
+            .HasForeignKey(c => c.UserId)
+            .HasConstraintName("FkUserRefreshToken");
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.Codes)
+            .WithOne(c => c.User)
+            .HasForeignKey(c => c.UserId)
+            .HasConstraintName("FkUserCode");
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.Posts)
+            .WithOne(c => c.User)
+            .HasForeignKey(c => c.UserId)
+            .HasConstraintName("FkUserPost");
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.Comments)
+            .WithOne(c => c.User)
+            .HasForeignKey(c => c.UserId)
+            .HasConstraintName("FkUserComment");
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.Reactions)
+            .WithOne(c => c.User)
+            .HasForeignKey(c => c.UserId)
+            .HasConstraintName("FkUserReaction");
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.UserGroups)
+            .WithOne(c => c.User)
+            .HasForeignKey(c => c.UserId)
+            .HasConstraintName("FkUserGroup");
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.UserChats)
+            .WithOne(c => c.User)
+            .HasForeignKey(c => c.UserId)
+            .HasConstraintName("FkUserUserChat");
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.SentNotifications)
+            .WithOne(c => c.User)
+            .HasForeignKey(c => c.UserId)
+            .HasConstraintName("FkUserSentNotification");
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.SentFriendRequests)
+            .WithOne(c => c.Requester)
+            .HasForeignKey(c => c.RequesterId)
+            .HasConstraintName("FkUserSentFriendRequest");
+
+        modelBuilder.Entity<User>()
+            .HasMany(c => c.ReceivedFriendRequests)
+            .WithOne(c => c.TargetUser)
+            .HasForeignKey(c => c.TargetUserId)
+            .HasConstraintName("FkUserReceivedFriendRequest");
+
+        modelBuilder.Entity<Challenge>()
+            .HasMany(c => c.Posts)
+            .WithOne(c => c.Challenge)
+            .HasForeignKey(c => c.ChallengeId)
+            .HasConstraintName("FkChallengePost");
+
+        modelBuilder.Entity<Chat>()
+            .HasMany(c => c.UserChats)
+            .WithOne(c => c.Chat)
+            .HasForeignKey(c => c.ChatId)
+            .HasConstraintName("FkChatUserChat");
+
+        modelBuilder.Entity<Chat>()
+            .HasMany(c => c.Messages)
+            .WithOne(c => c.Chat)
+            .HasForeignKey(c => c.ChatId)
+            .HasConstraintName("FkChatMessage");
+
+        modelBuilder.Entity<Comment>()
+            .HasMany(c => c.Replies)
+            .WithOne(c => c.ParentComment)
+            .HasForeignKey(c => c.ParentCommentId)
+            .HasConstraintName("FkComment");
+
+        modelBuilder.Entity<File>()
+            .HasMany(c => c.EntityFiles)
+            .WithOne(c => c.File)
+            .HasForeignKey(c => c.FileId)
+            .HasConstraintName("FkFileEntityFile");
+
+        modelBuilder.Entity<Group>()
+            .HasMany(c => c.Posts)
+            .WithOne(c => c.Group)
+            .HasForeignKey(c => c.GroupId)
+            .HasConstraintName("FkGroupPost");
+
+        modelBuilder.Entity<Group>()
+            .HasMany(c => c.UserGroups)
+            .WithOne(c => c.Group)
+            .HasForeignKey(c => c.GroupId)
+            .HasConstraintName("FkGroupUserGroup");
+
+        modelBuilder.Entity<Group>()
+            .HasMany(c => c.Challenges)
+            .WithOne(c => c.Group)
+            .HasForeignKey(c => c.GroupId)
+            .HasConstraintName("FkGroupChallenge");
+
+        modelBuilder.Entity<GroupRole>()
+            .HasMany(c => c.UserGroups)
+            .WithOne(c => c.GroupRole)
+            .HasForeignKey(c => c.GroupRoleId)
+            .HasConstraintName("FkGroupRoleUserGroup");
+
+        modelBuilder.Entity<Post>()
+            .HasMany(c => c.Comments)
+            .WithOne(c => c.Post)
+            .HasForeignKey(c => c.PostId)
+            .HasConstraintName("FkPostComment");
+
+        modelBuilder.Entity<UserRole>()
+            .HasMany(c => c.Users)
+            .WithOne(c => c.Role)
+            .HasForeignKey(c => c.RoleId)
+            .HasConstraintName("FkUserRoleUser");
+
+        #endregion
+
+        #region User
+
+        modelBuilder.Entity<User>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkUserId")
+                .IsRequired();
+    
+            entity.Property(u => u.FirstName)
+                .IsRequired()
+                .HasMaxLength(100);
+
+            entity.Property(u => u.LastName)
+                .IsRequired()
+                .HasMaxLength(50);
+
+            entity.Property(u => u.UserName)
+                .IsRequired()
+                .HasMaxLength(50);
+
+            entity.Property(a => a.Email)
+                .IsRequired();
+
+            entity.Property(u => u.Password)
+                .IsRequired(false)
+                .HasMaxLength(255);
+
+            entity.Property(u => u.ProfilePhoto)
+                .IsRequired(false)
+                .HasMaxLength(255);
+
+            entity.Property(u => u.CoverPhoto)
+                .IsRequired(false)
+                .HasMaxLength(255);
+
+            entity.Property(u => u.Biography)
+                .IsRequired(false)
+                .HasColumnType("text");
+
+            entity.Property(u => u.ConfirmedAccount)
+                .HasDefaultValue(false);
+    
+            entity.Property(u => u.IsActive)
+                .HasDefaultValue(true);
+
+            entity.Property(u => u.Birthday)
+                .IsRequired(false)
+                .HasColumnType("date");
+
+            entity.Property(u => u.LastLoginAt)
+                .IsRequired(false)
+                .HasColumnType("timestamptz");
+    
+            entity.Property(u => u.LastConnection)
+                .IsRequired(false)
+                .HasColumnType("timestamptz");
+
+            entity.Property(u => u.Status)
+                .IsRequired(false)
+                .HasMaxLength(50);
+    
+            entity.Property(u => u.Gender)
+                .IsRequired(false)
+                .HasMaxLength(50);
+    
+            entity.Property(u => u.GitHubId)
+                .IsRequired(false)
+                .HasMaxLength(100);
+        });
+
+        #endregion
+
+        #region Post
+
+        modelBuilder.Entity<Post>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkPostId")
+                .IsRequired();
+            
+            entity.Property(p => p.Title)
+                .IsRequired()
+                .HasMaxLength(100);
+
+            entity.Property(p => p.Description)
+                .HasMaxLength(500);
+        });
+
+        #endregion
+
+        #region Comment
+
+        modelBuilder.Entity<Comment>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkCommentId")
+                .IsRequired();
+            
+            entity.Property(c => c.Description)
+                .IsRequired()
+                .HasMaxLength(500);
+
+            entity.Property(c => c.IsPinned)
+                .HasDefaultValue(false);
+
+            entity.Property(c => c.Edited)
+                .HasDefaultValue(false);
+        });
+
+        #endregion
+
+        #region File
+
+        modelBuilder.Entity<File>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkFileId")
+                .IsRequired();
+            
+            entity.Property(f => f.Url)
+                .IsRequired()
+                .HasMaxLength(255);
+
+            entity.Property(f => f.Type)
+                .IsRequired()
+                .HasMaxLength(30);
+            
+            entity.Property(u => u.UploadedAt)
+                .HasColumnType("timestamptz");
+
+        });
+
+        #endregion
+
+        #region EntityFile
+
+        modelBuilder.Entity<EntityFile>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkEntityFileId")
+                .IsRequired();
+
+            entity.Property(e => e.TargetType)
+                .IsRequired()
+                .HasMaxLength(50);
+        });
+
+        #endregion
+
+        #region Challenge
+
+        modelBuilder.Entity<Challenge>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkChallengeId")
+                .IsRequired();
+            
+            entity.Property(u => u.CoverPhoto)
+                .HasMaxLength(255);
+            
+            entity.Property(c => c.Title)
+                .IsRequired()
+                .HasMaxLength(100);
+
+            entity.Property(c => c.Description)
+                .HasMaxLength(500);
+
+            entity.Property(c => c.Duration)
+                .IsRequired();
+
+            entity.Property(c => c.Status)
+                .HasMaxLength(50);
+        });
+
+        #endregion
+
+        #region Chat
+
+        modelBuilder.Entity<Chat>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkChatId")
+                .IsRequired();
+
+            entity.Property(c => c.Type)
+                .IsRequired()
+                .HasMaxLength(30);
+            
+            entity.Property(a => a.Name)
+                .HasMaxLength(100);
+            
+            entity.Property(a => a.GroupPhoto)
+                .HasMaxLength(255);
+        });
+
+        #endregion
+
+        #region Code
+
+        modelBuilder.Entity<Code>(entity =>
+        {  
+            entity.Property(a => a.Id)
+                .HasColumnName("PkCodeId")
+                .IsRequired();
+            
+            entity.Property(c => c.Value)
+                .IsRequired()
+                .HasMaxLength(6);
+
+            entity.Property(c => c.Expiration)
+                .IsRequired();
+            
+            entity.Property(c => c.Type)
+                .IsRequired()
+                .HasMaxLength(30);
+            
+            entity.Property(c => c.Expiration)
+                .HasColumnType("timestamptz");
+
+            entity.Property(c => c.Revoked)
+                .HasDefaultValue(false);
+            
+            entity.Property(c => c.Used)
+                .HasDefaultValue(false);
+        });
+
+        #endregion
+
+        #region Notification
+
+        modelBuilder.Entity<Notification>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkNotificationId")
+                .IsRequired();
+
+            entity.Property(n => n.Title)
+                .IsRequired()
+                .HasMaxLength(125);
+
+            entity.Property(n => n.Description)
+                .HasMaxLength(255);
+
+            entity.Property(n => n.Read)
+                .HasDefaultValue(false);
+
+            entity.Property(n => n.RecipientType)
+                .HasMaxLength(50)
+                .IsRequired();
+
+            entity.Property(n => n.RecipientId)
+                .IsRequired();
+
+            entity.Property(n => n.MetadataJson)
+                .HasColumnType("jsonb"); 
+        });
+
+
+        #endregion
+
+        #region Reaction
+
+        modelBuilder.Entity<Reaction>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkReactionId")
+                .IsRequired();
+
+            entity.Property(r => r.TargetType)
+                .IsRequired()
+                .HasMaxLength(30);
+
+            entity.Property(a => a.Like)
+                .HasDefaultValue(false);
+        });
+
+        #endregion
+
+        #region RefreshToken
+
+        modelBuilder.Entity<RefreshToken>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkRefreshTokenId")
+                .IsRequired();
+            
+            entity.Property(r => r.Value)
+                .IsRequired()
+                .HasColumnType("text");
+
+            entity.Property(r => r.Used)
+                .HasDefaultValue(false);
+
+            entity.Property(r => r.Revoked)
+                .HasDefaultValue(false);
+            
+            entity.Property(r => r.Expiration)
+                .HasColumnType("timestamptz");
+            
+        });
+
+        #endregion
+
+        #region UserChat
+
+        modelBuilder.Entity<UserChat>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkUserChatId")
+                .IsRequired();
+            
+            entity.Property(uc => uc.ChatId)
+                .IsRequired();
+
+            entity.Property(uc => uc.UserId)
+                .IsRequired();
+        });
+
+        #endregion
+
+        #region UserGroup
+
+        modelBuilder.Entity<UserGroup>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkUserGroupId")
+                .IsRequired();
+            
+            entity.Property(ug => ug.UserId)
+                .IsRequired();
+
+            entity.Property(ug => ug.GroupId)
+                .IsRequired();
+
+            entity.Property(ug => ug.GroupRoleId)
+                .IsRequired();
+            
+            entity.Property(ug => ug.RequestedAt)
+                .HasColumnType("timestamptz");
+            
+            entity.Property(ug => ug.CreatedAt)
+                .HasColumnType("timestamptz");
+
+            entity.Property(ug => ug.Status)
+                .HasMaxLength(50);
+        });
+
+        #endregion
+
+        #region FriendShip
+
+        modelBuilder.Entity<FriendShip>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkFriendShipId")
+                .IsRequired();
+            
+            entity.Property(f => f.RequesterId)
+                .IsRequired();
+
+            entity.Property(f => f.TargetUserId)
+                .IsRequired();
+
+            entity.Property(f => f.Status)
+                .IsRequired()
+                .HasMaxLength(50);
+        });
+
+        #endregion
+
+        #region Group
+
+        modelBuilder.Entity<Group>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkGroupId")
+                .IsRequired();
+            
+            entity.Property(g => g.Title)
+                .IsRequired()
+                .HasMaxLength(100);
+
+            entity.Property(g => g.Description)
+                .HasMaxLength(500);
+
+            entity.Property(g => g.Visibility)
+                .IsRequired()
+                .HasMaxLength(30);
+            
+            entity.Property(u => u.ProfilePhoto)
+                .IsRequired()
+                .HasMaxLength(255);
+
+            entity.Property(u => u.CoverPhoto)
+                .HasMaxLength(255);
+        });
+
+        #endregion
+
+        #region GroupRole
+
+        modelBuilder.Entity<GroupRole>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkGroupRoleId")
+                .IsRequired();
+            
+            entity.Property(gr => gr.Role)
+                .IsRequired()
+                .HasMaxLength(50);
+        });
+
+        #endregion
+
+        #region UserRole
+
+        modelBuilder.Entity<UserRole>(entity =>
+        {
+            entity.Property(a => a.Id)
+                .HasColumnName("PkUserRoleId")
+                .IsRequired();
+            
+            entity.Property(ur => ur.Role)
+                .IsRequired()
+                .HasMaxLength(50);
+        });
+
+        #endregion
+
+        #region Query Filters
+
+        modelBuilder.Entity<Chat>()
+            .HasQueryFilter(c => !c.Deleted);
+
+        modelBuilder.Entity<Comment>()
+            .HasQueryFilter(c => !c.Deleted);
+        
+        modelBuilder.Entity<Message>()
+            .HasQueryFilter(m => !m.Deleted);
+        
+        modelBuilder.Entity<Post>()
+            .HasQueryFilter(p => !p.Deleted);
+        
+        modelBuilder.Entity<Reaction>()
+            .HasQueryFilter(r => !r.Deleted);
+        
+        modelBuilder.Entity<User>()
+            .HasQueryFilter(u => !u.Deleted);
+
+        modelBuilder.Entity<Group>()
+            .HasQueryFilter(g => !g.Deleted);
+        
+        modelBuilder.Entity<Challenge>()
+            .HasQueryFilter(c => !c.Deleted);
+        
+        modelBuilder.Entity<EntityFile>()
+            .HasQueryFilter(c => !c.Deleted);
+        
+        modelBuilder.Entity<FriendShip>()
+            .HasQueryFilter(f => !f.Deleted && !f.Requester.Deleted && !f.TargetUser.Deleted);
+        
+        modelBuilder.Entity<Notification>()
+            .HasQueryFilter(n => !n.Deleted && !n.User.Deleted);
+
+        modelBuilder.Entity<RefreshToken>()
+            .HasQueryFilter(r => !r.Deleted && !r.User.Deleted);
+
+        modelBuilder.Entity<UserGroup>()
+            .HasQueryFilter(ug => !ug.Deleted && !ug.User.Deleted);
+
+        modelBuilder.Entity<UserChallenge>()
+            .HasQueryFilter(uc => !uc.Deleted && !uc.Challenge.Deleted);
+
+        modelBuilder.Entity<UserChat>()
+            .HasQueryFilter(uc => !uc.Deleted && !uc.Chat.Deleted);
+        
+        modelBuilder.Entity<File>()
+            .HasQueryFilter(c => !c.Deleted);
+        
+        modelBuilder.Entity<EntityFile>()
+            .HasQueryFilter(c => !c.Deleted);
+
+        #endregion
+    }
+    
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/DependencyInjection.cs b/Rex.Infrastructure.Persistence/DependencyInjection.cs
new file mode 100644
index 0000000..5fa2115
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/DependencyInjection.cs
@@ -0,0 +1,65 @@
+using Microsoft.EntityFrameworkCore;
+using Microsoft.Extensions.Configuration;
+using Microsoft.Extensions.DependencyInjection;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Infrastructure.Persistence.Repository;
+using Rex.Infrastructure.Persistence.Services;
+
+namespace Rex.Infrastructure.Persistence;
+
+public static class DependencyInjection
+{
+    public static void AddPersistenceLayer(this IServiceCollection services, IConfiguration configuration)
+    {
+        #region Redis
+        
+        services.AddStackExchangeRedisCache(options =>
+        {
+            options.Configuration = configuration.GetConnectionString("Redis");
+        });
+        
+        #endregion
+        
+        #region DbContext
+
+        services.AddDbContext<RexContext>(postgres =>
+        {
+            postgres.UseNpgsql(configuration.GetConnectionString("RexBackend"), 
+                m => m.MigrationsAssembly("Rex.Infrastructure.Persistence"));
+        });
+
+        #endregion
+        
+        #region Repositories
+
+        services.AddTransient(typeof(IGenericRepository<>), typeof(GenericRepository<>));
+        services.AddTransient<IUserRepository, UserRepository>();
+        services.AddTransient<IUserRoleRepository, UserRoleRepository>();
+        services.AddTransient<IRefreshTokenRepository, RefreshTokenRepository>();
+        services.AddTransient<IChallengeRepository, ChallengeRepository>();
+        services.AddTransient<IChatRepository, ChatRepository>();
+        services.AddTransient<ICodeRepository, CodeRepository>();
+        services.AddTransient<ICommentRepository, CommentRepository>();
+        services.AddTransient<IEntityFileRepository, EntityFileRepository>();
+        services.AddTransient<IFileRepository, FileRepository>();
+        services.AddTransient<IFriendShipRepository, FrienshipRepository>();
+        services.AddTransient<IGroupRoleRepository, GroupRoleRepository>();
+        services.AddTransient<IMessageRepository, MessageRepository>();
+        services.AddTransient<INotificationRepository, NotificationRepository>();
+        services.AddTransient<IPostRepository, PostRepository>();
+        services.AddTransient<IReactionRepository, ReactionRepository>();
+        services.AddTransient<IUserChallengeRepository, UserChallengeRepository>();
+        services.AddTransient<IUserChatRepository, UserChatRepository>();
+        services.AddTransient<IUserGroupRepository, UserGroupRepository>();
+        services.AddTransient<IGroupRepository, GroupRepository>();
+
+        #endregion
+
+        #region Services
+
+        services.AddScoped<IUserRoleService, UserRoleService>();
+        #endregion
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Migrations/20251027052200_Initial.Designer.cs b/Rex.Infrastructure.Persistence/Migrations/20251027052200_Initial.Designer.cs
new file mode 100644
index 0000000..ef7fa3c
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Migrations/20251027052200_Initial.Designer.cs
@@ -0,0 +1,1280 @@
+// <auto-generated />
+using System;
+using Microsoft.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore.Infrastructure;
+using Microsoft.EntityFrameworkCore.Migrations;
+using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
+using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
+using Rex.Infrastructure.Persistence.Context;
+
+#nullable disable
+
+namespace Rex.Infrastructure.Persistence.Migrations
+{
+    [DbContext(typeof(RexContext))]
+    [Migration("20251027052200_Initial")]
+    partial class Initial
+    {
+        /// <inheritdoc />
+        protected override void BuildTargetModel(ModelBuilder modelBuilder)
+        {
+#pragma warning disable 612, 618
+            modelBuilder
+                .HasAnnotation("ProductVersion", "8.0.10")
+                .HasAnnotation("Relational:MaxIdentifierLength", 63);
+
+            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);
+
+            modelBuilder.Entity("Rex.Models.Challenge", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkChallengeId");
+
+                    b.Property<string>("CoverPhoto")
+                        .IsRequired()
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("CreatorId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkCreatorId");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasMaxLength(500)
+                        .HasColumnType("character varying(500)");
+
+                    b.Property<TimeSpan>("Duration")
+                        .HasColumnType("interval");
+
+                    b.Property<Guid>("GroupId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkGroupId");
+
+                    b.Property<string>("Status")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<string>("Title")
+                        .IsRequired()
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkChallengeId");
+
+                    b.HasIndex("CreatorId");
+
+                    b.HasIndex("GroupId");
+
+                    b.ToTable("Challenge", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Chat", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkChatId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("GroupPhoto")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<string>("Name")
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<string>("Type")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkChatId");
+
+                    b.ToTable("Chat", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Code", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkCodeId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime>("Expiration")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<bool>("Revoked")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<string>("Type")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Used")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.Property<string>("Value")
+                        .IsRequired()
+                        .HasMaxLength(6)
+                        .HasColumnType("character varying(6)");
+
+                    b.HasKey("Id")
+                        .HasName("PkCodeId");
+
+                    b.HasIndex("UserId", "Type", "Used", "Revoked")
+                        .HasDatabaseName("IX_Code_UserId_Type_Status");
+
+                    b.ToTable("Code", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Comment", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkCommentId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasMaxLength(500)
+                        .HasColumnType("character varying(500)");
+
+                    b.Property<bool>("Edited")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<bool>("IsPinned")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid?>("ParentCommentId")
+                        .HasColumnType("uuid");
+
+                    b.Property<Guid>("PostId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkPostId");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkCommentId");
+
+                    b.HasIndex("ParentCommentId");
+
+                    b.HasIndex("PostId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("Comment", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.EntityFile", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkEntityFileId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("FileId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkFileId");
+
+                    b.Property<Guid>("TargetId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkTargetId");
+
+                    b.Property<string>("TargetType")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkEntityFileId");
+
+                    b.HasIndex("FileId");
+
+                    b.ToTable("EntityFile", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.File", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkFileId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Type")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime>("UploadedAt")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<string>("Url")
+                        .IsRequired()
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.HasKey("Id")
+                        .HasName("PkFileId");
+
+                    b.ToTable("File", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.FriendShip", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkFriendShipId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("RequesterId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkRequesterId");
+
+                    b.Property<string>("Status")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<Guid>("TargetUserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkTargetUserId");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkFriendShipId");
+
+                    b.HasIndex("TargetUserId");
+
+                    b.HasIndex("RequesterId", "TargetUserId", "Status")
+                        .HasDatabaseName("IX_FriendShip_RequesterId_TargetUserId_Status");
+
+                    b.ToTable("FriendShip", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Group", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkGroupId");
+
+                    b.Property<string>("CoverPhoto")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasMaxLength(500)
+                        .HasColumnType("character varying(500)");
+
+                    b.Property<string>("ProfilePhoto")
+                        .IsRequired()
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<string>("Title")
+                        .IsRequired()
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Visibility")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.HasKey("Id")
+                        .HasName("PkGroupId");
+
+                    b.ToTable("Group", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.GroupRole", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkGroupRoleId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Role")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkGroupRoleId");
+
+                    b.ToTable("GroupRole", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Message", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid");
+
+                    b.Property<Guid>("ChatId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkChatId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasColumnType("text");
+
+                    b.Property<Guid>("SenderId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkSenderId");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkMessageId");
+
+                    b.HasIndex("SenderId");
+
+                    b.HasIndex("ChatId", "CreatedAt")
+                        .HasDatabaseName("IX_Message_ChatId_CreatedAt");
+
+                    b.ToTable("Message", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Notification", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkNotificationId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<string>("MetadataJson")
+                        .IsRequired()
+                        .HasColumnType("jsonb");
+
+                    b.Property<bool>("Read")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid>("RecipientId")
+                        .HasColumnType("uuid");
+
+                    b.Property<string>("RecipientType")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<string>("Title")
+                        .IsRequired()
+                        .HasMaxLength(125)
+                        .HasColumnType("character varying(125)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkNotificationId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("Notification", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Post", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkPostId");
+
+                    b.Property<Guid?>("ChallengeId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkChallengeId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .HasMaxLength(500)
+                        .HasColumnType("character varying(500)");
+
+                    b.Property<Guid>("GroupId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkGroupId");
+
+                    b.Property<string>("Title")
+                        .IsRequired()
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkPostId");
+
+                    b.HasIndex("ChallengeId");
+
+                    b.HasIndex("UserId");
+
+                    b.HasIndex("GroupId", "CreatedAt")
+                        .HasDatabaseName("IX_Post_GroupId_CreatedAt");
+
+                    b.ToTable("Post", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Reaction", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkReactionId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Like")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid>("TargetId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkTargetId");
+
+                    b.Property<string>("TargetType")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkReactionId");
+
+                    b.HasIndex("UserId");
+
+                    b.HasIndex("TargetId", "TargetType", "Like")
+                        .HasDatabaseName("IX_Reaction_TargetId_Type_Like")
+                        .HasFilter("\"Like\" = true");
+
+                    b.ToTable("Reaction", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.RefreshToken", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkRefreshTokenId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime>("Expiration")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<bool>("Revoked")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Used")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.Property<string>("Value")
+                        .IsRequired()
+                        .HasColumnType("text");
+
+                    b.HasKey("Id")
+                        .HasName("PkRefreshTokenId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("RefreshToken", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.User", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkUserId");
+
+                    b.Property<string>("Biography")
+                        .HasColumnType("text");
+
+                    b.Property<DateTime?>("Birthday")
+                        .HasColumnType("date");
+
+                    b.Property<bool>("ConfirmedAccount")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<string>("CoverPhoto")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Email")
+                        .IsRequired()
+                        .HasColumnType("text");
+
+                    b.Property<string>("FirstName")
+                        .IsRequired()
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<string>("Gender")
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<string>("GitHubId")
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<bool>("IsActive")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(true);
+
+                    b.Property<DateTime?>("LastConnection")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<DateTime?>("LastLoginAt")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<string>("LastName")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<string>("Password")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<string>("ProfilePhoto")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<Guid?>("RoleId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkRoleId");
+
+                    b.Property<string>("Status")
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("UserName")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.HasKey("Id")
+                        .HasName("PkUserId");
+
+                    b.HasIndex("Email")
+                        .IsUnique()
+                        .HasDatabaseName("UQ_User_Email");
+
+                    b.HasIndex("RoleId");
+
+                    b.ToTable("User", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.UserChallenge", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid");
+
+                    b.Property<Guid>("ChallengeId")
+                        .HasColumnType("uuid");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Status")
+                        .IsRequired()
+                        .HasColumnType("text");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("ChallengeId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("UserChallenge");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserChat", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkUserChatId");
+
+                    b.Property<Guid>("ChatId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkChatId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkUserChatId");
+
+                    b.HasIndex("ChatId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("UserChat", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.UserGroup", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkUserGroupId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("GroupId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkGroupId");
+
+                    b.Property<Guid>("GroupRoleId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkGroupRoleId");
+
+                    b.Property<bool>("HasBeenWarned")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("LastWarningAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime>("RequestedAt")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<string>("Status")
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkUserGroupId");
+
+                    b.HasIndex("GroupId");
+
+                    b.HasIndex("GroupRoleId");
+
+                    b.HasIndex("UserId", "GroupId", "Status")
+                        .HasDatabaseName("IX_UserGroup_UserId_GroupId_Status");
+
+                    b.ToTable("UserGroup", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.UserRole", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkUserRoleId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Role")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkUserRoleId");
+
+                    b.ToTable("UserRole", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Challenge", b =>
+                {
+                    b.HasOne("Rex.Models.User", "Creator")
+                        .WithMany()
+                        .HasForeignKey("CreatorId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired();
+
+                    b.HasOne("Rex.Models.Group", "Group")
+                        .WithMany("Challenges")
+                        .HasForeignKey("GroupId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkGroupChallenge");
+
+                    b.Navigation("Creator");
+
+                    b.Navigation("Group");
+                });
+
+            modelBuilder.Entity("Rex.Models.Code", b =>
+                {
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("Codes")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserCode");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.Comment", b =>
+                {
+                    b.HasOne("Rex.Models.Comment", "ParentComment")
+                        .WithMany("Replies")
+                        .HasForeignKey("ParentCommentId")
+                        .HasConstraintName("FkComment");
+
+                    b.HasOne("Rex.Models.Post", "Post")
+                        .WithMany("Comments")
+                        .HasForeignKey("PostId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkPostComment");
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("Comments")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserComment");
+
+                    b.Navigation("ParentComment");
+
+                    b.Navigation("Post");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.EntityFile", b =>
+                {
+                    b.HasOne("Rex.Models.File", "File")
+                        .WithMany("EntityFiles")
+                        .HasForeignKey("FileId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkFileEntityFile");
+
+                    b.Navigation("File");
+                });
+
+            modelBuilder.Entity("Rex.Models.FriendShip", b =>
+                {
+                    b.HasOne("Rex.Models.User", "Requester")
+                        .WithMany("SentFriendRequests")
+                        .HasForeignKey("RequesterId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserSentFriendRequest");
+
+                    b.HasOne("Rex.Models.User", "TargetUser")
+                        .WithMany("ReceivedFriendRequests")
+                        .HasForeignKey("TargetUserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserReceivedFriendRequest");
+
+                    b.Navigation("Requester");
+
+                    b.Navigation("TargetUser");
+                });
+
+            modelBuilder.Entity("Rex.Models.Message", b =>
+                {
+                    b.HasOne("Rex.Models.Chat", "Chat")
+                        .WithMany("Messages")
+                        .HasForeignKey("ChatId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkChatMessage");
+
+                    b.HasOne("Rex.Models.User", "Sender")
+                        .WithMany()
+                        .HasForeignKey("SenderId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired();
+
+                    b.Navigation("Chat");
+
+                    b.Navigation("Sender");
+                });
+
+            modelBuilder.Entity("Rex.Models.Notification", b =>
+                {
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("SentNotifications")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserSentNotification");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.Post", b =>
+                {
+                    b.HasOne("Rex.Models.Challenge", "Challenge")
+                        .WithMany("Posts")
+                        .HasForeignKey("ChallengeId")
+                        .HasConstraintName("FkChallengePost");
+
+                    b.HasOne("Rex.Models.Group", "Group")
+                        .WithMany("Posts")
+                        .HasForeignKey("GroupId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkGroupPost");
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("Posts")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserPost");
+
+                    b.Navigation("Challenge");
+
+                    b.Navigation("Group");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.Reaction", b =>
+                {
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("Reactions")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserReaction");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.RefreshToken", b =>
+                {
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("RefreshTokens")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserRefreshToken");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.User", b =>
+                {
+                    b.HasOne("Rex.Models.UserRole", "Role")
+                        .WithMany("Users")
+                        .HasForeignKey("RoleId")
+                        .HasConstraintName("FkUserRoleUser");
+
+                    b.Navigation("Role");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserChallenge", b =>
+                {
+                    b.HasOne("Rex.Models.Challenge", "Challenge")
+                        .WithMany("UserChallenges")
+                        .HasForeignKey("ChallengeId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired();
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("UserChallenges")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired();
+
+                    b.Navigation("Challenge");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserChat", b =>
+                {
+                    b.HasOne("Rex.Models.Chat", "Chat")
+                        .WithMany("UserChats")
+                        .HasForeignKey("ChatId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkChatUserChat");
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("UserChats")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserUserChat");
+
+                    b.Navigation("Chat");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserGroup", b =>
+                {
+                    b.HasOne("Rex.Models.Group", "Group")
+                        .WithMany("UserGroups")
+                        .HasForeignKey("GroupId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkGroupUserGroup");
+
+                    b.HasOne("Rex.Models.GroupRole", "GroupRole")
+                        .WithMany("UserGroups")
+                        .HasForeignKey("GroupRoleId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkGroupRoleUserGroup");
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("UserGroups")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserGroup");
+
+                    b.Navigation("Group");
+
+                    b.Navigation("GroupRole");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.Challenge", b =>
+                {
+                    b.Navigation("Posts");
+
+                    b.Navigation("UserChallenges");
+                });
+
+            modelBuilder.Entity("Rex.Models.Chat", b =>
+                {
+                    b.Navigation("Messages");
+
+                    b.Navigation("UserChats");
+                });
+
+            modelBuilder.Entity("Rex.Models.Comment", b =>
+                {
+                    b.Navigation("Replies");
+                });
+
+            modelBuilder.Entity("Rex.Models.File", b =>
+                {
+                    b.Navigation("EntityFiles");
+                });
+
+            modelBuilder.Entity("Rex.Models.Group", b =>
+                {
+                    b.Navigation("Challenges");
+
+                    b.Navigation("Posts");
+
+                    b.Navigation("UserGroups");
+                });
+
+            modelBuilder.Entity("Rex.Models.GroupRole", b =>
+                {
+                    b.Navigation("UserGroups");
+                });
+
+            modelBuilder.Entity("Rex.Models.Post", b =>
+                {
+                    b.Navigation("Comments");
+                });
+
+            modelBuilder.Entity("Rex.Models.User", b =>
+                {
+                    b.Navigation("Codes");
+
+                    b.Navigation("Comments");
+
+                    b.Navigation("Posts");
+
+                    b.Navigation("Reactions");
+
+                    b.Navigation("ReceivedFriendRequests");
+
+                    b.Navigation("RefreshTokens");
+
+                    b.Navigation("SentFriendRequests");
+
+                    b.Navigation("SentNotifications");
+
+                    b.Navigation("UserChallenges");
+
+                    b.Navigation("UserChats");
+
+                    b.Navigation("UserGroups");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserRole", b =>
+                {
+                    b.Navigation("Users");
+                });
+#pragma warning restore 612, 618
+        }
+    }
+}
diff --git a/Rex.Infrastructure.Persistence/Migrations/20251027052200_Initial.cs b/Rex.Infrastructure.Persistence/Migrations/20251027052200_Initial.cs
new file mode 100644
index 0000000..aa7269a
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Migrations/20251027052200_Initial.cs
@@ -0,0 +1,736 @@
+using System;
+using Microsoft.EntityFrameworkCore.Migrations;
+
+#nullable disable
+
+namespace Rex.Infrastructure.Persistence.Migrations
+{
+    /// <inheritdoc />
+    public partial class Initial : Migration
+    {
+        /// <inheritdoc />
+        protected override void Up(MigrationBuilder migrationBuilder)
+        {
+            migrationBuilder.CreateTable(
+                name: "Chat",
+                columns: table => new
+                {
+                    PkChatId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Type = table.Column<string>(type: "character varying(30)", maxLength: 30, nullable: false),
+                    Name = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: true),
+                    GroupPhoto = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: true),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkChatId", x => x.PkChatId);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "File",
+                columns: table => new
+                {
+                    PkFileId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Url = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
+                    Type = table.Column<string>(type: "character varying(30)", maxLength: 30, nullable: false),
+                    UploadedAt = table.Column<DateTime>(type: "timestamptz", nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkFileId", x => x.PkFileId);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "Group",
+                columns: table => new
+                {
+                    PkGroupId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Title = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
+                    Description = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: false),
+                    Visibility = table.Column<string>(type: "character varying(30)", maxLength: 30, nullable: false),
+                    ProfilePhoto = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
+                    CoverPhoto = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: true),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkGroupId", x => x.PkGroupId);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "GroupRole",
+                columns: table => new
+                {
+                    PkGroupRoleId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Role = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkGroupRoleId", x => x.PkGroupRoleId);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "UserRole",
+                columns: table => new
+                {
+                    PkUserRoleId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Role = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkUserRoleId", x => x.PkUserRoleId);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "EntityFile",
+                columns: table => new
+                {
+                    PkEntityFileId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkFileId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkTargetId = table.Column<Guid>(type: "uuid", nullable: false),
+                    TargetType = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkEntityFileId", x => x.PkEntityFileId);
+                    table.ForeignKey(
+                        name: "FkFileEntityFile",
+                        column: x => x.FkFileId,
+                        principalTable: "File",
+                        principalColumn: "PkFileId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "User",
+                columns: table => new
+                {
+                    PkUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FirstName = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
+                    LastName = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
+                    UserName = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
+                    Email = table.Column<string>(type: "text", nullable: false),
+                    Password = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: true),
+                    ProfilePhoto = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: true),
+                    CoverPhoto = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: true),
+                    Biography = table.Column<string>(type: "text", nullable: true),
+                    Gender = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: true),
+                    Birthday = table.Column<DateTime>(type: "date", nullable: true),
+                    LastLoginAt = table.Column<DateTime>(type: "timestamptz", nullable: true),
+                    ConfirmedAccount = table.Column<bool>(type: "boolean", nullable: false, defaultValue: false),
+                    Status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: true),
+                    LastConnection = table.Column<DateTime>(type: "timestamptz", nullable: true),
+                    IsActive = table.Column<bool>(type: "boolean", nullable: false, defaultValue: true),
+                    FkRoleId = table.Column<Guid>(type: "uuid", nullable: true),
+                    GitHubId = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: true),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkUserId", x => x.PkUserId);
+                    table.ForeignKey(
+                        name: "FkUserRoleUser",
+                        column: x => x.FkRoleId,
+                        principalTable: "UserRole",
+                        principalColumn: "PkUserRoleId");
+                });
+
+            migrationBuilder.CreateTable(
+                name: "Challenge",
+                columns: table => new
+                {
+                    PkChallengeId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Title = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
+                    Description = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: false),
+                    FkCreatorId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkGroupId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Duration = table.Column<TimeSpan>(type: "interval", nullable: false),
+                    Status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
+                    CoverPhoto = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkChallengeId", x => x.PkChallengeId);
+                    table.ForeignKey(
+                        name: "FK_Challenge_User_FkCreatorId",
+                        column: x => x.FkCreatorId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FkGroupChallenge",
+                        column: x => x.FkGroupId,
+                        principalTable: "Group",
+                        principalColumn: "PkGroupId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "Code",
+                columns: table => new
+                {
+                    PkCodeId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Value = table.Column<string>(type: "character varying(6)", maxLength: 6, nullable: false),
+                    Expiration = table.Column<DateTime>(type: "timestamptz", nullable: false),
+                    Type = table.Column<string>(type: "character varying(30)", maxLength: 30, nullable: false),
+                    Revoked = table.Column<bool>(type: "boolean", nullable: false, defaultValue: false),
+                    Used = table.Column<bool>(type: "boolean", nullable: false, defaultValue: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkCodeId", x => x.PkCodeId);
+                    table.ForeignKey(
+                        name: "FkUserCode",
+                        column: x => x.FkUserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "FriendShip",
+                columns: table => new
+                {
+                    PkFriendShipId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkTargetUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkRequesterId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkFriendShipId", x => x.PkFriendShipId);
+                    table.ForeignKey(
+                        name: "FkUserReceivedFriendRequest",
+                        column: x => x.FkTargetUserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FkUserSentFriendRequest",
+                        column: x => x.FkRequesterId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "Message",
+                columns: table => new
+                {
+                    Id = table.Column<Guid>(type: "uuid", nullable: false),
+                    Description = table.Column<string>(type: "text", nullable: false),
+                    FkChatId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkSenderId = table.Column<Guid>(type: "uuid", nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkMessageId", x => x.Id);
+                    table.ForeignKey(
+                        name: "FK_Message_User_FkSenderId",
+                        column: x => x.FkSenderId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FkChatMessage",
+                        column: x => x.FkChatId,
+                        principalTable: "Chat",
+                        principalColumn: "PkChatId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "Notification",
+                columns: table => new
+                {
+                    PkNotificationId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Title = table.Column<string>(type: "character varying(125)", maxLength: 125, nullable: false),
+                    Description = table.Column<string>(type: "character varying(255)", maxLength: 255, nullable: false),
+                    FkUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Read = table.Column<bool>(type: "boolean", nullable: false, defaultValue: false),
+                    RecipientType = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: false),
+                    RecipientId = table.Column<Guid>(type: "uuid", nullable: false),
+                    MetadataJson = table.Column<string>(type: "jsonb", nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkNotificationId", x => x.PkNotificationId);
+                    table.ForeignKey(
+                        name: "FkUserSentNotification",
+                        column: x => x.FkUserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "Reaction",
+                columns: table => new
+                {
+                    PkReactionId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkTargetId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Like = table.Column<bool>(type: "boolean", nullable: false, defaultValue: false),
+                    TargetType = table.Column<string>(type: "character varying(30)", maxLength: 30, nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkReactionId", x => x.PkReactionId);
+                    table.ForeignKey(
+                        name: "FkUserReaction",
+                        column: x => x.FkUserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "RefreshToken",
+                columns: table => new
+                {
+                    PkRefreshTokenId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Value = table.Column<string>(type: "text", nullable: false),
+                    Used = table.Column<bool>(type: "boolean", nullable: false, defaultValue: false),
+                    Expiration = table.Column<DateTime>(type: "timestamptz", nullable: false),
+                    Revoked = table.Column<bool>(type: "boolean", nullable: false, defaultValue: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkRefreshTokenId", x => x.PkRefreshTokenId);
+                    table.ForeignKey(
+                        name: "FkUserRefreshToken",
+                        column: x => x.FkUserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "UserChat",
+                columns: table => new
+                {
+                    PkUserChatId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkChatId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkUserChatId", x => x.PkUserChatId);
+                    table.ForeignKey(
+                        name: "FkChatUserChat",
+                        column: x => x.FkChatId,
+                        principalTable: "Chat",
+                        principalColumn: "PkChatId",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FkUserUserChat",
+                        column: x => x.FkUserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "UserGroup",
+                columns: table => new
+                {
+                    PkUserGroupId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkGroupId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkGroupRoleId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Status = table.Column<string>(type: "character varying(50)", maxLength: 50, nullable: true),
+                    LastWarningAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    HasBeenWarned = table.Column<bool>(type: "boolean", nullable: false),
+                    RequestedAt = table.Column<DateTime>(type: "timestamptz", nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamptz", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkUserGroupId", x => x.PkUserGroupId);
+                    table.ForeignKey(
+                        name: "FkGroupRoleUserGroup",
+                        column: x => x.FkGroupRoleId,
+                        principalTable: "GroupRole",
+                        principalColumn: "PkGroupRoleId",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FkGroupUserGroup",
+                        column: x => x.FkGroupId,
+                        principalTable: "Group",
+                        principalColumn: "PkGroupId",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FkUserGroup",
+                        column: x => x.FkUserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "Post",
+                columns: table => new
+                {
+                    PkPostId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Title = table.Column<string>(type: "character varying(100)", maxLength: 100, nullable: false),
+                    Description = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: true),
+                    FkUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkGroupId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkChallengeId = table.Column<Guid>(type: "uuid", nullable: true),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkPostId", x => x.PkPostId);
+                    table.ForeignKey(
+                        name: "FkChallengePost",
+                        column: x => x.FkChallengeId,
+                        principalTable: "Challenge",
+                        principalColumn: "PkChallengeId");
+                    table.ForeignKey(
+                        name: "FkGroupPost",
+                        column: x => x.FkGroupId,
+                        principalTable: "Group",
+                        principalColumn: "PkGroupId",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FkUserPost",
+                        column: x => x.FkUserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "UserChallenge",
+                columns: table => new
+                {
+                    Id = table.Column<Guid>(type: "uuid", nullable: false),
+                    UserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    ChallengeId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Status = table.Column<string>(type: "text", nullable: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PK_UserChallenge", x => x.Id);
+                    table.ForeignKey(
+                        name: "FK_UserChallenge_Challenge_ChallengeId",
+                        column: x => x.ChallengeId,
+                        principalTable: "Challenge",
+                        principalColumn: "PkChallengeId",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FK_UserChallenge_User_UserId",
+                        column: x => x.UserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateTable(
+                name: "Comment",
+                columns: table => new
+                {
+                    PkCommentId = table.Column<Guid>(type: "uuid", nullable: false),
+                    Description = table.Column<string>(type: "character varying(500)", maxLength: 500, nullable: false),
+                    FkPostId = table.Column<Guid>(type: "uuid", nullable: false),
+                    FkUserId = table.Column<Guid>(type: "uuid", nullable: false),
+                    IsPinned = table.Column<bool>(type: "boolean", nullable: false, defaultValue: false),
+                    ParentCommentId = table.Column<Guid>(type: "uuid", nullable: true),
+                    Edited = table.Column<bool>(type: "boolean", nullable: false, defaultValue: false),
+                    CreatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: false),
+                    UpdatedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true),
+                    Deleted = table.Column<bool>(type: "boolean", nullable: false),
+                    DeletedAt = table.Column<DateTime>(type: "timestamp with time zone", nullable: true)
+                },
+                constraints: table =>
+                {
+                    table.PrimaryKey("PkCommentId", x => x.PkCommentId);
+                    table.ForeignKey(
+                        name: "FkComment",
+                        column: x => x.ParentCommentId,
+                        principalTable: "Comment",
+                        principalColumn: "PkCommentId");
+                    table.ForeignKey(
+                        name: "FkPostComment",
+                        column: x => x.FkPostId,
+                        principalTable: "Post",
+                        principalColumn: "PkPostId",
+                        onDelete: ReferentialAction.Cascade);
+                    table.ForeignKey(
+                        name: "FkUserComment",
+                        column: x => x.FkUserId,
+                        principalTable: "User",
+                        principalColumn: "PkUserId",
+                        onDelete: ReferentialAction.Cascade);
+                });
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Challenge_FkCreatorId",
+                table: "Challenge",
+                column: "FkCreatorId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Challenge_FkGroupId",
+                table: "Challenge",
+                column: "FkGroupId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Code_UserId_Type_Status",
+                table: "Code",
+                columns: new[] { "FkUserId", "Type", "Used", "Revoked" });
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Comment_FkPostId",
+                table: "Comment",
+                column: "FkPostId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Comment_FkUserId",
+                table: "Comment",
+                column: "FkUserId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Comment_ParentCommentId",
+                table: "Comment",
+                column: "ParentCommentId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_EntityFile_FkFileId",
+                table: "EntityFile",
+                column: "FkFileId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_FriendShip_FkTargetUserId",
+                table: "FriendShip",
+                column: "FkTargetUserId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_FriendShip_RequesterId_TargetUserId_Status",
+                table: "FriendShip",
+                columns: new[] { "FkRequesterId", "FkTargetUserId", "Status" });
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Message_ChatId_CreatedAt",
+                table: "Message",
+                columns: new[] { "FkChatId", "CreatedAt" });
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Message_FkSenderId",
+                table: "Message",
+                column: "FkSenderId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Notification_FkUserId",
+                table: "Notification",
+                column: "FkUserId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Post_FkChallengeId",
+                table: "Post",
+                column: "FkChallengeId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Post_FkUserId",
+                table: "Post",
+                column: "FkUserId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Post_GroupId_CreatedAt",
+                table: "Post",
+                columns: new[] { "FkGroupId", "CreatedAt" });
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Reaction_FkUserId",
+                table: "Reaction",
+                column: "FkUserId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_Reaction_TargetId_Type_Like",
+                table: "Reaction",
+                columns: new[] { "FkTargetId", "TargetType", "Like" },
+                filter: "\"Like\" = true");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_RefreshToken_FkUserId",
+                table: "RefreshToken",
+                column: "FkUserId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_User_FkRoleId",
+                table: "User",
+                column: "FkRoleId");
+
+            migrationBuilder.CreateIndex(
+                name: "UQ_User_Email",
+                table: "User",
+                column: "Email",
+                unique: true);
+
+            migrationBuilder.CreateIndex(
+                name: "IX_UserChallenge_ChallengeId",
+                table: "UserChallenge",
+                column: "ChallengeId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_UserChallenge_UserId",
+                table: "UserChallenge",
+                column: "UserId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_UserChat_FkChatId",
+                table: "UserChat",
+                column: "FkChatId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_UserChat_FkUserId",
+                table: "UserChat",
+                column: "FkUserId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_UserGroup_FkGroupId",
+                table: "UserGroup",
+                column: "FkGroupId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_UserGroup_FkGroupRoleId",
+                table: "UserGroup",
+                column: "FkGroupRoleId");
+
+            migrationBuilder.CreateIndex(
+                name: "IX_UserGroup_UserId_GroupId_Status",
+                table: "UserGroup",
+                columns: new[] { "FkUserId", "FkGroupId", "Status" });
+        }
+
+        /// <inheritdoc />
+        protected override void Down(MigrationBuilder migrationBuilder)
+        {
+            migrationBuilder.DropTable(
+                name: "Code");
+
+            migrationBuilder.DropTable(
+                name: "Comment");
+
+            migrationBuilder.DropTable(
+                name: "EntityFile");
+
+            migrationBuilder.DropTable(
+                name: "FriendShip");
+
+            migrationBuilder.DropTable(
+                name: "Message");
+
+            migrationBuilder.DropTable(
+                name: "Notification");
+
+            migrationBuilder.DropTable(
+                name: "Reaction");
+
+            migrationBuilder.DropTable(
+                name: "RefreshToken");
+
+            migrationBuilder.DropTable(
+                name: "UserChallenge");
+
+            migrationBuilder.DropTable(
+                name: "UserChat");
+
+            migrationBuilder.DropTable(
+                name: "UserGroup");
+
+            migrationBuilder.DropTable(
+                name: "Post");
+
+            migrationBuilder.DropTable(
+                name: "File");
+
+            migrationBuilder.DropTable(
+                name: "Chat");
+
+            migrationBuilder.DropTable(
+                name: "GroupRole");
+
+            migrationBuilder.DropTable(
+                name: "Challenge");
+
+            migrationBuilder.DropTable(
+                name: "User");
+
+            migrationBuilder.DropTable(
+                name: "Group");
+
+            migrationBuilder.DropTable(
+                name: "UserRole");
+        }
+    }
+}
diff --git a/Rex.Infrastructure.Persistence/Migrations/RexContextModelSnapshot.cs b/Rex.Infrastructure.Persistence/Migrations/RexContextModelSnapshot.cs
new file mode 100644
index 0000000..7b69e8e
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Migrations/RexContextModelSnapshot.cs
@@ -0,0 +1,1277 @@
+// <auto-generated />
+using System;
+using Microsoft.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore.Infrastructure;
+using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
+using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
+using Rex.Infrastructure.Persistence.Context;
+
+#nullable disable
+
+namespace Rex.Infrastructure.Persistence.Migrations
+{
+    [DbContext(typeof(RexContext))]
+    partial class RexContextModelSnapshot : ModelSnapshot
+    {
+        protected override void BuildModel(ModelBuilder modelBuilder)
+        {
+#pragma warning disable 612, 618
+            modelBuilder
+                .HasAnnotation("ProductVersion", "8.0.10")
+                .HasAnnotation("Relational:MaxIdentifierLength", 63);
+
+            NpgsqlModelBuilderExtensions.UseIdentityByDefaultColumns(modelBuilder);
+
+            modelBuilder.Entity("Rex.Models.Challenge", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkChallengeId");
+
+                    b.Property<string>("CoverPhoto")
+                        .IsRequired()
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("CreatorId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkCreatorId");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasMaxLength(500)
+                        .HasColumnType("character varying(500)");
+
+                    b.Property<TimeSpan>("Duration")
+                        .HasColumnType("interval");
+
+                    b.Property<Guid>("GroupId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkGroupId");
+
+                    b.Property<string>("Status")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<string>("Title")
+                        .IsRequired()
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkChallengeId");
+
+                    b.HasIndex("CreatorId");
+
+                    b.HasIndex("GroupId");
+
+                    b.ToTable("Challenge", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Chat", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkChatId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("GroupPhoto")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<string>("Name")
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<string>("Type")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkChatId");
+
+                    b.ToTable("Chat", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Code", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkCodeId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime>("Expiration")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<bool>("Revoked")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<string>("Type")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Used")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.Property<string>("Value")
+                        .IsRequired()
+                        .HasMaxLength(6)
+                        .HasColumnType("character varying(6)");
+
+                    b.HasKey("Id")
+                        .HasName("PkCodeId");
+
+                    b.HasIndex("UserId", "Type", "Used", "Revoked")
+                        .HasDatabaseName("IX_Code_UserId_Type_Status");
+
+                    b.ToTable("Code", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Comment", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkCommentId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasMaxLength(500)
+                        .HasColumnType("character varying(500)");
+
+                    b.Property<bool>("Edited")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<bool>("IsPinned")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid?>("ParentCommentId")
+                        .HasColumnType("uuid");
+
+                    b.Property<Guid>("PostId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkPostId");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkCommentId");
+
+                    b.HasIndex("ParentCommentId");
+
+                    b.HasIndex("PostId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("Comment", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.EntityFile", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkEntityFileId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("FileId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkFileId");
+
+                    b.Property<Guid>("TargetId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkTargetId");
+
+                    b.Property<string>("TargetType")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkEntityFileId");
+
+                    b.HasIndex("FileId");
+
+                    b.ToTable("EntityFile", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.File", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkFileId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Type")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime>("UploadedAt")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<string>("Url")
+                        .IsRequired()
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.HasKey("Id")
+                        .HasName("PkFileId");
+
+                    b.ToTable("File", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.FriendShip", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkFriendShipId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("RequesterId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkRequesterId");
+
+                    b.Property<string>("Status")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<Guid>("TargetUserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkTargetUserId");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkFriendShipId");
+
+                    b.HasIndex("TargetUserId");
+
+                    b.HasIndex("RequesterId", "TargetUserId", "Status")
+                        .HasDatabaseName("IX_FriendShip_RequesterId_TargetUserId_Status");
+
+                    b.ToTable("FriendShip", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Group", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkGroupId");
+
+                    b.Property<string>("CoverPhoto")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasMaxLength(500)
+                        .HasColumnType("character varying(500)");
+
+                    b.Property<string>("ProfilePhoto")
+                        .IsRequired()
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<string>("Title")
+                        .IsRequired()
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Visibility")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.HasKey("Id")
+                        .HasName("PkGroupId");
+
+                    b.ToTable("Group", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.GroupRole", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkGroupRoleId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Role")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkGroupRoleId");
+
+                    b.ToTable("GroupRole", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Message", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid");
+
+                    b.Property<Guid>("ChatId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkChatId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasColumnType("text");
+
+                    b.Property<Guid>("SenderId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkSenderId");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkMessageId");
+
+                    b.HasIndex("SenderId");
+
+                    b.HasIndex("ChatId", "CreatedAt")
+                        .HasDatabaseName("IX_Message_ChatId_CreatedAt");
+
+                    b.ToTable("Message", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Notification", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkNotificationId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .IsRequired()
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<string>("MetadataJson")
+                        .IsRequired()
+                        .HasColumnType("jsonb");
+
+                    b.Property<bool>("Read")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid>("RecipientId")
+                        .HasColumnType("uuid");
+
+                    b.Property<string>("RecipientType")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<string>("Title")
+                        .IsRequired()
+                        .HasMaxLength(125)
+                        .HasColumnType("character varying(125)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkNotificationId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("Notification", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Post", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkPostId");
+
+                    b.Property<Guid?>("ChallengeId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkChallengeId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Description")
+                        .HasMaxLength(500)
+                        .HasColumnType("character varying(500)");
+
+                    b.Property<Guid>("GroupId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkGroupId");
+
+                    b.Property<string>("Title")
+                        .IsRequired()
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkPostId");
+
+                    b.HasIndex("ChallengeId");
+
+                    b.HasIndex("UserId");
+
+                    b.HasIndex("GroupId", "CreatedAt")
+                        .HasDatabaseName("IX_Post_GroupId_CreatedAt");
+
+                    b.ToTable("Post", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Reaction", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkReactionId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Like")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid>("TargetId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkTargetId");
+
+                    b.Property<string>("TargetType")
+                        .IsRequired()
+                        .HasMaxLength(30)
+                        .HasColumnType("character varying(30)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkReactionId");
+
+                    b.HasIndex("UserId");
+
+                    b.HasIndex("TargetId", "TargetType", "Like")
+                        .HasDatabaseName("IX_Reaction_TargetId_Type_Like")
+                        .HasFilter("\"Like\" = true");
+
+                    b.ToTable("Reaction", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.RefreshToken", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkRefreshTokenId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime>("Expiration")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<bool>("Revoked")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Used")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.Property<string>("Value")
+                        .IsRequired()
+                        .HasColumnType("text");
+
+                    b.HasKey("Id")
+                        .HasName("PkRefreshTokenId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("RefreshToken", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.User", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkUserId");
+
+                    b.Property<string>("Biography")
+                        .HasColumnType("text");
+
+                    b.Property<DateTime?>("Birthday")
+                        .HasColumnType("date");
+
+                    b.Property<bool>("ConfirmedAccount")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(false);
+
+                    b.Property<string>("CoverPhoto")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Email")
+                        .IsRequired()
+                        .HasColumnType("text");
+
+                    b.Property<string>("FirstName")
+                        .IsRequired()
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<string>("Gender")
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<string>("GitHubId")
+                        .HasMaxLength(100)
+                        .HasColumnType("character varying(100)");
+
+                    b.Property<bool>("IsActive")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("boolean")
+                        .HasDefaultValue(true);
+
+                    b.Property<DateTime?>("LastConnection")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<DateTime?>("LastLoginAt")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<string>("LastName")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<string>("Password")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<string>("ProfilePhoto")
+                        .HasMaxLength(255)
+                        .HasColumnType("character varying(255)");
+
+                    b.Property<Guid?>("RoleId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkRoleId");
+
+                    b.Property<string>("Status")
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("UserName")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.HasKey("Id")
+                        .HasName("PkUserId");
+
+                    b.HasIndex("Email")
+                        .IsUnique()
+                        .HasDatabaseName("UQ_User_Email");
+
+                    b.HasIndex("RoleId");
+
+                    b.ToTable("User", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.UserChallenge", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid");
+
+                    b.Property<Guid>("ChallengeId")
+                        .HasColumnType("uuid");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Status")
+                        .IsRequired()
+                        .HasColumnType("text");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid");
+
+                    b.HasKey("Id");
+
+                    b.HasIndex("ChallengeId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("UserChallenge");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserChat", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkUserChatId");
+
+                    b.Property<Guid>("ChatId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkChatId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkUserChatId");
+
+                    b.HasIndex("ChatId");
+
+                    b.HasIndex("UserId");
+
+                    b.ToTable("UserChat", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.UserGroup", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkUserGroupId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("GroupId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkGroupId");
+
+                    b.Property<Guid>("GroupRoleId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkGroupRoleId");
+
+                    b.Property<bool>("HasBeenWarned")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("LastWarningAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<DateTime>("RequestedAt")
+                        .HasColumnType("timestamptz");
+
+                    b.Property<string>("Status")
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<Guid>("UserId")
+                        .HasColumnType("uuid")
+                        .HasColumnName("FkUserId");
+
+                    b.HasKey("Id")
+                        .HasName("PkUserGroupId");
+
+                    b.HasIndex("GroupId");
+
+                    b.HasIndex("GroupRoleId");
+
+                    b.HasIndex("UserId", "GroupId", "Status")
+                        .HasDatabaseName("IX_UserGroup_UserId_GroupId_Status");
+
+                    b.ToTable("UserGroup", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.UserRole", b =>
+                {
+                    b.Property<Guid>("Id")
+                        .ValueGeneratedOnAdd()
+                        .HasColumnType("uuid")
+                        .HasColumnName("PkUserRoleId");
+
+                    b.Property<DateTime>("CreatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<bool>("Deleted")
+                        .HasColumnType("boolean");
+
+                    b.Property<DateTime?>("DeletedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.Property<string>("Role")
+                        .IsRequired()
+                        .HasMaxLength(50)
+                        .HasColumnType("character varying(50)");
+
+                    b.Property<DateTime?>("UpdatedAt")
+                        .HasColumnType("timestamp with time zone");
+
+                    b.HasKey("Id")
+                        .HasName("PkUserRoleId");
+
+                    b.ToTable("UserRole", (string)null);
+                });
+
+            modelBuilder.Entity("Rex.Models.Challenge", b =>
+                {
+                    b.HasOne("Rex.Models.User", "Creator")
+                        .WithMany()
+                        .HasForeignKey("CreatorId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired();
+
+                    b.HasOne("Rex.Models.Group", "Group")
+                        .WithMany("Challenges")
+                        .HasForeignKey("GroupId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkGroupChallenge");
+
+                    b.Navigation("Creator");
+
+                    b.Navigation("Group");
+                });
+
+            modelBuilder.Entity("Rex.Models.Code", b =>
+                {
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("Codes")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserCode");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.Comment", b =>
+                {
+                    b.HasOne("Rex.Models.Comment", "ParentComment")
+                        .WithMany("Replies")
+                        .HasForeignKey("ParentCommentId")
+                        .HasConstraintName("FkComment");
+
+                    b.HasOne("Rex.Models.Post", "Post")
+                        .WithMany("Comments")
+                        .HasForeignKey("PostId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkPostComment");
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("Comments")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserComment");
+
+                    b.Navigation("ParentComment");
+
+                    b.Navigation("Post");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.EntityFile", b =>
+                {
+                    b.HasOne("Rex.Models.File", "File")
+                        .WithMany("EntityFiles")
+                        .HasForeignKey("FileId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkFileEntityFile");
+
+                    b.Navigation("File");
+                });
+
+            modelBuilder.Entity("Rex.Models.FriendShip", b =>
+                {
+                    b.HasOne("Rex.Models.User", "Requester")
+                        .WithMany("SentFriendRequests")
+                        .HasForeignKey("RequesterId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserSentFriendRequest");
+
+                    b.HasOne("Rex.Models.User", "TargetUser")
+                        .WithMany("ReceivedFriendRequests")
+                        .HasForeignKey("TargetUserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserReceivedFriendRequest");
+
+                    b.Navigation("Requester");
+
+                    b.Navigation("TargetUser");
+                });
+
+            modelBuilder.Entity("Rex.Models.Message", b =>
+                {
+                    b.HasOne("Rex.Models.Chat", "Chat")
+                        .WithMany("Messages")
+                        .HasForeignKey("ChatId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkChatMessage");
+
+                    b.HasOne("Rex.Models.User", "Sender")
+                        .WithMany()
+                        .HasForeignKey("SenderId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired();
+
+                    b.Navigation("Chat");
+
+                    b.Navigation("Sender");
+                });
+
+            modelBuilder.Entity("Rex.Models.Notification", b =>
+                {
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("SentNotifications")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserSentNotification");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.Post", b =>
+                {
+                    b.HasOne("Rex.Models.Challenge", "Challenge")
+                        .WithMany("Posts")
+                        .HasForeignKey("ChallengeId")
+                        .HasConstraintName("FkChallengePost");
+
+                    b.HasOne("Rex.Models.Group", "Group")
+                        .WithMany("Posts")
+                        .HasForeignKey("GroupId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkGroupPost");
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("Posts")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserPost");
+
+                    b.Navigation("Challenge");
+
+                    b.Navigation("Group");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.Reaction", b =>
+                {
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("Reactions")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserReaction");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.RefreshToken", b =>
+                {
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("RefreshTokens")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserRefreshToken");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.User", b =>
+                {
+                    b.HasOne("Rex.Models.UserRole", "Role")
+                        .WithMany("Users")
+                        .HasForeignKey("RoleId")
+                        .HasConstraintName("FkUserRoleUser");
+
+                    b.Navigation("Role");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserChallenge", b =>
+                {
+                    b.HasOne("Rex.Models.Challenge", "Challenge")
+                        .WithMany("UserChallenges")
+                        .HasForeignKey("ChallengeId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired();
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("UserChallenges")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired();
+
+                    b.Navigation("Challenge");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserChat", b =>
+                {
+                    b.HasOne("Rex.Models.Chat", "Chat")
+                        .WithMany("UserChats")
+                        .HasForeignKey("ChatId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkChatUserChat");
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("UserChats")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserUserChat");
+
+                    b.Navigation("Chat");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserGroup", b =>
+                {
+                    b.HasOne("Rex.Models.Group", "Group")
+                        .WithMany("UserGroups")
+                        .HasForeignKey("GroupId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkGroupUserGroup");
+
+                    b.HasOne("Rex.Models.GroupRole", "GroupRole")
+                        .WithMany("UserGroups")
+                        .HasForeignKey("GroupRoleId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkGroupRoleUserGroup");
+
+                    b.HasOne("Rex.Models.User", "User")
+                        .WithMany("UserGroups")
+                        .HasForeignKey("UserId")
+                        .OnDelete(DeleteBehavior.Cascade)
+                        .IsRequired()
+                        .HasConstraintName("FkUserGroup");
+
+                    b.Navigation("Group");
+
+                    b.Navigation("GroupRole");
+
+                    b.Navigation("User");
+                });
+
+            modelBuilder.Entity("Rex.Models.Challenge", b =>
+                {
+                    b.Navigation("Posts");
+
+                    b.Navigation("UserChallenges");
+                });
+
+            modelBuilder.Entity("Rex.Models.Chat", b =>
+                {
+                    b.Navigation("Messages");
+
+                    b.Navigation("UserChats");
+                });
+
+            modelBuilder.Entity("Rex.Models.Comment", b =>
+                {
+                    b.Navigation("Replies");
+                });
+
+            modelBuilder.Entity("Rex.Models.File", b =>
+                {
+                    b.Navigation("EntityFiles");
+                });
+
+            modelBuilder.Entity("Rex.Models.Group", b =>
+                {
+                    b.Navigation("Challenges");
+
+                    b.Navigation("Posts");
+
+                    b.Navigation("UserGroups");
+                });
+
+            modelBuilder.Entity("Rex.Models.GroupRole", b =>
+                {
+                    b.Navigation("UserGroups");
+                });
+
+            modelBuilder.Entity("Rex.Models.Post", b =>
+                {
+                    b.Navigation("Comments");
+                });
+
+            modelBuilder.Entity("Rex.Models.User", b =>
+                {
+                    b.Navigation("Codes");
+
+                    b.Navigation("Comments");
+
+                    b.Navigation("Posts");
+
+                    b.Navigation("Reactions");
+
+                    b.Navigation("ReceivedFriendRequests");
+
+                    b.Navigation("RefreshTokens");
+
+                    b.Navigation("SentFriendRequests");
+
+                    b.Navigation("SentNotifications");
+
+                    b.Navigation("UserChallenges");
+
+                    b.Navigation("UserChats");
+
+                    b.Navigation("UserGroups");
+                });
+
+            modelBuilder.Entity("Rex.Models.UserRole", b =>
+                {
+                    b.Navigation("Users");
+                });
+#pragma warning restore 612, 618
+        }
+    }
+}
diff --git a/Rex.Infrastructure.Persistence/Repository/ChallengeRepository.cs b/Rex.Infrastructure.Persistence/Repository/ChallengeRepository.cs
new file mode 100644
index 0000000..2f0db02
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/ChallengeRepository.cs
@@ -0,0 +1,145 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class ChallengeRepository(RexContext context) : GenericRepository<Challenge>(context), IChallengeRepository
+{
+    public async Task<PagedResult<Challenge>> GetChallengesPaginatedByGroupIdAndStatusAsync(Guid groupId, int page,
+        int size, ChallengeStatus status,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<Challenge>()
+            .AsNoTracking()
+            .Where(g => g.GroupId == groupId && g.Status == status.ToString());
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var challenges = await query
+            .Where(g => g.GroupId == groupId && g.Status == status.ToString())
+            .Select(g => new Challenge
+            {
+                Id = g.Id,
+                Title = g.Title,
+                Description = g.Description,
+                Status = g.Status,
+                CreatedAt = g.CreatedAt,
+                Duration = (g.CreatedAt + g.Duration) - DateTime.UtcNow,
+                Group = new Group
+                {
+                    Id = g.Group.Id,
+                    Title = g.Group.Title,
+                    ProfilePhoto = g.Group.ProfilePhoto,
+                    CoverPhoto = g.Group.CoverPhoto,
+                    Description = g.Group.Description,
+                    Visibility = g.Group.Visibility
+                },
+                UserChallenges = g.UserChallenges
+                    .Select(uc => new UserChallenge
+                    {
+                        Id = uc.Id,
+                        Status = uc.Status,
+                        User = new User
+                        {
+                            Id = uc.User.Id,
+                            ProfilePhoto = uc.User.ProfilePhoto
+                        }
+                    })
+                    .ToList()
+            })
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<Challenge>(challenges, total, page, size);
+    }
+
+    public async Task<PagedResult<Challenge>> GetChallengesPaginatedByUserParticipationGroupAndStatusAsync(Guid userId,
+        int page, int size,
+        Guid groupId, UserChallengeStatus status,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<Challenge>()
+            .AsNoTracking()
+            .Where(c => c.Status == status.ToString() && c.GroupId == groupId &&
+                        c.UserChallenges.Any(g => g.UserId == userId));
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var challenges = await query
+            .Where(c => c.Status == status.ToString() && c.GroupId == groupId &&
+                        c.UserChallenges.Any(g => g.UserId == userId))
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<Challenge>(challenges, total, page, size);
+    }
+
+    public async Task<PagedResult<Challenge>> GetChallengesPaginatedByUserIdAndStatusAsync(Guid userId, int page,
+        int size,
+        UserChallengeStatus status,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<Challenge>()
+            .AsNoTracking()
+            .Where(c => c.UserChallenges.Any(c => c.UserId == userId && c.Status == status.ToString()));
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var challenges = await query
+            .Select(c => new Challenge
+            {
+                Id = c.Id,
+                Title = c.Title,
+                Description = c.Description,
+                Status = c.Status,
+                CreatedAt = c.CreatedAt,
+                Duration = (c.CreatedAt + c.Duration) - DateTime.UtcNow,
+                Group = new Group
+                {
+                    Id = c.Group.Id,
+                    Title = c.Group.Title,
+                    ProfilePhoto = c.Group.ProfilePhoto
+                },
+                UserChallenges = c.UserChallenges
+                    .Select(uc => new UserChallenge
+                    {
+                        Status = uc.Status,
+                        UserId = uc.UserId,
+                        User = new User
+                        {
+                            ProfilePhoto = uc.User.ProfilePhoto
+                        }
+                    }).ToList()
+            })
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<Challenge>(challenges, total, page, size);
+    }
+
+    public async Task<bool> UserAlreadyJoined(Guid userId, Guid challengeId, CancellationToken cancellationToken) =>
+        await ValidateAsync(
+            c => c.UserChallenges.Any(a =>
+                a.UserId == userId && a.ChallengeId == challengeId &&
+                a.Status == UserChallengeStatus.Enrolled.ToString()), cancellationToken);
+
+    public async Task<bool> ChallengeBelongsToGroup(Guid groupId, Guid challengeId, CancellationToken cancellationToken) =>
+        await ValidateAsync(c => c.Id == challengeId && c.GroupId == groupId, cancellationToken);
+
+    public async Task<IEnumerable<Challenge>> GetExpiredChallenges(CancellationToken cancellationToken) =>
+        await context.Set<Challenge>()
+            .Where(c => !c.Deleted && c.Status == ChallengeStatus.Active.ToString())
+            .Where(c => DateTime.UtcNow - c.CreatedAt > c.Duration)
+            .ToListAsync(cancellationToken);
+
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/ChatRepository.cs b/Rex.Infrastructure.Persistence/Repository/ChatRepository.cs
new file mode 100644
index 0000000..25efd93
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/ChatRepository.cs
@@ -0,0 +1,96 @@
+using Microsoft.EntityFrameworkCore;
+using Microsoft.EntityFrameworkCore.Query;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class ChatRepository(RexContext context) : GenericRepository<Chat>(context), IChatRepository
+{
+    public async Task<PagedResult<Chat>> GetChatsWithLastMessageByUserIdAsync(
+        Guid userId, int page, int size, string? searchTerm = null, CancellationToken cancellationToken = default)
+    {
+        var baseQuery = context.Set<Chat>()
+            .AsNoTracking()
+            .Where(c => c.UserChats.Any(uc => uc.UserId == userId));
+
+        if (!string.IsNullOrWhiteSpace(searchTerm))
+        {
+            var searchTermLike = $"%{searchTerm}%";
+
+            baseQuery = baseQuery.Where(chat =>
+                context.Set<UserChat>()
+                    .Where(uc => uc.ChatId == chat.Id && uc.UserId != userId)
+                    .Any(uc =>
+                        EF.Functions.Like(uc.User.FirstName, searchTermLike) ||
+                        EF.Functions.Like(uc.User.LastName, searchTermLike)
+                    )
+            );
+        }
+
+        var total = await baseQuery.CountAsync(cancellationToken);
+
+        var query = baseQuery
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .Select(c => new Chat
+            {
+                Id = c.Id,
+                Name = c.Name,
+                CreatedAt = c.CreatedAt,
+                Type = c.Type,
+                GroupPhoto = c.GroupPhoto,
+
+                Messages = c.Messages
+                    .OrderByDescending(m => m.CreatedAt)
+                    .Take(1)
+                    .Select(m => new Message
+                    {
+                        Id = m.Id,
+                        Description = m.Description,
+                        CreatedAt = m.CreatedAt,
+                        ChatId = m.ChatId,
+                        SenderId = m.SenderId,
+                        Sender = new User
+                        {
+                            Id = m.Sender.Id,
+                            FirstName = m.Sender.FirstName,
+                            LastName = m.Sender.LastName,
+                            ProfilePhoto = m.Sender.ProfilePhoto
+                        }
+                    }).ToList(),
+
+                UserChats = c.UserChats.Select(uc => new UserChat
+                {
+                    ChatId = uc.ChatId,
+                    UserId = uc.UserId,
+                    User = new User
+                    {
+                        Id = uc.User.Id,
+                        FirstName = uc.User.FirstName,
+                        LastName = uc.User.LastName,
+                        ProfilePhoto = uc.User.ProfilePhoto
+                    }
+                }).ToList()
+            });
+
+        var chats = await query.ToListAsync(cancellationToken);
+
+        return new PagedResult<Chat>(chats, total, page, size);
+    }
+
+    public async Task<bool> ChatExistsAsync(Guid chatId, CancellationToken cancellationToken) =>
+        await ValidateAsync(c => c.Id == chatId, cancellationToken);
+
+    public Task<Chat> GetOneToOneChat(Guid firstUser, Guid secondUser, CancellationToken cancellationToken) =>
+        context.Set<Chat>()
+            .Where(c => c.Type == ChatType.Private.ToString() &&
+                        c.UserChats.Count == 2 &&
+                        c.UserChats.Any(uc => uc.UserId == firstUser) &&
+                        c.UserChats.Any(uc => uc.UserId == secondUser))
+            .FirstOrDefaultAsync(cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/CodeRepository.cs b/Rex.Infrastructure.Persistence/Repository/CodeRepository.cs
new file mode 100644
index 0000000..55247cc
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/CodeRepository.cs
@@ -0,0 +1,44 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class CodeRepository(RexContext context): GenericRepository<Code>(context), ICodeRepository
+{
+    public async Task CreateCodeAsync(Code code, CancellationToken cancellationToken)
+    {
+        await context.Set<Code>().AddAsync(code, cancellationToken);
+        await SaveAsync(cancellationToken);
+    }
+
+    public async Task<Code> GetCodeByIdAsync(Guid id, CancellationToken cancellationToken) =>
+        await context.Set<Code>()
+            .AsNoTracking()
+            .FirstOrDefaultAsync(e => e.Id == id, cancellationToken);
+
+    public async Task<Code> GetCodeByValueAsync(string value, CancellationToken cancellationToken) =>
+        await context.Set<Code>()
+            .AsNoTracking()
+            .FirstOrDefaultAsync(e => e.Value == value, cancellationToken);
+
+    public async Task<bool> IsCodeValidAsync(string code, CancellationToken cancellationToken) =>
+        await ValidateAsync(c => c.Value == code && c.Expiration > DateTime.UtcNow && !c.Used, cancellationToken);
+
+    public async Task MarkCodeAsUsedAsync(string code, CancellationToken cancellationToken)
+    {
+        var userCode = await context.Set<Code>()
+            .FirstOrDefaultAsync(c => c.Value == code, cancellationToken);
+
+        if (userCode != null)
+        {
+            userCode.Used = true;
+            await SaveAsync(cancellationToken);
+        }
+    }
+
+    public async Task<bool> IsCodeUsedAsync(string code, CancellationToken cancellationToken) =>
+         await ValidateAsync( c=> c.Value == code && c.Used, cancellationToken);
+    
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/CommentRepository.cs b/Rex.Infrastructure.Persistence/Repository/CommentRepository.cs
new file mode 100644
index 0000000..3ba48ea
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/CommentRepository.cs
@@ -0,0 +1,100 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class CommentRepository(RexContext context) : GenericRepository<Comment>(context), ICommentRepository
+{
+    public async Task<PagedResult<Comment>> GetCommentsPaginatedByPostIdAsync(
+        Guid postId, int page, int size,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<Comment>()
+            .AsNoTracking()
+            .Where(c => c.PostId == postId && c.ParentCommentId == null);
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var comments = await query
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .Select(c => new Comment
+            {
+                Id = c.Id,
+                Description = c.Description,
+                CreatedAt = c.CreatedAt,
+                IsPinned = c.IsPinned,
+                Edited = c.Edited,
+                PostId = c.PostId,
+                UserId = c.UserId,
+                ParentCommentId = null,
+                User = c.User,
+                Replies = c.Replies
+                    .OrderBy(r => r.CreatedAt)
+                    .Take(1)
+                    .ToList()
+            })
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<Comment>(comments, total, page, size);
+    }
+
+    public async Task<PagedResult<Comment>> GetCommentsRepliedPaginatedByParentCommentIdAsync(Guid postId, int page, int size,
+        Guid parentCommentId, CancellationToken cancellationToken)
+    {
+        var query = context.Set<Comment>()
+            .AsNoTracking()
+            .Include(c => c.Replies)
+            .Where(c => c.PostId == postId && c.ParentCommentId == parentCommentId);
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var comments = await query
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Select(c => new Comment
+            {
+                Id = c.Id,
+                Description = c.Description,
+                CreatedAt = c.CreatedAt,
+                IsPinned = c.IsPinned,
+                Edited = c.Edited,
+                PostId = c.PostId,
+                UserId = c.UserId,
+                ParentCommentId = c.ParentCommentId,
+                User = c.User,
+                Replies = c.Replies
+                    .OrderBy(r => r.CreatedAt)
+                    .Take(1)
+                    .ToList()
+            })
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<Comment>(comments, total, page, size);
+    }
+
+    public async Task<int> GetCommentsCountByPostIdAsync(Guid postId, CancellationToken cancellationToken) =>
+        await context.Set<Comment>()
+            .AsNoTracking()
+            .Where(f => f.PostId == postId)
+            .CountAsync(cancellationToken);
+
+    public async Task<bool> CommentAlreadyPinned(Guid commentId, CancellationToken cancellationToken) =>
+        await ValidateAsync(c => c.Id == commentId && c.IsPinned, cancellationToken);
+
+    public async Task<bool> AnotherCommentIsPinned(Guid postId, CancellationToken cancellationToken) =>
+        await ValidateAsync(c => c.PostId == postId && c.IsPinned, cancellationToken);
+
+    public async Task<Dictionary<Guid, int>> GetCommentsCountByPostIdsAsync(IEnumerable<Guid> postIds,
+        CancellationToken cancellationToken) =>
+        await context.Set<Comment>()
+            .Where(c => postIds.Contains(c.PostId))
+            .AsNoTracking()
+            .GroupBy(c => c.PostId)
+            .Select(g => new { PostId = g.Key, Count = g.Count() })
+            .ToDictionaryAsync(g => g.PostId, g => g.Count, cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/EntityFileRepository.cs b/Rex.Infrastructure.Persistence/Repository/EntityFileRepository.cs
new file mode 100644
index 0000000..e782940
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/EntityFileRepository.cs
@@ -0,0 +1,20 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class EntityFileRepository(RexContext context): GenericRepository<EntityFile>(context), IEntityFileRepository
+{
+    public async Task<bool> ExistsAsync(Guid targetId, Guid fileId, TargetType targetType, CancellationToken cancellationToken) =>
+        await ValidateAsync(e => e.TargetId == targetId && e.FileId == fileId && e.TargetType == targetType.ToString(), 
+            cancellationToken);
+
+    public async Task<int> CountByTargetIdAsync(Guid targetId, TargetType targetType,
+        CancellationToken cancellationToken) =>
+        await context.Set<EntityFile>()
+            .Where(e => e.TargetId == targetId && e.TargetType == targetType.ToString())
+            .CountAsync(cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/FileRepository.cs b/Rex.Infrastructure.Persistence/Repository/FileRepository.cs
new file mode 100644
index 0000000..edfdb67
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/FileRepository.cs
@@ -0,0 +1,65 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+using File = Rex.Models.File;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class FileRepository(RexContext context) : GenericRepository<File>(context), IFileRepository
+{
+    public async Task<IEnumerable<File>> GetFilesByEntityAndTypeAsync(Guid targetId, TargetType targetType, int page,
+        int size, FileType type, CancellationToken cancellationToken) =>
+        await context.Set<File>()
+            .AsNoTracking()
+            .Where(f => f.Type == type.ToString() &&
+                        f.EntityFiles.Any(c => c.TargetId == targetId && c.TargetType == targetType.ToString())
+            ).ToListAsync(cancellationToken);
+
+
+    public async Task<IEnumerable<File>> GetFilesByEntityAsync(Guid targetId, TargetType targetType, int page,
+        int size, CancellationToken cancellationToken) =>
+        await context.Set<File>()
+            .AsNoTracking()
+            .Where(t => t.EntityFiles.Any(c => c.TargetId == targetId && c.TargetType == targetType.ToString()))
+            .ToListAsync(cancellationToken);
+
+
+    public async Task<File> GetFileByEntityAndTypeAsync(Guid targetId, TargetType targetType,
+        CancellationToken cancellationToken) =>
+        await context.Set<File>()
+            .AsNoTracking()
+            .FirstOrDefaultAsync(f => f.EntityFiles.Any(c => c.TargetId == targetId
+                                                             && c.TargetType == targetType.ToString()),
+                cancellationToken);
+    
+    public async Task<IEnumerable<File>> GetFilesByTargetIdsAsync(IEnumerable<Guid> ids, TargetType targetType, CancellationToken ct)
+    {
+        return await context.Set<File>()
+            .Include(f => f.EntityFiles)
+            .Select(c => new File
+            {
+                Id = c.Id,
+                Url = c.Url,
+                Type = c.Type,
+                EntityFiles = c.EntityFiles.Where(e => ids.Contains(e.TargetId) && e.TargetType == targetType.ToString()).ToList()
+            })
+            .ToListAsync(ct);
+    }
+
+    public async Task<IEnumerable<File>> GetFilesByTargetIdAsync(Guid targetId, TargetType targetType, CancellationToken cancellationToken)
+    {
+        return await context.Set<EntityFile>()
+            .Where(e => e.TargetId == targetId && e.TargetType == targetType.ToString())
+            .Select(e => new File
+            {
+                Id = e.File.Id,
+                Url = e.File.Url,
+                Type = e.File.Type,
+                UploadedAt = e.File.UploadedAt
+            }).ToListAsync(cancellationToken);
+    }
+
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/FrienshipRepository.cs b/Rex.Infrastructure.Persistence/Repository/FrienshipRepository.cs
new file mode 100644
index 0000000..8207b7d
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/FrienshipRepository.cs
@@ -0,0 +1,72 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class FrienshipRepository(RexContext context) : GenericRepository<FriendShip>(context), IFriendShipRepository
+{
+    public async Task<PagedResult<FriendShip>> GetFriendShipRequestsByUserIdAsync(
+        Guid userId, int page, int size, RequestStatus status, CancellationToken cancellationToken)
+    {
+        var query = context.Set<FriendShip>()
+            .Where(f => f.TargetUserId == userId && f.Status == status.ToString())
+            .Select(f => new FriendShip
+            {
+                Id = f.Id,
+                Status = f.Status,
+                CreatedAt = f.CreatedAt,
+                Requester = new User
+                {
+                    Id = f.RequesterId,
+                    FirstName = f.Requester.FirstName,
+                    LastName = f.Requester.LastName,
+                    ProfilePhoto = f.Requester.ProfilePhoto
+                },
+                TargetUser = new User
+                {
+                    Id = f.TargetUserId,
+                    FirstName = f.TargetUser.FirstName,
+                    LastName = f.TargetUser.LastName,
+                    ProfilePhoto = f.TargetUser.ProfilePhoto
+                }
+            });
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var friendships = await query
+            .OrderByDescending(f => f.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<FriendShip>(friendships, total, page, size);
+    }
+
+    public async Task<bool> FriendShipExistAsync(Guid requesterId, Guid targetUserId, CancellationToken cancellationToken) =>
+        await ValidateAsync(
+            f => f.RequesterId == requesterId &&
+                 f.TargetUserId == targetUserId &&
+                 (f.Status == RequestStatus.Pending.ToString() || f.Status == RequestStatus.Accepted.ToString()) &&
+                 f.Deleted == false,
+            cancellationToken);
+
+    public async Task<FriendShip> GetFriendShipInPendingAsync(Guid requesterId, Guid targetUserId,
+        CancellationToken cancellationToken) =>
+        await context.Set<FriendShip>()
+            .Where(c => c.RequesterId == requesterId && c.TargetUserId == targetUserId &&
+                        c.Status == RequestStatus.Pending.ToString())
+            .FirstOrDefaultAsync(cancellationToken);
+    
+    public async Task<FriendShip> GetFriendShipBetweenUsersAsync(Guid requesterId, Guid targetUserId, CancellationToken cancellationToken) =>
+        await context.Set<FriendShip>()
+            .Where(f =>
+                (f.RequesterId == requesterId && f.TargetUserId == targetUserId) ||
+                (f.RequesterId == targetUserId && f.TargetUserId == requesterId))
+            .FirstOrDefaultAsync(cancellationToken);
+
+
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/GenericRepository.cs b/Rex.Infrastructure.Persistence/Repository/GenericRepository.cs
new file mode 100644
index 0000000..96b456b
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/GenericRepository.cs
@@ -0,0 +1,53 @@
+using System.Linq.Expressions;
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class GenericRepository<TEntity>(RexContext context)
+    : IGenericRepository<TEntity> where TEntity : AuditableEntity
+{
+    public async Task<TEntity> GetByIdAsync(Guid id, CancellationToken cancellationToken) =>
+        await context.Set<TEntity>().FindAsync(id, cancellationToken);
+
+    public async Task UpdateAsync(TEntity entity, CancellationToken cancellationToken)
+    {
+        context.Set<TEntity>().Attach(entity);
+        context.Entry(entity).State = EntityState.Modified;
+        await SaveAsync(cancellationToken);
+    }
+
+    public async Task DeleteAsync(TEntity entity, CancellationToken cancellationToken)
+    {
+        await context.Set<TEntity>()
+            .Where(e => e.Id == entity.Id)
+            .ExecuteUpdateAsync(
+                s => s
+                    .SetProperty(e => e.Deleted, true)
+                    .SetProperty(e => e.DeletedAt, DateTime.UtcNow),
+                cancellationToken);
+    }
+
+    public async Task CreateAsync(TEntity entity, CancellationToken cancellationToken)
+    {
+        await context.Set<TEntity>().AddAsync(entity, cancellationToken);
+        await SaveAsync(cancellationToken);
+    }
+
+    public async Task SaveAsync(CancellationToken cancellationToken) =>
+        await context.SaveChangesAsync(cancellationToken);
+
+    public async Task<bool> ValidateAsync(Expression<Func<TEntity, bool>> validation,
+        CancellationToken cancellationToken) =>
+        await context.Set<TEntity>()
+            .AsNoTracking()
+            .AnyAsync(validation, cancellationToken);
+
+    public async Task UpdateRangeAsync(IEnumerable<TEntity> entities, CancellationToken cancellationToken)
+    {
+        context.Set<TEntity>().UpdateRange(entities);
+        await context.SaveChangesAsync(cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/GroupRepository.cs b/Rex.Infrastructure.Persistence/Repository/GroupRepository.cs
new file mode 100644
index 0000000..04dbb42
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/GroupRepository.cs
@@ -0,0 +1,112 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Group = Rex.Models.Group;
+using UserGroup = Rex.Models.UserGroup;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class GroupRepository(RexContext context) : GenericRepository<Group>(context), IGroupRepository
+{
+    public async Task<PagedResult<Group>> GetGroupsByUserIdAsync(Guid userId, int page, int size,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<Group>()
+            .AsNoTracking()
+            .Where(c => c.UserGroups.Any(g => g.UserId == userId));
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var groups = await query
+            .AsNoTracking()
+            .Where(c => c.UserGroups.Any(g => g.UserId == userId))
+            .OrderBy(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .Select(g => new Group
+            {
+                Id = g.Id,
+                Title = g.Title,
+                Description = g.Description,
+                Visibility = g.Visibility,
+                ProfilePhoto = g.ProfilePhoto,
+                CoverPhoto = g.CoverPhoto,
+                CreatedAt = g.CreatedAt,
+                UserGroups = g.UserGroups
+                    .Select(ug => new UserGroup
+                    {
+                        UserId = ug.UserId,
+                    })
+                    .ToList()
+            })
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<Group>(groups, total, page, size);
+    }
+
+    public async Task<PagedResult<Group>> GetGroupsPaginatedAsync(Guid userId, int page, int size, CancellationToken cancellationToken)
+    {
+        var total = await context.Set<Group>()
+            .AsNoTracking()
+            .Where(c => !c.UserGroups.Any(g => g.UserId == userId))
+            .CountAsync(cancellationToken);
+
+        var result = await context.Set<Group>()
+            .AsNoTracking()
+            .Where(c => !c.UserGroups.Any(g => g.UserId == userId))
+            .OrderBy(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .Select(g => new Group
+            {
+                Id = g.Id,
+                Title = g.Title,
+                Description = g.Description,
+                Visibility = g.Visibility,
+                ProfilePhoto = g.ProfilePhoto,
+                CoverPhoto = g.CoverPhoto,
+                CreatedAt = g.CreatedAt,
+                UserGroups = g.UserGroups
+                    .Select(ug => new UserGroup
+                    {
+                        UserId = ug.UserId
+                    })
+                    .ToList()
+            })
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<Group>(result, total, page, size);
+    }
+
+    public async Task<Group> GetGroupByIdAsync(Guid groupId, CancellationToken cancellationToken) =>
+        await context.Set<Group>()
+            .AsNoTracking()
+            .Where(c => c.Id == groupId)
+            .Select(c => new Group
+            {
+                Id = c.Id,
+                Title = c.Title,
+                Description = c.Description,
+                Visibility = c.Visibility,
+                ProfilePhoto = c.ProfilePhoto,
+                CoverPhoto = c.CoverPhoto,
+                CreatedAt = c.CreatedAt,
+                UserGroups = c.UserGroups
+                    .Select(ug => new UserGroup
+                    {
+                        UserId = ug.UserId
+                    })
+                    .ToList()
+            }).FirstOrDefaultAsync(cancellationToken);
+
+    public async Task<bool> GroupExistAsync(Guid groupId, CancellationToken cancellationToken) =>
+        await ValidateAsync(c => c.Id == groupId, cancellationToken);
+
+    public async Task<int> GetGroupCountByUserIdAsync(Guid userId, CancellationToken cancellationToken) =>
+        await context.Set<Group>()
+            .AsNoTracking()
+            .Where(c => c.UserGroups.Any(g => g.UserId == userId))
+            .CountAsync(cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/GroupRoleRepository.cs b/Rex.Infrastructure.Persistence/Repository/GroupRoleRepository.cs
new file mode 100644
index 0000000..7d95f69
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/GroupRoleRepository.cs
@@ -0,0 +1,14 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class GroupRoleRepository(RexContext context): GenericRepository<Models.GroupRole>(context), IGroupRoleRepository
+{
+    public async Task<GroupRole> GetRoleByNameAsync(Enum.GroupRole role, CancellationToken cancellationToken) =>
+        await context.Set<GroupRole>()
+            .AsNoTracking()
+            .FirstOrDefaultAsync(c => c.Role == role.ToString(), cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/MessageRepository.cs b/Rex.Infrastructure.Persistence/Repository/MessageRepository.cs
new file mode 100644
index 0000000..b5141de
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/MessageRepository.cs
@@ -0,0 +1,29 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class MessageRepository(RexContext context): GenericRepository<Message>(context), IMessageRepository
+{
+    public async Task<PagedResult<Message>> GetMessagesByChatIdAsync(Guid chatId, int page, int size, CancellationToken cancellationToken)
+    {
+        var query = context.Set<Message>()
+            .Where(c => c.ChatId == chatId)
+            .Include(c => c.Sender);
+
+        var total = await query.CountAsync(cancellationToken);
+        
+        var messages = await query
+            .Where(c => c.ChatId == chatId)
+            .OrderBy(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+        
+        return new PagedResult<Message>(messages, total, page, size);
+            
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/NotificationRepository.cs b/Rex.Infrastructure.Persistence/Repository/NotificationRepository.cs
new file mode 100644
index 0000000..e273e11
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/NotificationRepository.cs
@@ -0,0 +1,30 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class NotificationRepository(RexContext context): GenericRepository<Notification>(context), INotificationRepository
+{
+    public async Task<PagedResult<Notification>> GetNotificationsByUserIdAsync(Guid userId, int page, int size,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<Notification>()
+            .AsNoTracking()
+            .Where(n => n.UserId == userId);
+
+        var total = await query.CountAsync(cancellationToken);
+        
+        var notifications = await query
+            .Where(n => n.UserId == userId)
+            .OrderByDescending(n => n.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+        
+        return new PagedResult<Notification>(notifications, total, page, size);
+    }
+
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/PostRepository.cs b/Rex.Infrastructure.Persistence/Repository/PostRepository.cs
new file mode 100644
index 0000000..7fa4e92
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/PostRepository.cs
@@ -0,0 +1,47 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class PostRepository(RexContext context) : GenericRepository<Post>(context), IPostRepository
+{
+    public async Task<PagedResult<Post>> GetPostsByGroupIdAsync(Guid groupId, int page, int size,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<Post>()
+            .AsNoTracking()
+            .Where(p => p.GroupId == groupId)
+            .Select(p => new Post
+            {
+                Id = p.Id,
+                Title = p.Title,
+                Description = p.Description,
+                CreatedAt = p.CreatedAt,
+                GroupId = p.GroupId,
+                ChallengeId = p.ChallengeId,
+                UserId = p.UserId,
+                Challenge = p.Challenge,
+                User = new User
+                {
+                    Id = p.User.Id,
+                    ProfilePhoto = p.User.ProfilePhoto,
+                    FirstName = p.User.FirstName,
+                    LastName = p.User.LastName,
+                    UserChallenges = p.User.UserChallenges
+                }
+            });
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var posts = await query
+            .OrderByDescending(p => p.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<Post>(posts, total, page, size);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/ReactionRepository.cs b/Rex.Infrastructure.Persistence/Repository/ReactionRepository.cs
new file mode 100644
index 0000000..ef187fe
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/ReactionRepository.cs
@@ -0,0 +1,52 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class ReactionRepository(RexContext context) : GenericRepository<Reaction>(context), IReactionRepository
+{
+    public async Task<int> CountLikesAsync(Guid targetId, ReactionTargetType targetType,
+        CancellationToken cancellationToken) =>
+        await context.Set<Reaction>()
+            .AsNoTracking()
+            .CountAsync(r => r.TargetId == targetId
+                             && r.TargetType == targetType.ToString()
+                             && r.Like,
+                cancellationToken);
+
+    public async Task<Reaction> HasLikedAsync(Guid targetId, Guid userId,
+        CancellationToken cancellationToken) =>
+        await context.Set<Reaction>()
+            .AsNoTracking()
+            .FirstOrDefaultAsync(
+                c => c.TargetId == targetId && c.UserId == userId, cancellationToken);
+
+    public async Task<Dictionary<Guid, int>> GetLikesCountByPostIdsAsync(IEnumerable<Guid> Ids, TargetType targetType,
+        CancellationToken cancellationToken) =>
+        await context.Set<Reaction>()
+            .Where(c => Ids.Contains(c.TargetId) && c.Like && c.TargetType == targetType.ToString())
+            .AsNoTracking()
+            .GroupBy(c => c.TargetId)
+            .Select(g => new { targetId = g.Key, Count = g.Count() })
+            .ToDictionaryAsync(g => g.targetId, g => g.Count, cancellationToken);
+
+    public async Task<HashSet<Guid>> GetUserLikesForTargetsAsync(
+        Guid userId,
+        List<Guid> targetIds,
+        ReactionTargetType targetType,
+        CancellationToken cancellationToken)
+    {
+        var likes = await context.Set<Reaction>()
+            .Where(r => r.UserId == userId
+                        && targetIds.Contains(r.TargetId)
+                        && r.TargetType == targetType.ToString()
+                        && r.Like)
+            .Select(r => r.TargetId)
+            .ToListAsync(cancellationToken);
+
+        return new HashSet<Guid>(likes);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/RefreshTokenRepository.cs b/Rex.Infrastructure.Persistence/Repository/RefreshTokenRepository.cs
new file mode 100644
index 0000000..6d00b83
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/RefreshTokenRepository.cs
@@ -0,0 +1,50 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class RefreshTokenRepository(RexContext context): GenericRepository<RefreshToken>(context), IRefreshTokenRepository
+{
+    public async Task CreateRefreshTokenAsync(RefreshToken token, CancellationToken cancellationToken)
+    {
+        await context.Set<RefreshToken>().AddAsync(token, cancellationToken);
+        await SaveAsync(cancellationToken);
+    }
+
+    public async Task<RefreshToken> GetRefreshTokenByIdAsync(Guid tokenId, CancellationToken cancellationToken) =>
+        await context.Set<RefreshToken>()
+            .FirstOrDefaultAsync( t => t.Id == tokenId, cancellationToken );
+
+    public async Task<bool> IsRefreshTokenValidAsync(Guid userId, string receivedToken, CancellationToken cancellationToken)
+    {
+        var activeTokens = await GetActiveTokensByUserIdAsync(userId, cancellationToken);
+
+        return activeTokens.Any(t => t.Value == receivedToken);
+    }
+
+    public async Task MarkRefreshTokenAsUsedAsync(string token, CancellationToken cancellationToken)
+    {
+        var userToken = await context.Set<RefreshToken>()
+            .FirstOrDefaultAsync(t => t.Value == token, cancellationToken);
+
+        if (userToken != null)
+        {
+            userToken.Used = true;
+            await SaveAsync(cancellationToken);
+        }
+    }
+
+    public async Task RevokeOldRefreshTokensAsync(Guid userId, Guid tokenId,
+        CancellationToken cancellationToken) =>
+        await context.Set<RefreshToken>()
+            .Where(c => c.Id != tokenId && !c.Used && c.Expiration > DateTime.UtcNow && c.UserId == userId)
+            .ExecuteUpdateAsync(c => c.SetProperty(u => u.Revoked, true), cancellationToken);
+            
+
+    public async Task<List<RefreshToken>> GetActiveTokensByUserIdAsync(Guid userId, CancellationToken cancellationToken) =>
+        await context.Set<RefreshToken>()
+            .Where(t => t.UserId == userId && !t.Used && !t.Revoked && t.Expiration > DateTime.UtcNow)
+            .ToListAsync(cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/UserChallengeRepository.cs b/Rex.Infrastructure.Persistence/Repository/UserChallengeRepository.cs
new file mode 100644
index 0000000..f232743
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/UserChallengeRepository.cs
@@ -0,0 +1,22 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class UserChallengeRepository(RexContext context)
+    : GenericRepository<UserChallenge>(context), IUserChallengeRepository
+{
+    public async Task<int> GetChallengesCountByUserIdAsync(Guid userId, CancellationToken cancellationToken) =>
+        await context.Set<UserChallenge>()
+            .AsNoTracking()
+            .Where(u => u.UserId == userId)
+            .CountAsync(cancellationToken);
+
+    public async Task<UserChallenge> GetByUserAndChallengeAsync(Guid userId, Guid challengeId,
+        CancellationToken cancellationToken) =>
+        await context.Set<UserChallenge>()
+            .FirstOrDefaultAsync(uc => uc.UserId == userId && uc.ChallengeId == challengeId, cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/UserChatRepository.cs b/Rex.Infrastructure.Persistence/Repository/UserChatRepository.cs
new file mode 100644
index 0000000..055fe2a
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/UserChatRepository.cs
@@ -0,0 +1,30 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class UserChatRepository(RexContext context) : GenericRepository<UserChat>(context), IUserChatRepository
+{
+    public async Task<bool> IsUserInChatAsync(Guid userId, Guid chatId, CancellationToken cancellationToken) =>
+        await ValidateAsync(u => u.UserId == userId && u.ChatId == chatId, cancellationToken);
+    public async Task<List<Guid>> GetUserChatsAsync(Guid userId, CancellationToken cancellationToken) =>
+        await context.Set<UserChat>()
+            .Where(c => c.UserId == userId)
+            .Select(c => c.ChatId)
+            .ToListAsync(cancellationToken);
+    
+    public async Task CreateRangeAsync(IEnumerable<UserChat> entities, CancellationToken cancellationToken)
+    {
+        context.Set<UserChat>().AddRange(entities);
+        await context.SaveChangesAsync(cancellationToken);
+    }
+    
+    public async Task<User> GetOtherUserInChatAsync(Guid chatId, Guid currentUserId, CancellationToken cancellationToken)
+        => await context.Set<UserChat>()
+            .Where(uc => uc.ChatId == chatId && uc.UserId != currentUserId)
+            .Select(uc => uc.User)
+            .FirstOrDefaultAsync(cancellationToken);
+
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/UserGroupRepository.cs b/Rex.Infrastructure.Persistence/Repository/UserGroupRepository.cs
new file mode 100644
index 0000000..b45ab7c
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/UserGroupRepository.cs
@@ -0,0 +1,217 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+using GroupRole = Rex.Enum.GroupRole;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class UserGroupRepository(RexContext context) : GenericRepository<UserGroup>(context), IUserGroupRepository
+{
+    public async Task<int> GetUserGroupCountAsync(Guid userId, RequestStatus status,
+        CancellationToken cancellationToken) =>
+        await context.Set<UserGroup>()
+            .AsNoTracking()
+            .Where(ug => ug.UserId == userId && ug.Status == status.ToString())
+            .CountAsync(cancellationToken);
+
+    public async Task<bool> IsUserInGroupAsync(Guid userId, Guid groupId, RequestStatus? status,
+        CancellationToken cancellationToken)
+    {
+        return await context.Set<UserGroup>()
+            .AnyAsync(ug => ug.UserId == userId && ug.GroupId == groupId
+                                                && ug.Status == status.ToString()
+                , cancellationToken);
+    }
+
+    public async Task<bool> IsGroupPrivateAsync(Guid groupId, CancellationToken cancellationToken) =>
+        await ValidateAsync(c => c.GroupId == groupId && c.Group.Visibility == GroupVisibility.Private.ToString(),
+            cancellationToken);
+
+    public async Task<bool> IsUserBannedAsync(Guid userId, Guid groupId, CancellationToken cancellationToken) =>
+        await ValidateAsync(
+            ug => ug.UserId == userId && ug.GroupId == groupId && ug.Status == UserStatus.Banned.ToString(),
+            cancellationToken);
+
+    public async Task<PagedResult<UserGroup>> GetMembersAsync(Guid groupId, GroupRole? roleFilter, string? searchTerm,
+        int pageNumber, int pageSize, CancellationToken cancellationToken)
+    {
+        var query = context.Set<UserGroup>()
+            .AsNoTracking()
+            .Select(c => new UserGroup
+            {
+                UserId = c.UserId,
+                GroupId = c.GroupId,
+                Status = c.Status,
+                RequestedAt = c.RequestedAt,
+                GroupRole = c.GroupRole,
+                User = new User
+                {
+                    Id = c.User.Id,
+                    UserName = c.User.UserName,
+                    FirstName = c.User.FirstName,
+                    LastName = c.User.LastName,
+                    Role = c.User.Role,
+                    ProfilePhoto = c.User.ProfilePhoto
+                }
+            })
+            .Where(c => c.GroupId == groupId &&
+                        c.Status == RequestStatus.Accepted.ToString());
+
+        if (roleFilter.HasValue)
+            query = query.Where(c => c.GroupRole.Role == roleFilter.Value.ToString());
+
+        if (!string.IsNullOrEmpty(searchTerm))
+        {
+            query = query.Where(c =>
+                EF.Functions.Like(c.User.UserName, $"%{searchTerm}%") ||
+                EF.Functions.Like(c.User.FirstName, $"%{searchTerm}%") ||
+                EF.Functions.Like(c.User.LastName, $"%{searchTerm}%") ||
+                EF.Functions.Like(c.User.FirstName + " " + c.User.LastName, $"%{searchTerm}%"));
+        }
+
+        var count = await query.CountAsync(cancellationToken);
+
+        var items = await query
+            .OrderByDescending(c => c.RequestedAt)
+            .Skip((pageNumber - 1) * pageSize)
+            .Take(pageSize)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<UserGroup>(items, count, pageNumber, pageSize);
+    }
+
+    public async Task<UserGroup> GetMemberAsync(Guid userId, Guid groupId, CancellationToken cancellation) =>
+        await context.Set<UserGroup>()
+            .Include(ug => ug.GroupRole)
+            .FirstOrDefaultAsync(ug => ug.UserId == userId && ug.GroupId == groupId, cancellation);
+
+    public async Task<PagedResult<UserGroup>> GetGroupRequestsAsync(Guid groupId, RequestStatus status,
+        string? searchTerm,
+        int pageNumber, int pageSize, CancellationToken cancellationToken)
+    {
+        var query = context.Set<UserGroup>()
+            .AsNoTracking()
+            .Where(ug => ug.GroupId == groupId && ug.Status == status.ToString())
+            .Select(c => new UserGroup()
+            {
+                UserId = c.UserId,
+                GroupId = c.GroupId,
+                Status = c.Status,
+                RequestedAt = c.RequestedAt,
+                User = new User
+                {
+                    Id = c.User.Id,
+                    UserName = c.User.UserName,
+                    FirstName = c.User.FirstName,
+                    LastName = c.User.LastName,
+                    ProfilePhoto = c.User.ProfilePhoto,
+                }
+            });
+
+        if (!string.IsNullOrEmpty(searchTerm))
+        {
+            query = query.Where(ug =>
+                EF.Functions.Like(ug.User.UserName, $"%{searchTerm}%") ||
+                EF.Functions.Like(ug.User.FirstName, $"%{searchTerm}%") ||
+                EF.Functions.Like(ug.User.LastName, $"%{searchTerm}%") ||
+                EF.Functions.Like(ug.User.FirstName + " " + ug.User.LastName, $"%{searchTerm}%"));
+        }
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var items = await query
+            .OrderByDescending(ug => ug.RequestedAt)
+            .Skip((pageNumber - 1) * pageSize)
+            .Take(pageSize)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<UserGroup>(items, total, pageNumber, pageSize);
+    }
+
+    public async Task<UserGroup> GetGroupRequestAsync(Guid userId, Guid groupId, CancellationToken cancellationToken) =>
+        await context.Set<UserGroup>()
+            .AsNoTracking()
+            .Where(c => c.UserId == userId && c.GroupId == groupId && c.Status == RequestStatus.Pending.ToString())
+            .FirstOrDefaultAsync(cancellationToken);
+
+    public async Task<bool> RequestExistsAsync(Guid userId, Guid groupId, CancellationToken cancellationToken) =>
+        await ValidateAsync(u => u.UserId == userId
+                                 && u.GroupId == groupId
+                                 && u.Status == RequestStatus.Pending.ToString(), cancellationToken);
+
+    public async Task<IEnumerable<UserGroup>> GetInactiveUserGroupsForWarning(
+        int inactiveDays,
+        CancellationToken cancellationToken)
+    {
+        var warningDate = DateTime.UtcNow.AddDays(-inactiveDays);
+
+        return await context.Set<UserGroup>()
+            .Include(ug => ug.User)
+            .Include(ug => ug.Group)
+            .Include(ug => ug.GroupRole)
+            .Where(ug =>
+                !ug.HasBeenWarned &&
+                ug.Status == RequestStatus.Accepted.ToString() &&
+                ug.GroupRole.Role == GroupRole.Leader.ToString() &&
+                ug.CreatedAt <= warningDate && 
+                !context.Set<Post>().Any(p =>
+                    p.UserId == ug.UserId &&
+                    p.GroupId == ug.GroupId &&
+                    p.CreatedAt >= warningDate
+                )
+            )
+            .ToListAsync(cancellationToken);
+    }
+
+    public async Task<IEnumerable<UserGroup>> GetInactiveUserGroupsForRemoval(
+        int inactiveDays,
+        CancellationToken cancellationToken)
+    {
+        var removalDate = DateTime.UtcNow.AddDays(-inactiveDays);
+
+        return await context.Set<UserGroup>()
+            .Include(ug => ug.User)
+            .Include(ug => ug.Group)
+            .Include(ug => ug.GroupRole)
+            .Where(ug =>
+                ug.HasBeenWarned &&
+                ug.Status == RequestStatus.Accepted.ToString() &&
+                ug.GroupRole.Role == GroupRole.Member.ToString() &&
+                ug.LastWarningAt.HasValue &&
+                ug.LastWarningAt.Value <= removalDate &&
+                ug.CreatedAt <= removalDate &&
+                !context.Set<Post>().Any(p =>
+                    p.UserId == ug.UserId &&
+                    p.GroupId == ug.GroupId &&
+                    p.CreatedAt > ug.LastWarningAt.Value
+                )
+            )
+            .ToListAsync(cancellationToken);
+    }
+
+
+    public async Task MarkMultipleAsWarned(IEnumerable<Guid> userGroupIds, CancellationToken cancellationToken)
+    {
+        await context.Set<UserGroup>()
+            .Where(ug => userGroupIds.Contains(ug.Id))
+            .ExecuteUpdateAsync(
+                s => s
+                    .SetProperty(ug => ug.HasBeenWarned, true)
+                    .SetProperty(ug => ug.LastWarningAt, DateTime.UtcNow)
+                    .SetProperty(ug => ug.UpdatedAt, DateTime.UtcNow),
+                cancellationToken);
+    }
+
+    public async Task ResetWarningStatus(Guid userId, Guid groupId, CancellationToken cancellationToken)
+    {
+        var userGroup = await context.Set<UserGroup>()
+            .FirstOrDefaultAsync(ug => ug.UserId == userId && ug.GroupId == groupId, cancellationToken);
+
+        userGroup.HasBeenWarned = false;
+        userGroup.LastWarningAt = null;
+        await context.SaveChangesAsync(cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/UserRepository.cs b/Rex.Infrastructure.Persistence/Repository/UserRepository.cs
new file mode 100644
index 0000000..0e3f474
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/UserRepository.cs
@@ -0,0 +1,167 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Pagination;
+using Rex.Enum;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+using GroupRole = Rex.Enum.GroupRole;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class UserRepository(RexContext context) : GenericRepository<User>(context), IUserRepository
+{
+    public async Task<bool> ConfirmedAccountAsync(Guid id, CancellationToken cancellationToken) =>
+        await ValidateAsync(u => u.Id == id && u.ConfirmedAccount == true, cancellationToken);
+
+    public async Task<bool> UserNameInUseAsync(Guid userId, string userName, CancellationToken cancellationToken) =>
+        await ValidateAsync(u => u.Id != userId && u.UserName == userName, cancellationToken);
+
+    public async Task<User> GetByEmailAsync(string email, CancellationToken cancellationToken) =>
+        await context.Set<User>()
+            .AsNoTracking()
+            .Where(u => u.Email == email)
+            .FirstOrDefaultAsync(cancellationToken);
+
+    public async Task<bool> EmailInUseAsync(string email, Guid userId, CancellationToken cancellationToken) =>
+        await ValidateAsync(u => u.Email == email && u.Id != userId, cancellationToken);
+
+    public async Task<bool> EmailInUseByYouAsync(Guid userId, string email, CancellationToken cancellationToken) =>
+        await ValidateAsync(u => u.Email == email && u.Id == userId, cancellationToken);
+
+    public async Task UpdatePasswordAsync(User user, string newPassword, CancellationToken cancellationToken)
+    {
+        user.Password = newPassword;
+        context.Set<User>().Update(user);
+        await context.SaveChangesAsync(cancellationToken);
+    }
+
+    public async Task<bool> EmailExistAsync(string email, CancellationToken cancellationToken) =>
+        await ValidateAsync(u => u.Email == email, cancellationToken);
+
+    public async Task<bool> UserNameExistAsync(string userName, CancellationToken cancellationToken) =>
+        await ValidateAsync(u => u.UserName == userName, cancellationToken);
+
+    public async Task<PagedResult<User>> GetUsersByGroupIdAsync(Guid groupId, int page, int size,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<User>()
+            .AsNoTracking()
+            .Where(c => c.UserGroups.Any(ug => ug.GroupId == groupId));
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var users = await query
+            .Where(c => c.UserGroups.Any(ug => ug.GroupId == groupId))
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<User>(users, total, page, size);
+    }
+
+    public async Task<PagedResult<User>> GetUsersByNameOrLastnameAsync(Guid groupId, string searchTerm, int page,
+        int size, CancellationToken cancellationToken)
+    {
+        var query = context.Set<User>()
+            .AsNoTracking()
+            .Where(u => u.FirstName.Contains(searchTerm) ||
+                        u.LastName.Contains(searchTerm) && u.UserGroups.Any(ug => ug.GroupId == groupId));
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var users = await query
+            .Where(u => u.FirstName.Contains(searchTerm) ||
+                        u.LastName.Contains(searchTerm) && u.UserGroups.Any(ug => ug.GroupId == groupId))
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<User>(users, total, page, size);
+    }
+
+    public async Task<PagedResult<User>> GetAdministrativeMembersByGroupIdAsync(Guid groupId, int page, int size,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<User>()
+            .AsNoTracking()
+            .Where(u => u.Role.Role == GroupRole.Leader.ToString()
+                        || u.Role.Role == GroupRole.Moderator.ToString()
+                        || u.Role.Role == GroupRole.Mentor.ToString()
+                        && u.UserGroups.Any(ug => ug.GroupId == groupId));
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var users = await query
+            .Where(u => u.Role.Role == GroupRole.Leader.ToString()
+                        || u.Role.Role == GroupRole.Moderator.ToString()
+                        || u.Role.Role == GroupRole.Mentor.ToString()
+                        && u.UserGroups.Any(ug => ug.GroupId == groupId))
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<User>(users, total, page, size);
+    }
+
+    public async Task<PagedResult<User>> GetPendingRequestsByGroupIdAsync(Guid groupId, int page, int size,
+        CancellationToken cancellationToken)
+    {
+        var query = context.Set<User>()
+            .Where(u => u.UserGroups.Any(g => g.GroupId == groupId && g.Status == RequestStatus.Pending.ToString()));
+
+        var total = await query.CountAsync(cancellationToken);
+
+        var users = await query
+            .Where(u => u.UserGroups.Any(g => g.GroupId == groupId && g.Status == RequestStatus.Pending.ToString()))
+            .OrderByDescending(c => c.CreatedAt)
+            .Skip((page - 1) * size)
+            .Take(size)
+            .ToListAsync(cancellationToken);
+
+        return new PagedResult<User>(users, total, page, size);
+    }
+
+
+    public async Task<User> GetUserDetailsAsync(Guid id, CancellationToken cancellationToken) =>
+        await context.Set<User>()
+            .Where(c => c.Id == id)
+            .Select(c => new User
+            {
+                Id = c.Id,
+                FirstName = c.FirstName,
+                LastName = c.LastName,
+                UserName = c.UserName,
+                Email = c.Email,
+                ProfilePhoto = c.ProfilePhoto,
+                CoverPhoto = c.CoverPhoto,
+                Gender = c.Gender,
+                Biography = c.Biography,
+                LastLoginAt = c.LastLoginAt,
+                Role = c.Role,
+                CreatedAt = c.CreatedAt,
+                UpdatedAt = c.UpdatedAt,
+                ConfirmedAccount = c.ConfirmedAccount,
+                UserGroups = c.UserGroups,
+                Reactions = c.Reactions,
+                UserChallenges = c.UserChallenges
+            })
+            .FirstOrDefaultAsync(cancellationToken);
+
+    public async Task UpdateLastTimeConnectionAsync(Guid userId, bool isActive, CancellationToken cancellationToken) =>
+        await context.Set<User>()
+            .Where(uc => uc.Id == userId)
+            .ExecuteUpdateAsync(s => s.SetProperty(uc => uc.LastConnection, DateTime.UtcNow)
+                .SetProperty(uc => uc.IsActive, isActive), cancellationToken);
+
+    public async Task<User> GetUserByCommentIdAsync(Guid parentCommentId, CancellationToken cancellationToken) =>
+        await context.Set<User>()
+            .Where(c => c.Comments.Any(p => p.ParentCommentId == parentCommentId))
+            .FirstOrDefaultAsync(cancellationToken);
+
+    public async Task<User> GetByGitHubIdAsync(string githubId, CancellationToken cancellationToken) =>
+        await context.Set<User>()
+            .FirstOrDefaultAsync(u => u.GitHubId == githubId, cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Repository/UserRoleRepository.cs b/Rex.Infrastructure.Persistence/Repository/UserRoleRepository.cs
new file mode 100644
index 0000000..ee076d7
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Repository/UserRoleRepository.cs
@@ -0,0 +1,16 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces.Repository;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Persistence.Repository;
+
+public class UserRoleRepository(RexContext context): GenericRepository<UserRole>(context), IUserRoleRepository
+{
+    public async Task<bool> RoleExistsAsync(Guid roleId, CancellationToken cancellationToken) =>
+        await ValidateAsync(c => c.Id == roleId, cancellationToken);
+
+    public async Task<UserRole> GetRoleByNameAsync(string roleName, CancellationToken cancellationToken) =>
+        await context.Set<UserRole>()
+            .FirstOrDefaultAsync(c => c.Role == roleName, cancellationToken);
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Persistence/Rex.Infrastructure.Persistence.csproj b/Rex.Infrastructure.Persistence/Rex.Infrastructure.Persistence.csproj
new file mode 100644
index 0000000..429a28d
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Rex.Infrastructure.Persistence.csproj
@@ -0,0 +1,25 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+    <PropertyGroup>
+        <TargetFramework>net8.0</TargetFramework>
+        <ImplicitUsings>enable</ImplicitUsings>
+        <Nullable>enable</Nullable>
+    </PropertyGroup>
+
+    <ItemGroup>
+      <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.10" />
+      <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.10">
+        <PrivateAssets>all</PrivateAssets>
+        <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
+      </PackageReference>
+      <PackageReference Include="Microsoft.Extensions.Caching.StackExchangeRedis" Version="8.0.10" />
+      <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="8.0.1" />
+      <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.10" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <ProjectReference Include="..\Rex.Application\Rex.Application.csproj" />
+      <ProjectReference Include="..\Rex.Domain\Rex.Domain.csproj" />
+    </ItemGroup>
+
+</Project>
diff --git a/Rex.Infrastructure.Persistence/Services/UserRoleService.cs b/Rex.Infrastructure.Persistence/Services/UserRoleService.cs
new file mode 100644
index 0000000..7ab469d
--- /dev/null
+++ b/Rex.Infrastructure.Persistence/Services/UserRoleService.cs
@@ -0,0 +1,35 @@
+using Microsoft.EntityFrameworkCore;
+using Rex.Application.Interfaces;
+using Rex.Infrastructure.Persistence.Context;
+using Rex.Models;
+using UserRole = Rex.Enum.UserRole;
+
+namespace Rex.Infrastructure.Persistence.Services;
+
+public class UserRoleService(RexContext context): IUserRoleService
+{
+    public async Task<List<string>> GetUserRolesAsync(Guid userId, CancellationToken cancellationToken)
+    {
+        var roles = new List<string>();
+        
+        var userRole = await context.Set<User>()
+            .AsNoTracking()
+            .Where(x => x.Id == userId)
+            .Select(c => c.Role.Role)
+            .ToListAsync(cancellationToken);
+
+
+        if (userRole is not null)
+        {
+            foreach (var role in userRole)
+            {
+                roles.Add(role);
+            }
+        }
+        
+        if (roles.Count is 0)
+            roles.Add(UserRole.User.ToString());
+        
+        return roles;
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/DependencyInjection.cs b/Rex.Infrastructure.Shared/DependencyInjection.cs
new file mode 100644
index 0000000..5a6df82
--- /dev/null
+++ b/Rex.Infrastructure.Shared/DependencyInjection.cs
@@ -0,0 +1,307 @@
+using System.Text;
+using Hangfire;
+using Hangfire.PostgreSql;
+using Microsoft.AspNetCore.Authentication.JwtBearer;
+using Microsoft.Extensions.Configuration;
+using Microsoft.Extensions.DependencyInjection;
+using Microsoft.Extensions.Logging;
+using Microsoft.IdentityModel.Tokens;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Configurations;
+using Rex.Infrastructure.Shared.Services;
+using Rex.Infrastructure.Shared.Services.SignalR;
+using Microsoft.AspNetCore.Authentication;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Builder;
+using Rex.Application.Services;
+using Rex.Enum;
+using Rex.Infrastructure.Shared.Services.Authorization;
+using AuthenticationService = Rex.Infrastructure.Shared.Services.AuthenticationService;
+using IAuthenticationService = Rex.Application.Interfaces.IAuthenticationService;
+
+namespace Rex.Infrastructure.Shared;
+
+public static class DependencyInjection
+{
+    public static void AddSharedLayer(this IServiceCollection services, IConfiguration configuration)
+    {
+        #region Configurations
+
+        services.Configure<EmailConfiguration>(configuration.GetSection("EmailConfigurations"));
+        services.Configure<JWTConfiguration>(configuration.GetSection("JWTConfigurations"));
+        services.Configure<CloudinaryConfiguration>(configuration.GetSection("CloudinaryConfigurations"));
+
+        #endregion
+
+        #region Hangfire
+
+        services.AddHangfire(config => config
+            .SetDataCompatibilityLevel(CompatibilityLevel.Version_180)
+            .UseSimpleAssemblyNameTypeSerializer()
+            .UseRecommendedSerializerSettings()
+            .UsePostgreSqlStorage(configuration.GetConnectionString("HangfireConnection")));
+
+        services.AddHangfireServer(options =>
+        {
+            options.ServerName = $"Rex-{Environment.MachineName}";
+            options.WorkerCount = 4;
+            options.Queues = new[] { "critical", "default" };
+        });
+
+        #endregion
+
+        #region JWT
+
+        services.Configure<JWTConfiguration>(configuration.GetSection("JWTConfigurations"));
+
+        var jwtConfig = configuration.GetSection("JWTConfigurations");
+        var key = jwtConfig["Key"];
+
+        services.AddAuthentication(options =>
+            {
+                options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
+                options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
+                options.DefaultSignInScheme = "Cookies";
+            })
+            .AddJwtBearer(options =>
+            {
+                options.RequireHttpsMetadata = false;
+                options.SaveToken = true;
+
+                options.TokenValidationParameters = new TokenValidationParameters
+                {
+                    ValidateIssuerSigningKey = true,
+                    ValidateIssuer = true,
+                    ValidateAudience = true,
+                    ValidateLifetime = true,
+                    ClockSkew = TimeSpan.Zero,
+                    ValidIssuer = jwtConfig["Issuer"],
+                    ValidAudience = jwtConfig["Audience"],
+                    IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key))
+                };
+
+                options.Events = new JwtBearerEvents
+                {
+                    OnMessageReceived = context =>
+                    {
+                        var accessToken = context.Request.Query["access_token"];
+
+                        if (!string.IsNullOrEmpty(accessToken) &&
+                            context.HttpContext.Request.Path.StartsWithSegments("/hubs"))
+                        {
+                            context.Token = accessToken;
+                        }
+
+                        return Task.CompletedTask;
+                    },
+
+                    OnTokenValidated = context =>
+                    {
+                        var logger = context.HttpContext.RequestServices.GetService<ILogger<JwtBearerEvents>>();
+                        logger?.LogInformation("JWT validated successfully for user: {UserId}",
+                            context.Principal?.FindFirst("sub")?.Value);
+                        return Task.CompletedTask;
+                    },
+
+                    OnAuthenticationFailed = context =>
+                    {
+                        var logger = context.HttpContext.RequestServices.GetService<ILogger<JwtBearerEvents>>();
+                        logger?.LogWarning("JWT authentication failed: {Error}", context.Exception.Message);
+
+                        return Task.CompletedTask;
+                    },
+
+                    OnChallenge = context =>
+                    {
+                        var logger = context.HttpContext.RequestServices.GetService<ILogger<JwtBearerEvents>>();
+                        logger?.LogWarning("JWT challenge triggered for path: {Path}",
+                            context.HttpContext.Request.Path);
+
+                        return Task.CompletedTask;
+                    },
+
+                    OnForbidden = context =>
+                    {
+                        var logger = context.HttpContext.RequestServices.GetService<ILogger<JwtBearerEvents>>();
+                        logger?.LogWarning("Access forbidden for path: {Path}", context.HttpContext.Request.Path);
+
+                        return Task.CompletedTask;
+                    }
+                };
+            })
+            .AddCookie("Cookies", options =>
+            {
+                options.LoginPath = "/api/v1/auth/github-login";
+                options.ExpireTimeSpan = TimeSpan.FromMinutes(5);
+            })
+            .AddOAuth("GitHub", options =>
+            {
+                var githubConfig = configuration.GetSection("GitHubAuthentication");
+
+                var clientId = githubConfig["ClientId"];
+                var clientSecret = githubConfig["ClientSecret"];
+
+                if (string.IsNullOrEmpty(clientId) || string.IsNullOrEmpty(clientSecret))
+                {
+                    throw new InvalidOperationException(
+                        "GitHub OAuth configuration is missing. Please ensure ClientId and ClientSecret are set in GitHubAuthentication section."
+                    );
+                }
+
+                options.ClientId = clientId;
+                options.ClientSecret = clientSecret;
+
+                options.CallbackPath = "/signin-github";
+
+                options.AuthorizationEndpoint = "https://github.com/login/oauth/authorize";
+                options.TokenEndpoint = "https://github.com/login/oauth/access_token";
+                options.UserInformationEndpoint = "https://api.github.com/user";
+
+                options.Scope.Add("user:email");
+                options.Scope.Add("read:user");
+
+                options.ClaimActions.MapJsonKey("urn:github:id", "id");
+                options.ClaimActions.MapJsonKey("urn:github:login", "login");
+                options.ClaimActions.MapJsonKey("urn:github:name", "name");
+                options.ClaimActions.MapJsonKey("urn:github:email", "email");
+                options.ClaimActions.MapJsonKey("urn:github:avatar", "avatar_url");
+
+                options.SignInScheme = "Cookies";
+
+                options.Events = new Microsoft.AspNetCore.Authentication.OAuth.OAuthEvents
+                {
+                    OnCreatingTicket = async context =>
+                    {
+                        var request = new HttpRequestMessage(HttpMethod.Get, context.Options.UserInformationEndpoint);
+                        request.Headers.Accept.Add(
+                            new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));
+                        request.Headers.Authorization =
+                            new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", context.AccessToken);
+
+                        var response = await context.Backchannel.SendAsync(request,
+                            HttpCompletionOption.ResponseHeadersRead, context.HttpContext.RequestAborted);
+                        response.EnsureSuccessStatusCode();
+
+                        var user = System.Text.Json.JsonDocument.Parse(await response.Content.ReadAsStringAsync());
+                        context.RunClaimActions(user.RootElement);
+
+                        if (!context.Identity.HasClaim(c => c.Type == "urn:github:email"))
+                        {
+                            var emailRequest =
+                                new HttpRequestMessage(HttpMethod.Get, "https://api.github.com/user/emails");
+                            emailRequest.Headers.Accept.Add(
+                                new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("application/json"));
+                            emailRequest.Headers.Authorization =
+                                new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", context.AccessToken);
+
+                            var emailResponse = await context.Backchannel.SendAsync(emailRequest,
+                                HttpCompletionOption.ResponseHeadersRead, context.HttpContext.RequestAborted);
+
+                            if (emailResponse.IsSuccessStatusCode)
+                            {
+                                var emails =
+                                    System.Text.Json.JsonDocument.Parse(await emailResponse.Content
+                                        .ReadAsStringAsync());
+                                var primaryEmail = emails.RootElement.EnumerateArray()
+                                    .FirstOrDefault(e => e.GetProperty("primary").GetBoolean());
+
+                                if (primaryEmail.ValueKind != System.Text.Json.JsonValueKind.Undefined)
+                                {
+                                    var email = primaryEmail.GetProperty("email").GetString();
+                                    if (!string.IsNullOrEmpty(email))
+                                    {
+                                        context.Identity.AddClaim(
+                                            new System.Security.Claims.Claim("urn:github:email", email));
+                                    }
+                                }
+                            }
+                        }
+                    }
+                };
+            });
+
+        #endregion
+
+        #region Services
+
+        services.AddScoped<IEmailService, EmailService>();
+        services.AddScoped<IAuthenticationService, AuthenticationService>();
+        services.AddScoped<ICloudinaryService, CloudinaryService>();
+        services.AddScoped<IAppConnectionService, AppConnectionService>();
+        services.AddScoped<IChatNotifier, ChatNotifier>();
+        services.AddScoped<IReactionNotifier, ReactionNotifier>();
+        services.AddScoped<IFriendshipNotifier, FriendshipNotifier>();
+        services.AddScoped<ICommentsNotifier, CommentsNotifier>();
+        services.AddScoped<IChallengeNotifier, ChallengeNotifier>();
+        services.AddScoped<IInactiveUserNotifier, InactiveUserNotifier>();
+        services.AddScoped<IGithubAuthService, GitHubAuthService>();
+        services.AddScoped<IUserClaimService, UserClaimService>();
+        services.AddScoped<IAuthorizationHandler, GroupRoleHandler>();
+
+        #endregion
+
+        #region Group Role Authorization
+
+        services.AddAuthorization(options =>
+        {
+            options.AddPolicy("LeaderOnly", policy =>
+                policy.Requirements.Add(new GroupRoleRequirement(GroupRole.Leader)));
+
+            options.AddPolicy("LeaderOrModerator", policy =>
+                policy.Requirements.Add(new GroupRoleRequirement(GroupRole.Moderator,
+                    GroupRole.Leader)));
+
+            options.AddPolicy("StaffOnly", policy =>
+                policy.Requirements.Add(new GroupRoleRequirement(
+                    GroupRole.Leader,
+                    GroupRole.Moderator,
+                    GroupRole.Mentor
+                )));
+        });
+
+        #endregion
+
+        #region SignalR
+
+        services.AddSignalR();
+
+        #endregion
+    }
+
+    public static void ConfigureHangfireJobs(this IApplicationBuilder app)
+    {
+        RecurringJob.AddOrUpdate<WarnUserService>(
+            recurringJobId: "warn-inactive-users",
+            queue: "default",
+            methodCall: service => service.ProcessWarning(CancellationToken.None),
+            cronExpression: Cron.Daily(1),
+            options: new RecurringJobOptions
+            {
+                TimeZone = TimeZoneInfo.Utc
+            }
+        );
+
+        RecurringJob.AddOrUpdate<RemoveUserService>(
+            recurringJobId: "remove-inactive-users",
+            queue: "critical",
+            methodCall: service => service.ProcessRemoval(CancellationToken.None),
+            cronExpression: Cron.Daily(4),
+            options: new RecurringJobOptions
+            {
+                TimeZone = TimeZoneInfo.Utc
+            }
+        );
+
+        RecurringJob.AddOrUpdate<ChallengeExpirationService>(
+            recurringJobId: "expire-challenges",
+            queue: "default",
+            methodCall: service => service.MarkChallengeExpired(CancellationToken.None),
+            cronExpression: Cron.Hourly,
+            options: new RecurringJobOptions
+            {
+                TimeZone = TimeZoneInfo.Utc
+            }
+        );
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Rex.Infrastructure.Shared.csproj b/Rex.Infrastructure.Shared/Rex.Infrastructure.Shared.csproj
new file mode 100644
index 0000000..c473409
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Rex.Infrastructure.Shared.csproj
@@ -0,0 +1,30 @@
+<Project Sdk="Microsoft.NET.Sdk">
+
+    <PropertyGroup>
+        <TargetFramework>net8.0</TargetFramework>
+        <ImplicitUsings>enable</ImplicitUsings>
+        <Nullable>enable</Nullable>
+    </PropertyGroup>
+
+    <ItemGroup>
+      <PackageReference Include="CloudinaryDotNet" Version="1.27.0" />
+      <PackageReference Include="Hangfire.AspNetCore" Version="1.8.0" />
+      <PackageReference Include="Hangfire.Core" Version="1.8.0" />
+      <PackageReference Include="Hangfire.PostgreSql" Version="1.20.0" />
+      <PackageReference Include="MailKit" Version="4.12.0" />
+      <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.10" />
+      <PackageReference Include="Microsoft.AspNetCore.Authentication.OAuth" Version="2.3.0" />
+      <PackageReference Include="Microsoft.AspNetCore.SignalR" Version="1.2.0" />
+      <PackageReference Include="Microsoft.Extensions.Options" Version="8.0.2" />
+      <PackageReference Include="Microsoft.Extensions.Options.ConfigurationExtensions" Version="8.0.0" />
+      <PackageReference Include="Microsoft.IdentityModel.Tokens" Version="8.10.0" />
+      <PackageReference Include="MimeKit" Version="4.12.0" />
+      <PackageReference Include="System.IdentityModel.Tokens.Jwt" Version="8.10.0" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <ProjectReference Include="..\Rex.Application\Rex.Application.csproj" />
+      <ProjectReference Include="..\Rex.Domain\Rex.Domain.csproj" />
+    </ItemGroup>
+
+</Project>
diff --git a/Rex.Infrastructure.Shared/Services/AuthenticationService.cs b/Rex.Infrastructure.Shared/Services/AuthenticationService.cs
new file mode 100644
index 0000000..7bf2b10
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/AuthenticationService.cs
@@ -0,0 +1,135 @@
+using System.IdentityModel.Tokens.Jwt;
+using System.Security.Claims;
+using System.Text;
+using Microsoft.Extensions.Options;
+using Microsoft.IdentityModel.Tokens;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Configurations;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Shared.Services;
+
+public class AuthenticationService(
+    IOptions<JWTConfiguration> jwtConfiguration,
+    IUserRoleService userRoleService,
+    IRefreshTokenRepository refreshTokenRepository,
+    IUserRepository userRepository
+) : IAuthenticationService
+{
+    private readonly JWTConfiguration _jwtConfiguration = jwtConfiguration.Value;
+
+    public async Task<string> GenerateTokenAsync(User user, CancellationToken cancellationToken)
+    {
+        var claims = new List<Claim>
+        {
+            new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
+            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
+            new Claim("type", "access"),
+        };
+
+        var roles = await userRoleService.GetUserRolesAsync(user.Id, cancellationToken);
+        claims.AddRange(roles.Select(r => new Claim("role", r)));
+
+        var keyBytes = Encoding.UTF8.GetBytes(_jwtConfiguration.Key!);
+        var key = new SymmetricSecurityKey(keyBytes);
+        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
+
+        var token = new JwtSecurityToken(
+            issuer: _jwtConfiguration.Issuer,
+            audience: _jwtConfiguration.Audience,
+            claims: claims,
+            expires: DateTime.UtcNow.AddMinutes(_jwtConfiguration.DurationInMinutes),
+            signingCredentials: credentials
+        );
+
+        return new JwtSecurityTokenHandler().WriteToken(token);
+    }
+
+    public async Task<string> GenerateRefreshTokenAsync(User user, CancellationToken cancellationToken)
+    {
+        var claims = new List<Claim>
+        {
+            new Claim(JwtRegisteredClaimNames.Sub, user.Id.ToString()),
+            new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
+            new Claim("type", "refresh"),
+            new Claim(JwtRegisteredClaimNames.Iat, DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString(), ClaimValueTypes.Integer64)
+        };
+
+        var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtConfiguration.Key));
+        var credentials = new SigningCredentials(key, SecurityAlgorithms.HmacSha256);
+
+        var expiration = DateTime.UtcNow.AddDays(7);
+
+        var token = new JwtSecurityToken(
+            issuer: _jwtConfiguration.Issuer,
+            audience: _jwtConfiguration.Audience,
+            claims: claims,
+            expires: expiration,
+            signingCredentials: credentials
+        );
+
+        var tokenString = new JwtSecurityTokenHandler().WriteToken(token);
+
+        var refreshToken = new RefreshToken
+        {
+            Id = Guid.NewGuid(),
+            UserId = user.Id,
+            Value = tokenString,
+            Expiration = expiration,
+            CreatedAt = DateTime.UtcNow
+        };
+
+        await refreshTokenRepository.CreateRefreshTokenAsync(refreshToken, cancellationToken);
+        await refreshTokenRepository.RevokeOldRefreshTokensAsync(user.Id, refreshToken.Id, cancellationToken);
+
+        return tokenString;
+    }
+
+    public async Task<ResultT<TokenResponseDto>> RefreshTokenAsync(string refreshToken, CancellationToken cancellationToken)
+    {
+        var handler = new JwtSecurityTokenHandler();
+
+        handler.ValidateToken(refreshToken, new TokenValidationParameters
+        {
+            ValidateIssuer = true,
+            ValidateAudience = true,
+            ValidIssuer = _jwtConfiguration.Issuer,
+            ValidAudience = _jwtConfiguration.Audience,
+            ValidateLifetime = false,
+            ValidateIssuerSigningKey = true,
+            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_jwtConfiguration.Key!)),
+            ClockSkew = TimeSpan.Zero
+        }, out SecurityToken token);
+
+        var jwt = (JwtSecurityToken)token;
+        var tokenUserId = Guid.Parse(jwt.Subject);
+
+        if (jwt.Claims.FirstOrDefault(c => c.Type == "type")?.Value != "refresh")
+            return ResultT<TokenResponseDto>.Failure(Error.Unauthorized("401", "The provided token is not a refresh token"));
+
+        var tokenValid = await refreshTokenRepository.IsRefreshTokenValidAsync(tokenUserId, refreshToken, cancellationToken);
+
+        if (!tokenValid)
+        {
+            return ResultT<TokenResponseDto>.Failure(Error.Unauthorized("401", "Refresh token is invalid, used, revoked, or expired"));
+        }
+        
+        var userExist = await userRepository.GetByIdAsync(tokenUserId, cancellationToken);
+
+        if (userExist is null)
+            return ResultT<TokenResponseDto>.Failure(Error.NotFound("404", "User not found"));
+            
+        var newToken = await GenerateTokenAsync(userExist, cancellationToken);
+        var newRefreshToken = await GenerateRefreshTokenAsync(userExist, cancellationToken);
+
+        await refreshTokenRepository.MarkRefreshTokenAsUsedAsync(refreshToken, cancellationToken);
+
+        return ResultT<TokenResponseDto>.Success(new TokenResponseDto(
+            AccessToken: newToken,
+            RefreshToken: newRefreshToken
+            ));
+    }
+}
diff --git a/Rex.Infrastructure.Shared/Services/Authorization/GroupRoleHandler.cs b/Rex.Infrastructure.Shared/Services/Authorization/GroupRoleHandler.cs
new file mode 100644
index 0000000..25e961c
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/Authorization/GroupRoleHandler.cs
@@ -0,0 +1,76 @@
+using System.Security.Claims;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Http;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Interfaces;
+
+namespace Rex.Infrastructure.Shared.Services.Authorization;
+
+public class GroupRoleHandler(
+    ILogger<GroupRoleHandler> logger,
+    IUserInGroupService userInGroupService,
+    IHttpContextAccessor httpContextAccessor
+) : AuthorizationHandler<GroupRoleRequirement>
+{
+    protected override async Task HandleRequirementAsync(
+        AuthorizationHandlerContext context,
+        GroupRoleRequirement requirement)
+    {
+        var claims = context.User.Claims.Select(c => new { c.Type, c.Value }).ToList();
+        logger.LogInformation("Claims in user: {@Claims}", claims);
+
+        var httpContext = httpContextAccessor.HttpContext;
+        if (httpContext is null)
+        {
+            logger.LogWarning("HTTP context is null.");
+            context.Fail(); 
+            return;
+        }
+
+        var cancellationToken = httpContext.RequestAborted;
+
+        var userIdClaim = context.User.FindFirst(ClaimTypes.NameIdentifier)?.Value;
+        if (userIdClaim is null || !Guid.TryParse(userIdClaim, out var userId))
+        {
+            logger.LogWarning("User ID claim is missing or invalid.");
+            context.Fail();
+            return;
+        }
+
+        if (!httpContext.Request.RouteValues.TryGetValue("groupId", out var groupIdValue) ||
+            groupIdValue is null || !Guid.TryParse(groupIdValue.ToString(), out var groupId))
+        {
+            logger.LogWarning("Group ID route value is missing or invalid.");
+            context.Fail();
+            return;
+        }
+
+        var userRoleResult = await userInGroupService.GetUserRoleInGroupAsync(userId, groupId, cancellationToken);
+
+        if (!userRoleResult.IsSuccess)
+        {
+            logger.LogWarning("Failed to retrieve user role in group: {Error}", userRoleResult.Error);
+            context.Fail();
+            return;
+        }
+
+        var userRole = userRoleResult.Value;
+
+        if (!requirement.AllowedRoles.Contains(userRole, StringComparer.OrdinalIgnoreCase))
+        {
+            logger.LogWarning(
+                "User {UserId} does not have permission to access this resource.",
+                userId
+            );
+            context.Fail();
+            return;
+        }
+
+        logger.LogInformation(
+            "User {UserId} authorized successfully for this request.",
+            userId
+        );
+
+        context.Succeed(requirement);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/Authorization/GroupRoleRequirement.cs b/Rex.Infrastructure.Shared/Services/Authorization/GroupRoleRequirement.cs
new file mode 100644
index 0000000..56b9764
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/Authorization/GroupRoleRequirement.cs
@@ -0,0 +1,9 @@
+using Microsoft.AspNetCore.Authorization;
+using Rex.Enum;
+
+namespace Rex.Infrastructure.Shared.Services.Authorization;
+
+public class GroupRoleRequirement(params GroupRole[] requiredRoles) : IAuthorizationRequirement
+{
+    public IReadOnlyCollection<string> AllowedRoles { get; } = requiredRoles.Select(r => r.ToString()).ToArray();
+}
diff --git a/Rex.Infrastructure.Shared/Services/CloudinaryService.cs b/Rex.Infrastructure.Shared/Services/CloudinaryService.cs
new file mode 100644
index 0000000..bea5e82
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/CloudinaryService.cs
@@ -0,0 +1,55 @@
+using CloudinaryDotNet;
+using CloudinaryDotNet.Actions;
+using Microsoft.Extensions.Options;
+using Rex.Application.Interfaces;
+using CloudinaryConfiguration = Rex.Configurations.CloudinaryConfiguration;
+
+namespace Rex.Infrastructure.Shared.Services;
+
+public sealed class CloudinaryService(IOptions<CloudinaryConfiguration> cloudinaryOptions): ICloudinaryService
+{
+    private CloudinaryConfiguration _cloudinaryConfiguration { get; } = cloudinaryOptions.Value;
+
+    public async Task<string> UploadArchiveAsync(Stream archive, string imageName, CancellationToken cancellationToken)
+    {
+        Cloudinary cloudinary = new Cloudinary(_cloudinaryConfiguration.CloudinaryUrl);
+        RawUploadParams uploadArchive = new RawUploadParams()
+        {
+            File = new FileDescription(imageName, archive),
+            UseFilename = true,
+            UniqueFilename = false,
+            Overwrite = true
+        };
+        
+        RawUploadResult uploadResult = await cloudinary.UploadAsync(uploadArchive, "raw", cancellationToken);
+        return uploadResult.SecureUrl.ToString();
+    }
+
+    public async Task<string> UploadImageAsync(Stream archive, string imageName, CancellationToken cancellationToken)
+    {
+        var cloudinary = new Cloudinary(_cloudinaryConfiguration.CloudinaryUrl);
+        ImageUploadParams uploadImage = new()
+        {
+            File = new FileDescription(imageName, archive),
+            UseFilename = true,
+            UniqueFilename = false,
+            Overwrite = true
+        };
+        ImageUploadResult uploadResult = await cloudinary.UploadAsync(uploadImage, cancellationToken);
+        return uploadResult.SecureUrl.ToString();
+    }
+    
+    public async Task<string> UploadVideoAsync(Stream archive, string imageName, CancellationToken cancellationToken)
+    {
+        var cloudinary = new Cloudinary(_cloudinaryConfiguration.CloudinaryUrl);
+        VideoUploadParams uploadVideo = new()
+        {
+            File = new FileDescription(imageName, archive),
+            UseFilename = true,
+            UniqueFilename = false,
+            Overwrite = true
+        };
+        VideoUploadResult uploadResult = await cloudinary.UploadAsync(uploadVideo, cancellationToken);
+        return uploadResult.SecureUrl.ToString();
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/EmailService.cs b/Rex.Infrastructure.Shared/Services/EmailService.cs
new file mode 100644
index 0000000..2c10920
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/EmailService.cs
@@ -0,0 +1,40 @@
+using MailKit.Net.Smtp;
+using Microsoft.Extensions.Options;
+using MimeKit;
+using Rex.Application.DTOs.Configs;
+using Rex.Application.Interfaces;
+using Rex.Configurations;
+
+namespace Rex.Infrastructure.Shared.Services;
+
+public class EmailService(IOptions<EmailConfiguration> emailOptions): IEmailService
+{
+    private EmailConfiguration _emailConfiguration { get; } = emailOptions.Value;
+
+    public async Task SendEmailAsync(EmailDto emailAnswer)
+    {
+        try
+        {
+            MimeMessage email = new();
+            email.Sender = MailboxAddress.Parse(_emailConfiguration.EmailFrom);
+            email.To.Add(MailboxAddress.Parse(emailAnswer.User));
+            email.Subject = emailAnswer.Subject;
+            BodyBuilder bodyBuilder = new()
+            {
+                HtmlBody = emailAnswer.Body,
+            };
+            email.Body = bodyBuilder.ToMessageBody();
+
+            using SmtpClient smtp = new();
+            smtp.ServerCertificateValidationCallback = (sender, certificate, chain, errors) => true;
+            await smtp.ConnectAsync(_emailConfiguration.SmtpHost, _emailConfiguration.SmtpPort, MailKit.Security.SecureSocketOptions.StartTls);
+            await smtp.AuthenticateAsync(_emailConfiguration.SmtpUser, _emailConfiguration.SmtpPass);
+            await smtp.SendAsync(email);
+            await smtp.DisconnectAsync(true);
+        }
+        catch (Exception e)
+        {
+            Console.WriteLine(e);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/GithubAuthService.cs b/Rex.Infrastructure.Shared/Services/GithubAuthService.cs
new file mode 100644
index 0000000..3df5a3b
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/GithubAuthService.cs
@@ -0,0 +1,105 @@
+using System.Security.Claims;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Utilities;
+using Rex.Models;
+using UserRole = Rex.Enum.UserRole;
+
+namespace Rex.Infrastructure.Shared.Services;
+
+public class GitHubAuthService(
+    IUserRepository userRepository,
+    IAuthenticationService authenticationService,
+    IUserRoleRepository userRoleRepository
+) : IGithubAuthService
+{
+    public async Task<ResultT<GithubResponseDto>> AuthenticateGitHubUserAsync(
+        ClaimsPrincipal principal,
+        CancellationToken cancellationToken)
+    {
+        var githubId = principal.FindFirst("urn:github:id")?.Value;
+        var email = principal.FindFirst("urn:github:email")?.Value;
+        var username = principal.FindFirst("urn:github:login")?.Value;
+        var name = principal.FindFirst("urn:github:name")?.Value;
+        var avatarUrl = principal.FindFirst("urn:github:avatar")?.Value;
+
+        if (string.IsNullOrEmpty(githubId) || string.IsNullOrEmpty(username))
+        {
+            return ResultT<GithubResponseDto>.Failure(
+                Error.Failure("400", "Could not retrieve GitHub user information")
+            );
+        }
+
+        var existingUser = await userRepository.GetByGitHubIdAsync(githubId, cancellationToken);
+
+        if (existingUser != null)
+        {
+            var existingAccessToken = await authenticationService.GenerateTokenAsync(existingUser, cancellationToken);
+            var existingRefreshToken = await authenticationService.GenerateRefreshTokenAsync(existingUser, cancellationToken);
+
+            return ResultT<GithubResponseDto>.Success(new GithubResponseDto(
+                AccessToken: existingAccessToken,
+                RefreshToken: existingRefreshToken,
+                UserId: existingUser.Id
+            ));
+        }
+
+        if (!string.IsNullOrEmpty(email))
+        {
+            var userWithEmail = await userRepository.GetByEmailAsync(email, cancellationToken);
+            if (userWithEmail != null)
+            {
+                return ResultT<GithubResponseDto>.Failure(
+                    Error.Conflict("409", "An account with this email already exists.")
+                );
+            }
+        }
+
+        var (firstName, lastName) = ParseName(name ?? username);
+        var role = await userRoleRepository.GetRoleByNameAsync(UserRole.User.ToString(), cancellationToken);
+
+        var user = new User
+        {
+            Id = Guid.NewGuid(),
+            GitHubId = githubId,
+            Email = email ?? $"{username}@github.local",
+            UserName = username,
+            FirstName = firstName,
+            LastName = lastName,
+            ProfilePhoto = avatarUrl,
+            CreatedAt = DateTime.UtcNow,
+            LastLoginAt = DateTime.UtcNow,
+            LastConnection = DateTime.UtcNow,
+            ConfirmedAccount = !string.IsNullOrEmpty(email),
+            Password = null,
+            RoleId = role.Id
+        };
+
+        await userRepository.CreateAsync(user, cancellationToken);
+
+        var accessToken = await authenticationService.GenerateTokenAsync(user, cancellationToken);
+        var refreshToken = await authenticationService.GenerateRefreshTokenAsync(user, cancellationToken);
+
+        return ResultT<GithubResponseDto>.Success(new GithubResponseDto(
+            AccessToken: accessToken,
+            RefreshToken: refreshToken,
+            UserId: user.Id
+        ));
+    }
+
+    private static (string FirstName, string LastName) ParseName(string fullName)
+    {
+        if (string.IsNullOrWhiteSpace(fullName))
+            return (string.Empty, string.Empty);
+
+        var nameParts = fullName.Trim().Split(' ', 2, StringSplitOptions.RemoveEmptyEntries);
+        
+        return nameParts.Length switch
+        {
+            0 => (string.Empty, string.Empty),
+            1 => (nameParts[0], string.Empty),
+            _ => (nameParts[0], nameParts[1])
+        };
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/SignalR/AppConnectionService.cs b/Rex.Infrastructure.Shared/Services/SignalR/AppConnectionService.cs
new file mode 100644
index 0000000..7e238bd
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/SignalR/AppConnectionService.cs
@@ -0,0 +1,68 @@
+using Microsoft.AspNetCore.SignalR;
+using Microsoft.Extensions.Logging;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+
+namespace Rex.Infrastructure.Shared.Services.SignalR;
+
+public class AppConnectionService(
+    ILogger<AppConnectionService> logger,
+    IUserChatRepository userChatRepository,
+    IUserRepository userRepository
+) : IAppConnectionService
+{
+    public async Task HandleConnectedAsync(HubCallerContext context, IGroupManager groups)
+    {
+        var userId = GetUserIdFromClaims(context);
+        if (userId is null)
+        {
+            logger.LogWarning("User attempted to connect but no valid user ID was found.");
+            context.Abort();
+            return;
+        }
+        
+        await groups.AddToGroupAsync(context.ConnectionId, userId.Value.ToString());
+        logger.LogInformation("User {UserId} connected with ConnectionId {ConnectionId}", userId, context.ConnectionId);
+
+        var chats = await userChatRepository.GetUserChatsAsync(userId.Value, CancellationToken.None);
+        logger.LogInformation("User {UserId} has access to {ChatCount} chats", userId.Value, chats.Count);
+
+        var user = await userRepository.GetByIdAsync(userId.Value, CancellationToken.None);
+        if (user is not null)
+        {
+            user.IsActive = true;
+            await userRepository.UpdateAsync(user, CancellationToken.None);
+            logger.LogInformation("User {UserId} marked as active", user.Id);
+        }
+
+        foreach (var chatId in chats)
+        {
+            await groups.AddToGroupAsync(context.ConnectionId, chatId.ToString());
+            logger.LogDebug("User {UserId} added to chat group {ChatId}", userId.Value, chatId);
+        }
+
+        logger.LogInformation("User {UserId} fully connected", userId.Value);
+    }
+
+    public async Task HandleDisconnectedAsync(HubCallerContext context)
+    {
+        var userId = GetUserIdFromClaims(context);
+        if (userId is null) return;
+
+        var user = await userRepository.GetByIdAsync(userId.Value, CancellationToken.None);
+        if (user is not null)
+        {
+            user.IsActive = false;
+            user.LastConnection = DateTime.UtcNow;
+            await userRepository.UpdateAsync(user, CancellationToken.None);
+            logger.LogInformation("User {UserId} disconnected", user.Id);
+        }
+    }
+
+    private Guid? GetUserIdFromClaims(HubCallerContext context)
+    {
+        var claim = context.User?.FindFirst(System.Security.Claims.ClaimTypes.NameIdentifier);
+        if (claim is null) return null;
+        return Guid.TryParse(claim.Value, out var id) ? id : null;
+    }
+}
diff --git a/Rex.Infrastructure.Shared/Services/SignalR/ChallengeNotifier.cs b/Rex.Infrastructure.Shared/Services/SignalR/ChallengeNotifier.cs
new file mode 100644
index 0000000..1734136
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/SignalR/ChallengeNotifier.cs
@@ -0,0 +1,34 @@
+using Microsoft.AspNetCore.SignalR;
+using Rex.Application.DTOs.Notification;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Infrastructure.Shared.Services.SignalR.Hubs;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Shared.Services.SignalR;
+
+public class ChallengeNotifier(
+    IHubContext<AppHub, IAppHub> hubContext,
+    INotificationRepository notificationRepository
+) : IChallengeNotifier
+{
+    public async Task SendChallengeNotification(Notification notificationChallenge, CancellationToken cancellationToken)
+    {
+        await notificationRepository.CreateAsync(notificationChallenge, cancellationToken);
+
+        var notificationDto = new NotificationDto(
+            Id: notificationChallenge.Id,
+            Title: notificationChallenge.Title,
+            Description: notificationChallenge.Description,
+            UserId: notificationChallenge.UserId,
+            RecipientType: notificationChallenge.RecipientType,
+            RecipientId: notificationChallenge.RecipientId,
+            MetadataJson: notificationChallenge.MetadataJson,
+            CreatedAt: notificationChallenge.CreatedAt,
+            IsRead: notificationChallenge.Read
+        );
+
+        await hubContext.Clients.Group(notificationChallenge.RecipientId.ToString())
+            .ReceiveFriendRequestNotification(notificationDto);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/SignalR/ChatNotifier.cs b/Rex.Infrastructure.Shared/Services/SignalR/ChatNotifier.cs
new file mode 100644
index 0000000..fdb7a80
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/SignalR/ChatNotifier.cs
@@ -0,0 +1,32 @@
+using Microsoft.AspNetCore.SignalR;
+using Rex.Application.DTOs.Challenge;
+using Rex.Application.DTOs.Message;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Infrastructure.Shared.Services.SignalR.Hubs;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Shared.Services.SignalR;
+
+public class ChatNotifier(
+    IHubContext<AppHub, IAppHub> hubContext,
+    IUserChatRepository userChatRepository
+) : IChatNotifier
+{
+    public async Task NotifyChatCreatedAsync(IEnumerable<Guid> userIds, Chat chat, CancellationToken cancellationToken)
+    {
+        foreach (var userId in userIds)
+        {
+            var otherUser = await userChatRepository.GetOtherUserInChatAsync(chat.Id, userId, cancellationToken);
+            var chatDto = new ChatDto(chat.Id, otherUser.FirstName + " " + otherUser.LastName, chat.Type,
+                otherUser.ProfilePhoto);
+            await hubContext.Clients.User(userId.ToString()).ReceiveChatCreated(chatDto);
+        }
+    }
+
+    public async Task NotifyMessageAsync(Guid chatId, MessageDto message)
+    {
+        await hubContext.Clients.Group(chatId.ToString())
+            .ReceiveMessage(message);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/SignalR/CommentsNotifier.cs b/Rex.Infrastructure.Shared/Services/SignalR/CommentsNotifier.cs
new file mode 100644
index 0000000..077da71
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/SignalR/CommentsNotifier.cs
@@ -0,0 +1,54 @@
+using Microsoft.AspNetCore.SignalR;
+using Rex.Application.DTOs.Notification;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Infrastructure.Shared.Services.SignalR.Hubs;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Shared.Services.SignalR;
+
+public class CommentsNotifier(
+    IHubContext<AppHub, IAppHub> hubContext,
+    INotificationRepository notificationRepository
+) : ICommentsNotifier
+{
+    public async Task SendCommentNotification(Notification notificationComment, CancellationToken cancellationToken)
+    {
+        await notificationRepository.CreateAsync(notificationComment, cancellationToken);
+
+        var notificationDto = new NotificationDto(
+            Id: notificationComment.Id,
+            Title: notificationComment.Title,
+            Description: notificationComment.Description,
+            UserId: notificationComment.UserId,
+            RecipientType: notificationComment.RecipientType,
+            RecipientId: notificationComment.RecipientId,
+            MetadataJson: notificationComment.MetadataJson,
+            CreatedAt: notificationComment.CreatedAt,
+            IsRead: notificationComment.Read
+        );
+
+        await hubContext.Clients.User(notificationComment.RecipientId.ToString())
+            .ReceiveCommentNotification(notificationDto);
+    }
+
+    public async Task SendReplyNotification(Notification notificationReply, CancellationToken cancellationToken)
+    {
+        await notificationRepository.CreateAsync(notificationReply, cancellationToken);
+    
+        var notificationDto = new NotificationDto(
+            Id: notificationReply.Id,
+            Title: notificationReply.Title,
+            Description: notificationReply.Description,
+            UserId: notificationReply.UserId,
+            RecipientType: notificationReply.RecipientType,
+            RecipientId: notificationReply.RecipientId, 
+            MetadataJson: notificationReply.MetadataJson,
+            CreatedAt: notificationReply.CreatedAt,
+            IsRead: notificationReply.Read
+        );
+
+        await hubContext.Clients.User(notificationDto.RecipientId.ToString())
+            .ReceiveReplyNotification(notificationDto);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/SignalR/FriendshipNotifier.cs b/Rex.Infrastructure.Shared/Services/SignalR/FriendshipNotifier.cs
new file mode 100644
index 0000000..843c1d2
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/SignalR/FriendshipNotifier.cs
@@ -0,0 +1,34 @@
+using Microsoft.AspNetCore.SignalR;
+using Rex.Application.DTOs.Notification;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Infrastructure.Shared.Services.SignalR.Hubs;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Shared.Services.SignalR;
+
+public class FriendshipNotifier(
+    IHubContext<AppHub, IAppHub> hubContext,
+    INotificationRepository notificationRepository
+    ): IFriendshipNotifier
+{
+    public async Task SendFriendRequestNotification(Notification notification, CancellationToken cancellationToken)
+    {
+        await notificationRepository.CreateAsync(notification, cancellationToken);
+
+        var notificationDto = new NotificationDto(
+            Id: notification.Id,
+            Title: notification.Title,
+            Description: notification.Description,
+            UserId: notification.UserId,
+            RecipientType: notification.RecipientType,
+            RecipientId: notification.RecipientId,
+            MetadataJson: notification.MetadataJson,
+            CreatedAt: notification.CreatedAt,
+            IsRead: notification.Read
+        );
+
+        await hubContext.Clients.User(notification.RecipientId.ToString())
+            .ReceiveFriendRequestNotification(notificationDto);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/SignalR/Hubs/AppHub.cs b/Rex.Infrastructure.Shared/Services/SignalR/Hubs/AppHub.cs
new file mode 100644
index 0000000..f9a5716
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/SignalR/Hubs/AppHub.cs
@@ -0,0 +1,93 @@
+using MediatR;
+using Microsoft.AspNetCore.SignalR;
+using Rex.Application.Helpers;
+using Rex.Application.Interfaces;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Application.Modules.Chats.Commands.CreatePrivateChat;
+using Rex.Application.Modules.Friendships.Commands;
+using Rex.Application.Modules.Friendships.Commands.CreateRequestFriendship;
+using Rex.Application.Modules.Messages.Commands.SendMessage;
+using Rex.Application.Modules.Reactions.Commands.AddLike;
+using Rex.Application.Modules.Reactions.Commands.RemoveLike;
+using Rex.Enum;
+
+namespace Rex.Infrastructure.Shared.Services.SignalR.Hubs;
+
+public class AppHub(
+    IAppConnectionService connectionService,
+    IUserClaimService userClaimService,
+    IMediator mediator) : Hub<IAppHub>
+{
+    public override async Task OnConnectedAsync()
+        => await connectionService.HandleConnectedAsync(Context, Groups);
+
+    public override async Task OnDisconnectedAsync(Exception? exception)
+        => await connectionService.HandleDisconnectedAsync(Context);
+
+    public async Task JoinPostGroup(Guid postId)
+    {
+        await Groups.AddToGroupAsync(Context.ConnectionId, postId.ToString());
+    }
+
+    public async Task LeavePostGroup(Guid postId)
+    {
+        await Groups.RemoveFromGroupAsync(Context.ConnectionId, postId.ToString());
+    }
+
+    public async Task SendMessage(Guid chatId, string message)
+    {
+        var userId = userClaimService.GetUserId(Context.User);
+        var result = await mediator.Send(new SendMessageCommand(chatId, message, userId));
+
+        if (!result.IsSuccess)
+        {
+            await Clients.Caller.ReceiveError(result.Error!.Description);
+        }
+    }
+
+    public async Task CreatePrivateChat(Guid otherUserId)
+    {
+        var userId = userClaimService.GetUserId(Context.User);
+        var result = await mediator.Send(new CreatePrivateChatCommand(userId, otherUserId));
+
+        if (!result.IsSuccess)
+        {
+            await Clients.Caller.ReceiveError(result.Error!.Description);
+        }
+    }
+
+    public async Task CreateFriendshipRequest(Guid otherUserId)
+    {
+        var userId = userClaimService.GetUserId(Context.User);
+        
+        var result = await mediator.Send(new CreateFriendshipRequestCommand(userId, otherUserId));
+        if (!result.IsSuccess)
+        {
+            await Clients.Caller.ReceiveError(result.Error!.Description);
+        }
+    }
+
+    public async Task AddLike(Guid postId)
+    {
+        var userId = userClaimService.GetUserId(Context.User);
+
+        var result = await mediator.Send(new AddLikeCommand(userId, postId, ReactionTargetType.Post));
+
+        if (!result.IsSuccess)
+        {
+            await Clients.Caller.ReceiveError(result.Error!.Description);
+        }
+    }
+
+    public async Task RemoveLike(Guid postId)
+    {
+        var userId = userClaimService.GetUserId(Context.User);
+
+        var result = await mediator.Send(new RemoveLikeCommand(userId, postId, ReactionTargetType.Post));
+
+        if (!result.IsSuccess)
+        {
+            await Clients.Caller.ReceiveError(result.Error!.Description);
+        }
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/SignalR/InactiveUserNotifier.cs b/Rex.Infrastructure.Shared/Services/SignalR/InactiveUserNotifier.cs
new file mode 100644
index 0000000..b77b338
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/SignalR/InactiveUserNotifier.cs
@@ -0,0 +1,54 @@
+using Microsoft.AspNetCore.SignalR;
+using Rex.Application.DTOs.Notification;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Infrastructure.Shared.Services.SignalR.Hubs;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Shared.Services.SignalR;
+
+public class InactiveUserNotifier(
+    IHubContext<AppHub, IAppHub> hubContext,
+    INotificationRepository notificationRepository
+) : IInactiveUserNotifier
+{
+    public async Task SendWarnNotification(Notification notification, CancellationToken cancellationToken)
+    {
+        await notificationRepository.CreateAsync(notification, cancellationToken);
+
+        var notificationDto = new NotificationDto(
+            Id: notification.Id,
+            Title: notification.Title,
+            Description: notification.Description,
+            UserId: notification.UserId,
+            RecipientType: notification.RecipientType,
+            RecipientId: notification.RecipientId,
+            MetadataJson: notification.MetadataJson,
+            CreatedAt: notification.CreatedAt,
+            IsRead: notification.Read
+        );
+
+        await hubContext.Clients.User(notificationDto.RecipientId.ToString())
+            .ReceiveWarnNotification(notificationDto);
+    }
+
+    public async Task SendBanNotification(Notification notification, CancellationToken cancellationToken)
+    {
+        await notificationRepository.CreateAsync(notification, cancellationToken);
+
+        var notificationDto = new NotificationDto(
+            Id: notification.Id,
+            Title: notification.Title,
+            Description: notification.Description,
+            UserId: notification.UserId,
+            RecipientType: notification.RecipientType,
+            RecipientId: notification.RecipientId,
+            MetadataJson: notification.MetadataJson,
+            CreatedAt: notification.CreatedAt,
+            IsRead: notification.Read
+        );
+
+        await hubContext.Clients.User(notificationDto.RecipientId.ToString())
+            .ReceiveRemoveNotification(notificationDto);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/SignalR/ReactionNotifier.cs b/Rex.Infrastructure.Shared/Services/SignalR/ReactionNotifier.cs
new file mode 100644
index 0000000..73d4377
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/SignalR/ReactionNotifier.cs
@@ -0,0 +1,41 @@
+using Microsoft.AspNetCore.SignalR;
+using Rex.Application.DTOs.Notification;
+using Rex.Application.DTOs.Reaction;
+using Rex.Application.Interfaces.Repository;
+using Rex.Application.Interfaces.SignalR;
+using Rex.Infrastructure.Shared.Services.SignalR.Hubs;
+using Rex.Models;
+
+namespace Rex.Infrastructure.Shared.Services.SignalR;
+
+public class ReactionNotifier(
+    IHubContext<AppHub, IAppHub> hubContext,
+    INotificationRepository notificationRepository
+) : IReactionNotifier
+{
+    public async Task ReactionPostNotificationAsync(Notification notification, CancellationToken cancellationToken)
+    {
+        await notificationRepository.CreateAsync(notification, cancellationToken);
+
+        var notificationDto = new NotificationDto(
+            Id: notification.Id,
+            Title: notification.Title,
+            Description: notification.Description,
+            UserId: notification.UserId,
+            RecipientType: notification.RecipientType,
+            RecipientId: notification.RecipientId,
+            MetadataJson: notification.MetadataJson,
+            CreatedAt: notification.CreatedAt,
+            IsRead: notification.Read
+        );
+
+        await hubContext.Clients.User(notificationDto.RecipientId.ToString())
+            .ReceiveReactionNotification(notificationDto);
+    }
+    
+    public async Task LikeChangedNotificationAsync(LikeChangedDto dto, CancellationToken cancellationToken)
+    {
+        await hubContext.Clients.Group(dto.PostId.ToString()).ReceiveLikeUpdate(dto);
+        
+    }
+}
\ No newline at end of file
diff --git a/Rex.Infrastructure.Shared/Services/UserClaimService.cs b/Rex.Infrastructure.Shared/Services/UserClaimService.cs
new file mode 100644
index 0000000..1f793d5
--- /dev/null
+++ b/Rex.Infrastructure.Shared/Services/UserClaimService.cs
@@ -0,0 +1,20 @@
+using System.Security.Claims;
+using Rex.Application.Interfaces;
+
+namespace Rex.Infrastructure.Shared.Services;
+
+public class UserClaimService(): IUserClaimService
+{
+    public Guid GetUserId(ClaimsPrincipal user)
+    {
+        if (user == null)
+            throw new UnauthorizedAccessException("You are not authenticated. Please log in.");
+
+        var claim = user.FindFirst(ClaimTypes.NameIdentifier);
+
+        if (claim is null || !Guid.TryParse(claim.Value, out var id))
+            throw new UnauthorizedAccessException("Unable to identify your user. Please try logging in again.");
+
+        return id;
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Controllers/AuthController.cs b/Rex.Presentation.Api/Controllers/AuthController.cs
new file mode 100644
index 0000000..4301977
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/AuthController.cs
@@ -0,0 +1,100 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Authentication;
+using Microsoft.AspNetCore.Mvc;
+using Swashbuckle.AspNetCore.Annotations;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.User.Commands.Login;
+using Rex.Application.Utilities;
+using IAuthenticationService = Rex.Application.Interfaces.IAuthenticationService;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiController]
+[ApiVersion("1.0")]
+[Route("api/v{version:apiVersion}/auth")]
+public class AuthController(
+    IMediator mediator,
+    IAuthenticationService authenticationService,
+    IGithubAuthService gitHubAuthService
+    ): ControllerBase
+{
+    [HttpPost]
+    [SwaggerOperation(
+        Summary = "Login user",
+        Description = "Authenticates a user and returns a token if the credentials are correct."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<TokenResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<TokenResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status403Forbidden, Type = typeof(ResultT<TokenResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<TokenResponseDto>))]
+    public async Task<ResultT<TokenResponseDto>> LoginAsync([FromBody] LoginCommand command,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(command, cancellationToken);
+    }
+
+    [HttpPost("refresh-token")]
+    [SwaggerOperation(
+        Summary = "Refresh authentication token",
+        Description = "Refreshes the JWT token using the provided refresh token."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<TokenResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status401Unauthorized, Type = typeof(ResultT<TokenResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<TokenResponseDto>))]
+    public async Task<ResultT<TokenResponseDto>> RefreshTokenAsync([FromBody] RefreshTokenDto refreshToken,
+        CancellationToken cancellationToken)
+    {
+        return await authenticationService.RefreshTokenAsync(refreshToken.refreshToken, cancellationToken);
+    }
+
+    [HttpGet("github-login")]
+    [SwaggerOperation(
+        Summary = "Login with GitHub",
+        Description = "Redirects the user to the GitHub authentication page for OAuth login."
+    )]
+    [ProducesResponseType(StatusCodes.Status302Found)]
+    [ProducesResponseType(StatusCodes.Status400BadRequest)]
+    public IActionResult Login(string returnUrl)
+    {
+        var properties = new AuthenticationProperties
+        {
+            RedirectUri = Url.Action(nameof(Callback), new { returnUrl }),
+            Items = { { "scheme", "GitHub" } }
+        };
+
+        return Challenge(properties, "GitHub");
+    }
+
+    [HttpGet("callback")]
+    [SwaggerOperation(
+        Summary = "GitHub authentication callback",
+        Description = "Handles the GitHub OAuth callback, verifies authentication, and redirects the user with the generated tokens."
+    )]
+    [ProducesResponseType(StatusCodes.Status302Found)]
+    [ProducesResponseType(StatusCodes.Status400BadRequest)]
+    [ProducesResponseType(StatusCodes.Status401Unauthorized)]
+    public async Task<IActionResult> Callback(string returnUrl, CancellationToken cancellationToken = default)
+    {
+        var authenticateResult = await HttpContext.AuthenticateAsync("GitHub");
+
+        if (!authenticateResult.Succeeded)
+        {
+            return BadRequest(new { error = "GitHub authentication failed" });
+        }
+
+        var result = await gitHubAuthService.AuthenticateGitHubUserAsync(
+            authenticateResult.Principal!,
+            cancellationToken
+        );
+
+        if (!result.IsSuccess)
+        {
+            return BadRequest(new { error = result.Error });
+        }
+
+        var redirectUrl = $"{returnUrl}?accessToken={result.Value!.AccessToken}&refreshToken={result.Value.RefreshToken}&userId={result.Value.UserId}";
+        return Redirect(redirectUrl);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Controllers/ChallengesController.cs b/Rex.Presentation.Api/Controllers/ChallengesController.cs
new file mode 100644
index 0000000..39a4785
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/ChallengesController.cs
@@ -0,0 +1,137 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+using Rex.Application.DTOs.Challenge;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.Challenges.Commands.DeleteChallenge;
+using Rex.Application.Modules.Challenges.Commands.JoinChallenge;
+using Rex.Application.Modules.Challenges.Commands.UpdateChallenge;
+using Rex.Application.Modules.Challenges.CreateChallenge;
+using Rex.Application.Modules.Challenges.Queries.GetChallengesByStatus;
+using Rex.Application.Modules.Challenges.Queries.GetChallengesByUser;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Swashbuckle.AspNetCore.Annotations;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiController]
+[ApiVersion("1.0")]
+[Authorize]
+[Route("api/v{version:apiVersion}/[controller]")]
+public class ChallengesController(IMediator mediator, IUserClaimService userClaimService) : ControllerBase
+{
+    [Authorize(Policy = "StaffOnly")]
+    [HttpPost("groups/{groupId}")]
+    [SwaggerOperation(
+        Summary = "Create a new challenge",
+        Description = "Creates a new challenge with the provided data"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> CreateChallengeAsync(
+        [FromRoute] Guid groupId,
+        [FromForm] CreateChallengeDto createChallenge,
+        CancellationToken cancellation)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(
+            new CreateChallengeCommand(userId, groupId, createChallenge.Title,
+                createChallenge.Description, createChallenge.Duration, createChallenge.CoverPhoto), cancellation);
+    }
+
+    [HttpGet("groups/{groupId}/status/{status}")]
+    [SwaggerOperation(
+        Summary = "Get challenges by status",
+        Description = "Returns the challenges of a group filtered by status"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<ChallengeGroupDetailsDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<ChallengeGroupDetailsDto>>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<PagedResult<ChallengeGroupDetailsDto>>))]
+    public async Task<ResultT<PagedResult<ChallengeGroupDetailsDto>>> GetChallengesByStatusAsync(
+        [FromRoute] Guid groupId,
+        [FromRoute] ChallengeStatus status,
+        [FromQuery] int pageNumber,
+        [FromQuery] int pageSize,
+        CancellationToken cancellation)
+    {
+        return await mediator.Send(new GetChallengesByStatusQuery(groupId, status, pageNumber, pageSize), cancellation);
+    }
+
+    [HttpPost("challenges/{challengeId}/join")]
+    [SwaggerOperation(
+        Summary = "Join a challenge",
+        Description = "Allows the authenticated user to join an existing challenge"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> JoinChallengeAsync(
+        [FromRoute] Guid challengeId,
+        CancellationToken cancellation)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new JoinChallengeCommand(challengeId, userId), cancellation);
+    }
+
+    [Authorize(Policy = "StaffOnly")]
+    [HttpPut("groups/{groupId}/challenges/{challengeId}")]
+    [SwaggerOperation(
+        Summary = "Update a challenge",
+        Description = "Updates the information of an existing challenge"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> UpdateChallengeAsync(
+        [FromRoute] Guid groupId,
+        [FromRoute] Guid challengeId,
+        [FromForm] UpdateChallengeDto dto,
+        CancellationToken cancellation)
+    {
+        var command = new UpdateChallengeCommand(groupId, challengeId, dto.Title, dto.Description, dto.Duration,
+            dto.Status);
+        return await mediator.Send(command, cancellation);
+    }
+
+    [HttpGet("user")]
+    [SwaggerOperation(
+        Summary = "Get challenges of the authenticated user",
+        Description = "Returns the challenges associated with the authenticated user filtered by status"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<ChallengeUserDetailsDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<ChallengeUserDetailsDto>>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<PagedResult<ChallengeUserDetailsDto>>))]
+    public async Task<ResultT<PagedResult<ChallengeUserDetailsDto>>> GetChallengesByUserAsync(
+        [FromQuery] UserChallengeStatus status,
+        [FromQuery] int pageNumber,
+        [FromQuery] int pageSize,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new GetChallengesByUserQuery(userId, status, pageNumber, pageSize),
+            cancellationToken);
+    }
+
+    [Authorize(Policy = "StaffOnly")]
+    [HttpDelete("groups/{groupId}/challenges/{challengeId}")]
+    [SwaggerOperation(
+        Summary = "Delete a challenge",
+        Description = "Deletes a challenge if the authenticated user is authorized"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status403Forbidden, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> DeleteChallengeAsync(
+        [FromRoute] Guid groupId,
+        [FromRoute] Guid challengeId,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new DeleteChallengeCommand(challengeId, groupId, userId), cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Controllers/ChatsController.cs b/Rex.Presentation.Api/Controllers/ChatsController.cs
new file mode 100644
index 0000000..cc4c615
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/ChatsController.cs
@@ -0,0 +1,37 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+using Rex.Application.DTOs.Challenge;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.Chats.Queries.GetChatsByUserId;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Swashbuckle.AspNetCore.Annotations;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiVersion("1.0")]
+[ApiController]
+[Authorize]
+[Route("api/v{version:apiVersion}/[controller]")]
+public class ChatsController(IMediator mediator, IUserClaimService userClaimService) : ControllerBase
+{
+    [HttpGet] 
+    [SwaggerOperation(
+        Summary = "Get user chats",
+        Description = "Retrieves a paginated list of chats for the authenticated user, optionally filtered by a search term."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<ChatLastMessageDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<ChatLastMessageDto>>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<PagedResult<ChatLastMessageDto>>))]
+    public async Task<ResultT<PagedResult<ChatLastMessageDto>>> GetChats(
+        [FromQuery] int page,
+        [FromQuery] int pageSize,
+        [FromQuery] string? searchTerm = null,
+        CancellationToken cancellationToken = default)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new GetChatsByUserIdQuery(userId, page, pageSize, searchTerm), cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Controllers/CommentsController.cs b/Rex.Presentation.Api/Controllers/CommentsController.cs
new file mode 100644
index 0000000..30b584b
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/CommentsController.cs
@@ -0,0 +1,125 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+using Rex.Application.DTOs.Comment;
+using Rex.Application.DTOs.Reply;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.Comments.Commands.CreateComment;
+using Rex.Application.Modules.Comments.Commands.CreateCommentReply;
+using Rex.Application.Modules.Comments.Commands.PinComment;
+using Rex.Application.Modules.Comments.Commands.UpdateComment;
+using Rex.Application.Modules.Comments.Queries.GetCommentReplies;
+using Rex.Application.Modules.Comments.Queries.GetCommentsByPostId;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Swashbuckle.AspNetCore.Annotations;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiController]
+[ApiVersion("1.0")]
+[Authorize]
+[Route("api/v{version:apiVersion}/[controller]")]
+public class CommentsController(IMediator mediator, IUserClaimService userClaimService) : ControllerBase
+{
+    [HttpGet("post/{postId}")]
+    [SwaggerOperation(
+        Summary = "Get paginated comments by post ID",
+        Description = "Returns paginated comments for a given post, including first reply if any"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<CommentDetailsDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<CommentDetailsDto>>))]
+    public async Task<ResultT<PagedResult<CommentDetailsDto>>> GetCommentsByPostIdAsync(
+        [FromRoute] Guid postId, [FromQuery] int pageNumber, [FromQuery] int pageSize,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(new GetCommentsByPostIdQuery(postId, pageNumber, pageSize), cancellationToken);
+    }
+
+    [HttpPost]
+    [SwaggerOperation(
+        Summary = "Create a new comment",
+        Description = "Creates a new comment for a specific post by a user"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<CommentDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<CommentDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<CommentDto>))]
+    public async Task<ResultT<CommentDto>> CreateCommentAsync(
+        [FromForm] CreateCommentDto createComment,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(
+            new CreateCommentCommand(createComment.PostId, userId, createComment.Description, createComment.Files),
+            cancellationToken);
+    }
+
+    [HttpPost("reply")]
+    [SwaggerOperation(
+        Summary = "Create a new reply to a comment",
+        Description = "Creates a new reply for a specific parent comment"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ReplyDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ReplyDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ReplyDto>))]
+    public async Task<ResultT<ReplyDto>> CreateCommentReplyAsync(
+        [FromForm] CreateCommentReplyDto createCommentReply,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(
+            new CreateCommentReplyCommand(createCommentReply.ParentCommentId, createCommentReply.PostId, userId,
+                createCommentReply.Description, createCommentReply.Files), cancellationToken);
+    }
+
+    [HttpGet("replies/{parentCommentId}")]
+    [SwaggerOperation(
+        Summary = "Get replies for a specific comment",
+        Description = "Returns paginated replies for a specific parent comment in a post"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<ReplyDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<ReplyDto>>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<PagedResult<ReplyDto>>))]
+    public async Task<ResultT<PagedResult<ReplyDto>>> GetRepliesByCommentIdAsync(
+        [FromRoute] Guid parentCommentId, [FromQuery] Guid postId,
+        [FromQuery] int pageNumber, [FromQuery] int pageSize,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(
+            new GetCommentRepliesQuery(postId, parentCommentId, pageNumber, pageSize),
+            cancellationToken
+        );
+    }
+
+    [HttpPost("pin")]
+    [SwaggerOperation(
+        Summary = "Pin or unpin a comment",
+        Description = "Pins or unpins a comment on a specific post by a user. Requires post ownership."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<CommentUpdatedDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<CommentUpdatedDto>))]
+    [ProducesResponseType(StatusCodes.Status401Unauthorized, Type = typeof(ResultT<CommentUpdatedDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<CommentUpdatedDto>))]
+    public async Task<ActionResult<ResultT<CommentUpdatedDto>>> PinCommentAsync(
+        [FromBody] PinCommentDto pinComment, CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return Ok(await mediator.Send(
+            new PinCommentCommand(pinComment.CommentId, userId, pinComment.PostId, pinComment.Pin), cancellationToken));
+    }
+
+    [HttpPut]
+    [SwaggerOperation(
+        Summary = "Update an existing comment",
+        Description = "Update the description of a comment in a post."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<CommentUpdatedDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<CommentUpdatedDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<CommentUpdatedDto>))]
+    public async Task<ActionResult<ResultT<CommentUpdatedDto>>> UpdateCommentAsync(
+        [FromForm] UpdateCommentCommand command, CancellationToken cancellationToken)
+    {
+        return Ok(await mediator.Send(command, cancellationToken));
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Controllers/FriendshipsController.cs b/Rex.Presentation.Api/Controllers/FriendshipsController.cs
new file mode 100644
index 0000000..514cb38
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/FriendshipsController.cs
@@ -0,0 +1,75 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+using Rex.Application.DTOs.Friendship;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.Friendships.Commands;
+using Rex.Application.Modules.Friendships.Commands.DeleteFriendship;
+using Rex.Application.Modules.Friendships.Commands.ManageFriendshipRequest;
+using Rex.Application.Modules.Friendships.Queries.GetFriendshipsRequest;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Swashbuckle.AspNetCore.Annotations;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiVersion("1.0")]
+[ApiController]
+[Authorize]
+[Route("api/v{version:apiVersion}/[controller]")]
+public class FriendshipsController(IMediator mediator, IUserClaimService userClaimService) : ControllerBase
+{
+    [HttpPut("{targetUserId}/status")]
+    [SwaggerOperation(
+        Summary = "Manage friendship request",
+        Description = "Accept or reject a friendship request"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status409Conflict, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> ManageFriendshipRequest(
+        [FromRoute] Guid targetUserId,
+        [FromBody] UpdateFriendshipStatusDto dto,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new ManageFriendshipRequestCommand(userId, targetUserId, dto.Status),
+            cancellationToken);
+    }
+
+    [HttpGet("requests")]
+    [SwaggerOperation(
+        Summary = "Get friendship requests by user",
+        Description = "Retrieves a paginated list of friendship requests received by the specified user."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<FriendshipRequestDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<FriendshipRequestDto>>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<PagedResult<FriendshipRequestDto>>))]
+    public async Task<ResultT<PagedResult<FriendshipRequestDto>>> GetFriendshipRequests(
+        [FromQuery] int pageNumber, [FromQuery] int pageSize,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new GetFriendshipsRequestQuery(userId, pageNumber, pageSize), cancellationToken);
+    }
+
+    [HttpDelete("{targetUserId}")]
+    [SwaggerOperation(
+        Summary = "Delete a friendship",
+        Description =
+            "Deletes a friendship between the authenticated user and the specified target user and deactivates the associated chat"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> DeleteFriendship([FromRoute] Guid targetUserId,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new DeleteFriendshipCommand(userId, targetUserId), cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Controllers/GroupsController.cs b/Rex.Presentation.Api/Controllers/GroupsController.cs
new file mode 100644
index 0000000..b94c131
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/GroupsController.cs
@@ -0,0 +1,213 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+using Rex.Application.DTOs.Group;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.DTOs.User;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.Groups.Commands;
+using Rex.Application.Modules.Groups.Commands.DeleteGroup;
+using Rex.Application.Modules.Groups.Commands.GroupUserModeration;
+using Rex.Application.Modules.Groups.Commands.ManageRequest;
+using Rex.Application.Modules.Groups.Commands.RequestToJoinGroupCommand;
+using Rex.Application.Modules.Groups.Commands.UpdateGroup;
+using Rex.Application.Modules.Groups.Commands.UpdateGroupRoleMember;
+using Rex.Application.Modules.Groups.Queries.GetGroupById;
+using Rex.Application.Modules.Groups.Queries.GetGroupJoinRequests;
+using Rex.Application.Modules.Groups.Queries.GetGroupMembers;
+using Rex.Application.Modules.Groups.Queries.GetGroupsByUserId;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Swashbuckle.AspNetCore.Annotations;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiController]
+[ApiVersion("1.0")]
+[Authorize]
+[Route("api/v{version:apiVersion}/groups")]
+public class GroupsController(IMediator mediator, IUserClaimService userClaimService) : ControllerBase
+{
+    [HttpPost]
+    [SwaggerOperation(
+        Summary = "Create a new group",
+        Description = "Creates a new group with the provided data"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResponseDto))]
+    public async Task<ResultT<ResponseDto>> CreateGroupsAsync([FromForm] CreateGroupDto createGroup,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(
+            new CreateGroupCommand(userId, createGroup.ProfilePhoto, createGroup.CoverPhoto, createGroup.Title,
+                createGroup.Description, createGroup.Visibility), cancellationToken);
+    }
+
+    [HttpGet("{groupId}/membership")]
+    [SwaggerOperation(
+        Summary = "Get group by ID",
+        Description = "Returns detailed information of a group for a specific user"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(GroupDetailsDto))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResponseDto))]
+    public async Task<ResultT<GroupDetailsDto>> GetGroupById([FromRoute] Guid groupId,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new GetGroupByGroupIdQuery(groupId, userId), cancellationToken);
+    }
+
+    [HttpGet("my-groups")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(PagedResult<GroupDetailsDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(GroupDetailsDto))]
+    public async Task<ResultT<PagedResult<GroupDetailsDto>>> GetGroupsByUserId(
+        [FromQuery] int pageNumber,
+        [FromQuery] int pageSize,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new GetGroupsByUserIdQuery(userId, pageNumber, pageSize), cancellationToken);
+    }
+
+    [Authorize("LeaderOrModerator")]
+    [HttpPut("{groupId}")]
+    [SwaggerOperation(
+        Summary = "Update group information",
+        Description = "Updates information of an existing group"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResponseDto))]
+    public async Task<ResultT<ResponseDto>> UpdateGroupInformation([FromRoute] Guid groupId,
+        [FromForm] UpdateGroupDto updateGroupDto,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(
+            new UpdateGroupCommand(groupId, updateGroupDto.ProfilePhoto, updateGroupDto.CoverPhoto,
+                updateGroupDto.Title, updateGroupDto.Description, updateGroupDto.Visibility), cancellationToken);
+    }
+
+    [HttpGet("{groupId}/members")]
+    [SwaggerOperation(
+        Summary = "Get group members",
+        Description = "Returns paginated members of a group with optional search and role filtering"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(PagedResult<UserGroupDetailsDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(UserGroupDetailsDto))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(UserGroupDetailsDto))]
+    public async Task<ResultT<PagedResult<UserGroupDetailsDto>>> GetGroupMembers([FromRoute] Guid groupId,
+        [FromQuery] int pageNumber, [FromQuery] int pageSize, [FromQuery] string? searchTerm = null,
+        [FromQuery] GroupRole? roleFilter = null)
+    {
+        return await mediator.Send(new GetGroupMembersQuery(groupId, pageNumber, pageSize,
+            searchTerm, roleFilter));
+    }
+
+    [Authorize("StaffOnly")]
+    [HttpGet("{groupId}/join-requests")]
+    [SwaggerOperation(
+        Summary = "Get join requests",
+        Description = "Returns paginated join requests for a group with optional search term"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(PagedResult<UserGroupRequestDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(UserGroupRequestDto))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(UserGroupRequestDto))]
+    public async Task<ResultT<PagedResult<UserGroupRequestDto>>> GetGroupJoinRequests([FromRoute] Guid groupId,
+        [FromQuery] int pageNumber,
+        [FromQuery] int pageSize,
+        [FromQuery] string? searchTerm, CancellationToken cancellationToken)
+    {
+        return await mediator.Send(new GetGroupJoinRequestsCommand(
+            groupId, pageNumber, pageSize, searchTerm), cancellationToken);
+    }
+
+    [HttpPost("{groupId}/join-requests")]
+    [SwaggerOperation(
+        Summary = "Request to join a group",
+        Description = "Allows a user to send a request to join a specific group"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status409Conflict, Type = typeof(ResponseDto))]
+    public async Task<ResultT<ResponseDto>> RequestToJoinGroup([FromRoute] Guid groupId,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new RequestToJoinGroupCommand(userId, groupId), cancellationToken);
+    }
+
+    [Authorize("StaffOnly")]
+    [HttpPatch("{groupId}/requests/{targetUserId}")]
+    [SwaggerOperation(
+        Summary = "Update join request status",
+        Description = "Approves or rejects a user's request to join a specific group. " +
+                      "The new status must be provided in the request body."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status409Conflict, Type = typeof(ResponseDto))]
+    public async Task<ResultT<ResponseDto>> ManageRequest(
+        Guid groupId,
+        Guid targetUserId,
+        [FromBody] ManageRequestStatusDto statusDto,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(
+            new ManageRequestCommand(groupId, targetUserId, statusDto.Status),
+            cancellationToken
+        );
+    }
+
+    [HttpPatch("{groupId}/members/{memberId}/role")]
+    [SwaggerOperation(
+        Summary = "Update group member role",
+        Description = "Updates the role of a specific user in the selected group"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResponseDto))]
+    public async Task<ResultT<ResponseDto>> UpdateMemberRole([FromRoute] Guid groupId, [FromRoute] Guid memberId,
+        [FromBody] UpdateRoleMemberdto dto,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(new UpdateGroupRoleMemberCommand(groupId, memberId, dto.Role), cancellationToken);
+    }
+
+    [Authorize("LeaderOnly")]
+    [HttpDelete("{groupId}")]
+    [SwaggerOperation(
+        Summary = "Delete a group",
+        Description = "Deletes a group if the request comes from the group leader"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status403Forbidden, Type = typeof(ResponseDto))]
+    public async Task<ResultT<ResponseDto>> DeleteGroup([FromRoute] Guid groupId, CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new DeleteGroupCommand(groupId, userId), cancellationToken);
+    }
+
+    [Authorize("LeaderOrModerator")]
+    [HttpPatch("{groupId}/members/{memberId}/moderate")]
+    [SwaggerOperation(
+        Summary = "Ban or remove a group member",
+        Description = "Ban a user or remove them from the group"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResponseDto))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResponseDto))]
+    public async Task<ResultT<ResponseDto>> ModerateMember([FromRoute] Guid groupId, [FromRoute] Guid memberId,
+        [FromBody] GroupUserModerationDto moderation, CancellationToken cancellationToken)
+    {
+        return await mediator.Send(new GroupUserModerationCommand(memberId, groupId, moderation.Status),
+            cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Controllers/MessagesController.cs b/Rex.Presentation.Api/Controllers/MessagesController.cs
new file mode 100644
index 0000000..b4ff389
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/MessagesController.cs
@@ -0,0 +1,56 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+using Rex.Application.DTOs.Message;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.Messages.Commands.SendFileMessage;
+using Rex.Application.Modules.Messages.Queries.GetMessagesByChatId;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Swashbuckle.AspNetCore.Annotations;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiVersion("1.0")]
+[ApiController]
+[Route("api/v{version:apiVersion}/[controller]")]
+public class MessagesController(IMediator mediator, IUserClaimService userClaimService) : ControllerBase
+{
+    [HttpGet("chat/{chatId}")]
+    [SwaggerOperation(
+        Summary = "Get chat messages",
+        Description = "Retrieves a paginated list of messages from a specific chat."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<MessageDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<MessageDto>>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<PagedResult<MessageDto>>))]
+    public async Task<ResultT<PagedResult<MessageDto>>> GetMessageByChatIdAsync(
+        [FromRoute] Guid chatId,
+        [FromQuery] int pageNumber,
+        [FromQuery] int pageSize,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(new GetMessagesByChatIdQuery(chatId, pageNumber, pageSize), cancellationToken);
+    }
+
+    [Authorize]
+    [HttpPost("file")]
+    [SwaggerOperation(
+        Summary = "Send file message",
+        Description = "Sends a message that includes a file attachment within a specific chat."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<MessageDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<MessageDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<MessageDto>))]
+    [ProducesResponseType(StatusCodes.Status415UnsupportedMediaType, Type = typeof(ResultT<MessageDto>))]
+    public async Task<ResultT<MessageDto>> SendFileMessageAsync(
+        [FromForm] SendFileMessageDto sendFileMessage,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(
+            new SendFileMessageCommand(sendFileMessage.ChatId, userId, sendFileMessage.Message, sendFileMessage.Files),
+            cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Controllers/NotificationsController.cs b/Rex.Presentation.Api/Controllers/NotificationsController.cs
new file mode 100644
index 0000000..a820a3f
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/NotificationsController.cs
@@ -0,0 +1,51 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Mvc;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.DTOs.Notification;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.Notifications.Commands.MarkNotificationAsRead;
+using Rex.Application.Modules.Notifications.Queries.GetNotificationsByUserId;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Swashbuckle.AspNetCore.Annotations;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiController]
+[ApiVersion("1.0")]
+[Route("api/v:{version:apiVersion}/[controller]")]
+public class NotificationsController(IMediator mediator, IUserClaimService userClaimService) : ControllerBase
+{
+    [HttpGet("user-notifications")]
+    [SwaggerOperation(
+        Summary = "Get notifications by user",
+        Description = "Retrieves a paginated list of notifications for the authenticated user."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<NotificationDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<NotificationDto>>))]
+    public async Task<ResultT<PagedResult<NotificationDto>>> GetNotificationsByUserIdAsync(
+        [FromQuery] int pageNumber,
+        [FromQuery] int pageSize,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new GetNotificationsByUserIdCommand(userId, pageNumber, pageSize),
+            cancellationToken);
+    }
+
+    [HttpPut("{notificationId}/mark-as-read")]
+    [SwaggerOperation(
+        Summary = "Mark notification as read",
+        Description = "Marks a specific notification as read for the authenticated user."
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> MarkNotificationAsReadAsync(
+        [FromRoute] Guid notificationId,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(new MarkNotificationAsReadCommand(notificationId), cancellationToken);
+    }
+}
diff --git a/Rex.Presentation.Api/Controllers/PostsController.cs b/Rex.Presentation.Api/Controllers/PostsController.cs
new file mode 100644
index 0000000..462e7fa
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/PostsController.cs
@@ -0,0 +1,80 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.DTOs.Post;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.Posts.Commands;
+using Rex.Application.Modules.Posts.Commands.DeletePost;
+using Rex.Application.Modules.Posts.Queries.GetPostsByGroupId;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Swashbuckle.AspNetCore.Annotations;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiVersion("1.0")]
+[ApiController]
+[Authorize]
+[Route("api/v{version:apiVersion}/[controller]")]
+public class PostsController(IMediator mediator, IUserClaimService userClaimService) : ControllerBase
+{
+    [HttpPost]
+    [SwaggerOperation(
+        Summary = "Create a new post",
+        Description = "Creates a new post in a specified group"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status403Forbidden, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> CreatePostAsync(
+        [FromForm] CreatePostDto createPost,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(
+            new CreatePostCommand(createPost.GroupId, userId, createPost.ChallengeId, createPost.Title,
+                createPost.Description, createPost.Files), cancellationToken);
+    }
+
+    [HttpGet("group/{groupId}")]
+    [SwaggerOperation(
+        Summary = "Get posts by group ID",
+        Description = "Retrieves a paginated list of posts for a specific group"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<PostDetailsDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<PostDetailsDto>>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<PagedResult<PostDetailsDto>>))]
+    public async Task<ResultT<PagedResult<PostDetailsDto>>> GetPostsByGroupIdAsync(
+        [FromRoute] Guid groupId,
+        [FromQuery] int pageNumber,
+        [FromQuery] int pageSize,
+        CancellationToken cancellationToken = default)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(
+            new GetPostsByGroupIdQuery(groupId, userId, pageNumber, pageSize),
+            cancellationToken
+        );
+    }
+
+    [HttpDelete("{postId}")]
+    [SwaggerOperation(
+        Summary = "Delete a post",
+        Description = "Deletes a post if the user has permission"
+    )]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status403Forbidden, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> DeletePostAsync(
+        [FromRoute] Guid postId,
+        [FromQuery] Guid groupId,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new DeletePostCommand(postId, groupId, userId), cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Controllers/UsersController.cs b/Rex.Presentation.Api/Controllers/UsersController.cs
new file mode 100644
index 0000000..ad9cee6
--- /dev/null
+++ b/Rex.Presentation.Api/Controllers/UsersController.cs
@@ -0,0 +1,204 @@
+using Asp.Versioning;
+using MediatR;
+using Microsoft.AspNetCore.Authorization;
+using Microsoft.AspNetCore.Mvc;
+using Rex.Application.DTOs.Code;
+using Rex.Application.DTOs.Group;
+using Rex.Application.DTOs.JWT;
+using Rex.Application.DTOs.User;
+using Rex.Application.Interfaces;
+using Rex.Application.Modules.Groups.Queries.GetGroupsPaginated;
+using Rex.Application.Modules.User.Commands.ConfirmAccount;
+using Rex.Application.Modules.User.Commands.ConfirmEmailChange;
+using Rex.Application.Modules.User.Commands.RegisterUser;
+using Rex.Application.Modules.User.Commands.ResendCode;
+using Rex.Application.Modules.User.Commands.UpdateEmail;
+using Rex.Application.Modules.User.Commands.UpdatePassword;
+using Rex.Application.Modules.User.Commands.UpdateUserInformation;
+using Rex.Application.Modules.User.Commands.UpdateUsername;
+using Rex.Application.Modules.User.Queries.GetUserDetails;
+using Rex.Application.Modules.Users.Commands.ConfirmPasswordChangeByEmail;
+using Rex.Application.Modules.Users.Commands.InactiveAccount;
+using Rex.Application.Modules.Users.Commands.UpdatePasswordByEmail;
+using Rex.Application.Pagination;
+using Rex.Application.Utilities;
+using Rex.Enum;
+using Swashbuckle.AspNetCore.Annotations;
+
+namespace Rex.Presentation.Api.Controllers;
+
+[ApiVersion("1.0")]
+[ApiController]
+[Route("api/v{version:apiVersion}/users")]
+public class UsersController(IMediator mediator, IUserClaimService userClaimService) : ControllerBase
+{
+    [Authorize]
+    [HttpPut("password")]
+    [SwaggerOperation(Summary = "Update user password", Description = "Updates the password of an existing user")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> UpdatePassword([FromBody] UpdatePasswordDto updatePassword,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(
+            new UpdatePasswordCommand(userId, updatePassword.CurrentPassword, updatePassword.NewPassword),
+            cancellationToken);
+    }
+
+    [Authorize]
+    [HttpPost("resend-code")]
+    [SwaggerOperation(Summary = "Resend confirmation code", Description = "Resends the confirmation code to the user")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status409Conflict, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> ResendCodeAsync([FromBody] ResendCodeCommand command,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(command, cancellationToken);
+    }
+
+    [HttpPost]
+    [SwaggerOperation(Summary = "Register a new user", Description = "Registers a new user with the provided information")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<RegisterUserDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<RegisterUserDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<RegisterUserDto>))]
+    [ProducesResponseType(StatusCodes.Status409Conflict, Type = typeof(ResultT<RegisterUserDto>))]
+    public async Task<ResultT<RegisterUserDto>> RegisterUserAsync([FromForm] RegisterUserCommand command,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(command, cancellationToken);
+    }
+
+    [Authorize]
+    [HttpPost("confirm-account")]
+    [SwaggerOperation(Summary = "Confirm account", Description = "Confirms a user account using the provided code")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> ConfirmAccountAsync([FromBody] ConfirmAccountDto code,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new ConfirmAccountCommand(userId, code.Code), cancellationToken);
+    }
+
+    [Authorize]
+    [HttpPut("confirm-email-change")]
+    [SwaggerOperation(Summary = "Confirm email change", Description = "Confirms a pending email change request")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> ConfirmEmailAsync([FromBody] ConfirmEmailCodeDto code,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new ConfirmEmailChangeCommand(userId, code.Code), cancellationToken);
+    }
+
+    [Authorize]
+    [HttpPut("change-email")]
+    [SwaggerOperation(Summary = "Update user email", Description = "Updates the email of an existing user")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status409Conflict, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> UpdateEmailAsync([FromBody] UpdateEmailDto updateEmail,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new UpdateEmailCommand(userId, updateEmail.Email, updateEmail.NewEmail),
+            cancellationToken);
+    }
+
+    [Authorize]
+    [HttpPatch("username")]
+    [SwaggerOperation(Summary = "Update username", Description = "Updates the username of an existing user")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status409Conflict, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> UpdateUsernameAsync([FromBody] UpdateUsernameDto updateUsername,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new UpdateUsernameCommand(userId, updateUsername.Username), cancellationToken);
+    }
+
+    [Authorize]
+    [HttpPut]
+    [SwaggerOperation(Summary = "Update user information", Description = "Updates general information of an existing user")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> UpdateUserInformation([FromForm] UpdateUserInformationDto updateUserInformation,
+        CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(
+            new UpdateUserInformationCommand(userId, updateUserInformation.ProfilePhoto,
+                updateUserInformation.Firstname, updateUserInformation.Lastname, updateUserInformation.Biography),
+            cancellationToken);
+    }
+
+    [Authorize]
+    [HttpGet("me")]
+    [SwaggerOperation(Summary = "Get user profile by ID", Description = "Returns profile information of the current user")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<UserProfileDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<UserProfileDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<UserProfileDto>))]
+    public async Task<ResultT<UserProfileDto>> GetUserProfileById(CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new GetUserDetailsByIdQuery(userId), cancellationToken);
+    }
+
+    [Authorize]
+    [HttpGet("groups/recommended")]
+    [SwaggerOperation(Summary = "Get recommended groups for user", Description = "Returns paginated list of groups the user is not a member of")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<PagedResult<GroupDetailsDto>>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<PagedResult<GroupDetailsDto>>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<PagedResult<GroupDetailsDto>>))]
+    public async Task<ResultT<PagedResult<GroupDetailsDto>>> GetGroupsUserNotIn([FromQuery] int pageNumber,
+        [FromQuery] int pageSize, CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new GetGroupsPaginatedQuery(userId, pageNumber, pageSize), cancellationToken);
+    }
+
+    [HttpDelete("deactivate")]
+    [SwaggerOperation(Summary = "Deactivate user account", Description = "Deactivates the user account")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status403Forbidden, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> InactivateAccountAsync(CancellationToken cancellationToken)
+    {
+        var userId = userClaimService.GetUserId(User);
+        return await mediator.Send(new InactiveAccountCommand(userId), cancellationToken);
+    }
+
+    [HttpPost("password/reset/request")]
+    [SwaggerOperation(Summary = "Request password reset", Description = "Sends a reset code to the user's email")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> RequestPasswordResetAsync([FromBody] UpdatePasswordByEmailCommand command,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(command, cancellationToken);
+    }
+
+    [HttpPut("password/reset/confirm")]
+    [SwaggerOperation(Summary = "Confirm password reset", Description = "Confirms the reset code and updates the password")]
+    [ProducesResponseType(StatusCodes.Status200OK, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status400BadRequest, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status404NotFound, Type = typeof(ResultT<ResponseDto>))]
+    [ProducesResponseType(StatusCodes.Status422UnprocessableEntity, Type = typeof(ResultT<ResponseDto>))]
+    public async Task<ResultT<ResponseDto>> ConfirmPasswordResetAsync([FromBody] ConfirmPasswordChangeByEmailCommand command,
+        CancellationToken cancellationToken)
+    {
+        return await mediator.Send(command, cancellationToken);
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Filters/HangfireAuthorizationFilter.cs b/Rex.Presentation.Api/Filters/HangfireAuthorizationFilter.cs
new file mode 100644
index 0000000..4923439
--- /dev/null
+++ b/Rex.Presentation.Api/Filters/HangfireAuthorizationFilter.cs
@@ -0,0 +1,25 @@
+using Hangfire.Dashboard;
+using Rex.Enum;
+
+namespace Trivo.Presentation.API.Filters;
+
+public class HangfireAuthorizationFilter(string environment) : IDashboardAuthorizationFilter
+{
+    public bool Authorize(DashboardContext context)
+    {
+        var httpContext = context.GetHttpContext();
+
+        if (httpContext.Connection.RemoteIpAddress?.Equals(httpContext.Connection.LocalIpAddress) == true ||
+            httpContext.Request.Host.Host.Contains("localhost"))
+        {
+            return true;
+        }
+
+        if (environment == "Development")
+        {
+            return true;
+        }
+
+        return httpContext.User.IsInRole(UserRole.Admin.ToString());
+    }
+}
diff --git a/Rex.Presentation.Api/Filters/ResultFilter.cs b/Rex.Presentation.Api/Filters/ResultFilter.cs
new file mode 100644
index 0000000..896537c
--- /dev/null
+++ b/Rex.Presentation.Api/Filters/ResultFilter.cs
@@ -0,0 +1,61 @@
+using Microsoft.AspNetCore.Mvc;
+using Microsoft.AspNetCore.Mvc.Filters;
+using Rex.Application.Utilities;
+
+namespace Trivo.Presentation.API.Filters;
+
+public class ResultFilter(ILogger<ResultFilter> logger) : IAsyncActionFilter
+{
+    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
+    {
+        var executedContext = await next();
+
+        if (executedContext.Result is ObjectResult objectResult && objectResult.Value is Result result)
+        {
+            if (!result.IsSuccess)
+            {
+                int statusCode = GetStatusCodeFromError(result.Error);
+
+                logger.LogWarning("Operation failed with code {Code} and message: {Message}", result.Error?.Code, result.Error?.Description);
+
+                // Create an anonymous object with the error details
+                var errorResponse = new
+                {
+                    code = result.Error?.Code,
+                    description = result.Error?.Description
+                };
+
+                var objResult = new ObjectResult(errorResponse);
+
+                objResult.StatusCode = statusCode;
+
+                executedContext.Result = objResult;
+
+                return;
+
+            }
+
+            // If the result is ResultT<T>, return its Value
+            var type = result.GetType();
+            if (type.IsGenericType && type.GetGenericTypeDefinition() == typeof(ResultT<>))
+            {
+                var value = type.GetProperty("Value")!.GetValue(result);
+                executedContext.Result = new OkObjectResult(value);
+            }
+        }
+    }
+
+    private static int GetStatusCodeFromError(Error? error)
+    {
+        if (error != null && int.TryParse(error.Code, out var statusCode))
+        {
+            if (statusCode >= 100 && statusCode <= 599)
+            {
+                return statusCode;
+            }
+        }
+
+        return StatusCodes.Status500InternalServerError;
+    }
+
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/Middlewares/ExceptionHandlingMiddleware.cs b/Rex.Presentation.Api/Middlewares/ExceptionHandlingMiddleware.cs
new file mode 100644
index 0000000..74462ff
--- /dev/null
+++ b/Rex.Presentation.Api/Middlewares/ExceptionHandlingMiddleware.cs
@@ -0,0 +1,75 @@
+using FluentValidation;
+using Rex.Application.DTOs.Configs;
+
+
+namespace Rex.Presentation.Api.Middlewares;
+
+public class ExceptionHandlingMiddleware(RequestDelegate next, ILogger<ExceptionHandlingMiddleware> logger)
+{
+    public async Task InvokeAsync(HttpContext context)
+    {
+        var trackerId = Guid.NewGuid().ToString();
+        context.Response.Headers["tracker-id"] = trackerId;
+
+        try
+        {
+            await next(context);
+
+            if (context.Response.StatusCode == StatusCodes.Status401Unauthorized)
+            {
+                context.Response.ContentType = "application/json";
+                await context.Response.WriteAsJsonAsync(ProblemDetailsDto.Fail(
+                    message: "Authentication required",
+                    code: StatusCodes.Status401Unauthorized,
+                    details: "You need to sign in to access this resource."
+                ));
+            }
+
+            if (context.Response.StatusCode == StatusCodes.Status403Forbidden)
+            {
+                context.Response.ContentType = "application/json";
+                await context.Response.WriteAsJsonAsync(ProblemDetailsDto.Fail(
+                    message: "Access denied",
+                    code: StatusCodes.Status403Forbidden,
+                    details: "You do not have permission to perform this action."
+                ));
+            }
+        }
+        catch (ValidationException ex)
+        {
+            logger.LogWarning(
+                "Validation error: {Message} | TrackerId: {TrackerId} | Path: {Path}",
+                ex.Message, trackerId, context.Request.Path
+            );
+
+            var errors = ex.Errors
+                .GroupBy(e => e.PropertyName)
+                .ToDictionary(
+                    g => g.Key,
+                    g => g.Select(e => e.ErrorMessage).ToArray()
+                );
+
+            context.Response.StatusCode = StatusCodes.Status400BadRequest;
+            context.Response.ContentType = "application/json";
+            await context.Response.WriteAsJsonAsync(ProblemDetailsDto.Fail(
+                message: "Validation errors",
+                code: StatusCodes.Status400BadRequest,
+                details: "One or more validation errors occurred.",
+                errors: errors
+            ));
+        }
+
+        catch (Exception ex)
+        {
+            logger.LogError(ex, "Unhandled exception | TrackerId: {TrackerId} | Path: {Path}", trackerId, context.Request.Path);
+
+            context.Response.StatusCode = StatusCodes.Status500InternalServerError;
+            context.Response.ContentType = "application/json";
+            await context.Response.WriteAsJsonAsync(ProblemDetailsDto.Fail(
+                message: "Server error",
+                code: StatusCodes.Status500InternalServerError,
+                details: "An unexpected error occurred. Please try again later."
+            ));
+        }
+    }
+}
diff --git a/Rex.Presentation.Api/Program.cs b/Rex.Presentation.Api/Program.cs
new file mode 100644
index 0000000..a61eaae
--- /dev/null
+++ b/Rex.Presentation.Api/Program.cs
@@ -0,0 +1,81 @@
+using Hangfire;
+using Microsoft.AspNetCore.Authentication.JwtBearer;
+using Microsoft.OpenApi;
+using Rex.Application;
+using Rex.Infrastructure.Persistence;
+using Rex.Infrastructure.Shared;
+using Rex.Infrastructure.Shared.Services.SignalR.Hubs;
+using Rex.Presentation.Api.ServicesExtension;
+using Serilog;
+using Trivo.Presentation.API.Filters;
+
+var builder = WebApplication.CreateBuilder(args);
+
+builder.Host.UseSerilog((context, loggerConfig) =>
+{
+    loggerConfig.ReadFrom.Configuration(context.Configuration);
+});
+
+builder.Services.AddControllers().AddFilters();
+builder.Services.AddEndpointsApiExplorer();
+builder.Services.AddSwaggerGen();
+builder.Services.AddPersistenceLayer(builder.Configuration);
+builder.Services.AddApplicationLayer(builder.Configuration);
+builder.Services.AddSharedLayer(builder.Configuration);
+builder.Services.AddSwaggerExtension();
+builder.Services.AddVersioning();
+
+builder.Services.AddAuthentication(options =>
+{
+    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
+    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
+    options.DefaultScheme = JwtBearerDefaults.AuthenticationScheme;
+});
+
+builder.Services.AddAuthorization();
+
+builder.Services.AddCors(options =>
+{
+    options.AddPolicy("AllowAllOrigins", policy =>
+    {
+        policy.AllowAnyHeader().AllowAnyMethod().AllowAnyOrigin();
+    });
+});
+
+var app = builder.Build();
+
+app.UseExceptionHandling();
+app.UseSerilogRequestLogging();
+
+if (app.Environment.IsDevelopment())
+{
+    app.UseSwagger(options => options.OpenApiVersion = OpenApiSpecVersion.OpenApi2_0);
+    app.UseSwaggerUI(c =>
+    {
+        c.SwaggerEndpoint("./v1/swagger.json", "Rex v1");
+        c.RoutePrefix = "swagger";
+    });
+}
+
+app.UseWebSockets();
+app.UseRouting();
+
+app.UseCors("AllowAllOrigins");
+app.UseAuthentication();
+app.UseAuthorization();
+
+app.UseEndpoints(endpoints =>
+{
+    endpoints.MapControllers();
+    endpoints.MapHangfireDashboard("/hangfire", new DashboardOptions
+    {
+        Authorization = new[] { new HangfireAuthorizationFilter(builder.Environment.EnvironmentName) },
+        DashboardTitle = "Rex - Background Jobs"
+    });
+});
+
+app.ConfigureHangfireJobs();
+
+app.MapHub<AppHub>("/hubs/app");
+
+app.Run();
diff --git a/Rex.Presentation.Api/Properties/launchSettings.json b/Rex.Presentation.Api/Properties/launchSettings.json
new file mode 100644
index 0000000..69da50a
--- /dev/null
+++ b/Rex.Presentation.Api/Properties/launchSettings.json
@@ -0,0 +1,41 @@
+{
+  "$schema": "http://json.schemastore.org/launchsettings.json",
+  "iisSettings": {
+    "windowsAuthentication": false,
+    "anonymousAuthentication": true,
+    "iisExpress": {
+      "applicationUrl": "http://localhost:19129",
+      "sslPort": 44331
+    }
+  },
+  "profiles": {
+    "http": {
+      "commandName": "Project",
+      "dotnetRunMessages": true,
+      "launchBrowser": true,
+      "launchUrl": "swagger",
+      "applicationUrl": "http://localhost:5288",
+      "environmentVariables": {
+        "ASPNETCORE_ENVIRONMENT": "Development"
+      }
+    },
+    "https": {
+      "commandName": "Project",
+      "dotnetRunMessages": true,
+      "launchBrowser": true,
+      "launchUrl": "swagger",
+      "applicationUrl": "https://localhost:7099;http://localhost:5288",
+      "environmentVariables": {
+        "ASPNETCORE_ENVIRONMENT": "Development"
+      }
+    },
+    "IIS Express": {
+      "commandName": "IISExpress",
+      "launchBrowser": true,
+      "launchUrl": "swagger",
+      "environmentVariables": {
+        "ASPNETCORE_ENVIRONMENT": "Development"
+      }
+    }
+  }
+}
diff --git a/Rex.Presentation.Api/Rex.Presentation.Api.csproj b/Rex.Presentation.Api/Rex.Presentation.Api.csproj
new file mode 100644
index 0000000..597045a
--- /dev/null
+++ b/Rex.Presentation.Api/Rex.Presentation.Api.csproj
@@ -0,0 +1,30 @@
+<Project Sdk="Microsoft.NET.Sdk.Web">
+
+    <PropertyGroup>
+        <TargetFramework>net8.0</TargetFramework>
+        <Nullable>enable</Nullable>
+        <ImplicitUsings>enable</ImplicitUsings>
+    </PropertyGroup>
+
+    <ItemGroup>
+        <PackageReference Include="Asp.Versioning.Mvc" Version="8.1.0" />
+        <PackageReference Include="MediatR" Version="12.2.0" />
+        <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.10" />
+        <PackageReference Include="Microsoft.AspNetCore.SignalR.Core" Version="1.2.0" />
+        <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.10">
+          <PrivateAssets>all</PrivateAssets>
+          <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
+        </PackageReference>
+        <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
+        <PackageReference Include="Serilog.Sinks.Console" Version="6.0.0" />
+        <PackageReference Include="Serilog.Sinks.Seq" Version="8.0.0" />
+        <PackageReference Include="Swashbuckle.AspNetCore" Version="6.6.2"/>
+        <PackageReference Include="Swashbuckle.AspNetCore.Annotations" Version="8.1.0" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <ProjectReference Include="..\Rex.Infrastructure.Persistence\Rex.Infrastructure.Persistence.csproj" />
+      <ProjectReference Include="..\Rex.Infrastructure.Shared\Rex.Infrastructure.Shared.csproj" />
+    </ItemGroup>
+
+</Project>
diff --git a/Rex.Presentation.Api/Rex.Presentation.Api.http b/Rex.Presentation.Api/Rex.Presentation.Api.http
new file mode 100644
index 0000000..d7a22c5
--- /dev/null
+++ b/Rex.Presentation.Api/Rex.Presentation.Api.http
@@ -0,0 +1,6 @@
+@Rex.Presentation.Api_HostAddress = http://localhost:5288
+
+GET {{Rex.Presentation.Api_HostAddress}}/weatherforecast/
+Accept: application/json
+
+###
diff --git a/Rex.Presentation.Api/ServicesExtension/ServiceExtensions.cs b/Rex.Presentation.Api/ServicesExtension/ServiceExtensions.cs
new file mode 100644
index 0000000..152f067
--- /dev/null
+++ b/Rex.Presentation.Api/ServicesExtension/ServiceExtensions.cs
@@ -0,0 +1,79 @@
+using Asp.Versioning;
+using Microsoft.OpenApi.Models;
+using Rex.Presentation.Api.Middlewares;
+using Trivo.Presentation.API.Filters;
+
+namespace Rex.Presentation.Api.ServicesExtension;
+
+public static class ServiceExtensions
+{
+    public static void UseExceptionHandling(this IApplicationBuilder app)
+    {
+        app.UseMiddleware<ExceptionHandlingMiddleware>();
+    }
+
+    public static void AddSwaggerExtension(this IServiceCollection services)
+    {
+        services.AddSwaggerGen(options =>
+        {
+            options.SwaggerDoc("v1", new OpenApiInfo
+            {
+                Version = "v1",
+                Title = "Rex",
+                Description =
+                    "Rex is a community-driven platform for self-taught individuals to stay motivated through challenges, share their progress in posts, and engage with others through reactions.",
+                Contact = new OpenApiContact
+                {
+                    Name = "Dayron Bello",
+                    Email = "dayronbp06@gmail.com"
+                }
+            });
+
+            options.EnableAnnotations();
+
+            options.DescribeAllParametersInCamelCase();
+            options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
+            {
+                Name = "Authorization",
+                In = ParameterLocation.Header,
+                Type = SecuritySchemeType.ApiKey,
+                Scheme = "bearer",
+                BearerFormat = "JWT",
+                Description = "Input your Bearer token in this format - Bearer {your token here}"
+            });
+            options.AddSecurityRequirement(new OpenApiSecurityRequirement
+            {
+                {
+                    new OpenApiSecurityScheme
+                    {
+                        Reference = new OpenApiReference
+                        {
+                            Type = ReferenceType.SecurityScheme,
+                            Id = "Bearer"
+                        },
+                        Scheme = "Bearer",
+                        Name = "Bearer",
+                        In = ParameterLocation.Header
+                    }, 
+                    new List<string>()
+                }     
+            }); 
+        });
+    }
+
+
+    public static void AddFilters(this IMvcBuilder builder)
+    {
+        builder.AddMvcOptions(options => { options.Filters.Add<ResultFilter>(); });
+    }
+
+    public static void AddVersioning(this IServiceCollection services)
+    {
+        services.AddApiVersioning(options =>
+        {
+            options.ReportApiVersions = true;
+            options.DefaultApiVersion = new ApiVersion(1, 0);
+            options.AssumeDefaultVersionWhenUnspecified = false;
+        });
+    }
+}
\ No newline at end of file
diff --git a/Rex.Presentation.Api/appsettings.Development.json b/Rex.Presentation.Api/appsettings.Development.json
new file mode 100644
index 0000000..0c208ae
--- /dev/null
+++ b/Rex.Presentation.Api/appsettings.Development.json
@@ -0,0 +1,8 @@
+{
+  "Logging": {
+    "LogLevel": {
+      "Default": "Information",
+      "Microsoft.AspNetCore": "Warning"
+    }
+  }
+}
diff --git a/Rex.sln b/Rex.sln
new file mode 100644
index 0000000..f475db6
--- /dev/null
+++ b/Rex.sln
@@ -0,0 +1,61 @@
+
+Microsoft Visual Studio Solution File, Format Version 12.00
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Rex.Domain", "Rex.Domain\Rex.Domain.csproj", "{2992F86E-7C02-484C-8656-9A76C57A695D}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "src", "src", "{37B18598-0E4E-41E0-9885-297287C128DB}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Domain", "Domain", "{56495204-1B31-4E76-9DAC-91D9149A20FD}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Infrastructure", "Infrastructure", "{7E6540E2-7AB7-4B69-8DFB-AA15D5BFBAA8}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Rex.Infrastructure.Persistence", "Rex.Infrastructure.Persistence\Rex.Infrastructure.Persistence.csproj", "{0C891B9F-0627-4565-B6BB-2746A5719E78}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Presentation", "Presentation", "{B151BA44-F799-42FC-9BE0-D49E6F4722D1}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Rex.Presentation.Api", "Rex.Presentation.Api\Rex.Presentation.Api.csproj", "{FC4CB8C9-D8EC-477A-9A84-58E2D64C8A10}"
+EndProject
+Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Application", "Application", "{10EB95E0-2DC4-4066-9CE6-F52D8ACEA5B2}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Rex.Application", "Rex.Application\Rex.Application.csproj", "{D6E05503-2D65-4656-978A-EC390A967FD6}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Rex.Infrastructure.Shared", "Rex.Infrastructure.Shared\Rex.Infrastructure.Shared.csproj", "{3CAD11DA-9A25-45C8-BDCE-B36E25E57560}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Any CPU = Debug|Any CPU
+		Release|Any CPU = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{2992F86E-7C02-484C-8656-9A76C57A695D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{2992F86E-7C02-484C-8656-9A76C57A695D}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{2992F86E-7C02-484C-8656-9A76C57A695D}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{2992F86E-7C02-484C-8656-9A76C57A695D}.Release|Any CPU.Build.0 = Release|Any CPU
+		{0C891B9F-0627-4565-B6BB-2746A5719E78}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{0C891B9F-0627-4565-B6BB-2746A5719E78}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{0C891B9F-0627-4565-B6BB-2746A5719E78}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{0C891B9F-0627-4565-B6BB-2746A5719E78}.Release|Any CPU.Build.0 = Release|Any CPU
+		{FC4CB8C9-D8EC-477A-9A84-58E2D64C8A10}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{FC4CB8C9-D8EC-477A-9A84-58E2D64C8A10}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{FC4CB8C9-D8EC-477A-9A84-58E2D64C8A10}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{FC4CB8C9-D8EC-477A-9A84-58E2D64C8A10}.Release|Any CPU.Build.0 = Release|Any CPU
+		{D6E05503-2D65-4656-978A-EC390A967FD6}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{D6E05503-2D65-4656-978A-EC390A967FD6}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{D6E05503-2D65-4656-978A-EC390A967FD6}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{D6E05503-2D65-4656-978A-EC390A967FD6}.Release|Any CPU.Build.0 = Release|Any CPU
+		{3CAD11DA-9A25-45C8-BDCE-B36E25E57560}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{3CAD11DA-9A25-45C8-BDCE-B36E25E57560}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{3CAD11DA-9A25-45C8-BDCE-B36E25E57560}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{3CAD11DA-9A25-45C8-BDCE-B36E25E57560}.Release|Any CPU.Build.0 = Release|Any CPU
+	EndGlobalSection
+	GlobalSection(NestedProjects) = preSolution
+		{56495204-1B31-4E76-9DAC-91D9149A20FD} = {37B18598-0E4E-41E0-9885-297287C128DB}
+		{2992F86E-7C02-484C-8656-9A76C57A695D} = {56495204-1B31-4E76-9DAC-91D9149A20FD}
+		{7E6540E2-7AB7-4B69-8DFB-AA15D5BFBAA8} = {37B18598-0E4E-41E0-9885-297287C128DB}
+		{0C891B9F-0627-4565-B6BB-2746A5719E78} = {7E6540E2-7AB7-4B69-8DFB-AA15D5BFBAA8}
+		{B151BA44-F799-42FC-9BE0-D49E6F4722D1} = {37B18598-0E4E-41E0-9885-297287C128DB}
+		{FC4CB8C9-D8EC-477A-9A84-58E2D64C8A10} = {B151BA44-F799-42FC-9BE0-D49E6F4722D1}
+		{10EB95E0-2DC4-4066-9CE6-F52D8ACEA5B2} = {37B18598-0E4E-41E0-9885-297287C128DB}
+		{D6E05503-2D65-4656-978A-EC390A967FD6} = {10EB95E0-2DC4-4066-9CE6-F52D8ACEA5B2}
+		{3CAD11DA-9A25-45C8-BDCE-B36E25E57560} = {7E6540E2-7AB7-4B69-8DFB-AA15D5BFBAA8}
+	EndGlobalSection
+EndGlobal
diff --git a/docker-compose.yml b/docker-compose.yml
new file mode 100644
index 0000000..54e86db
--- /dev/null
+++ b/docker-compose.yml
@@ -0,0 +1,63 @@
+services:
+  postgres:
+    image: ${POSTGRES_IMAGE}
+    container_name: PostgreSQL
+    restart: always
+    environment:
+      - POSTGRES_USER=${POSTGRES_USER}
+      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
+      - POSTGRES_DB=${POSTGRES_DB}
+    ports:
+      - ${POSTGRES_PORTS}:5432
+    volumes:
+      - PostgresDb:/var/lib/postgresql/data
+    healthcheck:
+      test: [ "CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}" ]
+      interval: 5s
+      timeout: 5s
+      retries: 5
+  
+  pgAdmin:
+    image: ${PG_ADMIN_IMAGE}
+    container_name: PgAdmin
+    restart: always
+    depends_on:
+      postgres:
+        condition: service_healthy
+    environment:
+      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_DEFAULT_EMAIL}
+      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD}
+    ports:
+      - ${PGADMIN_PORTS}:80
+    volumes:
+      - PgAdmin:/var/lib/pgadmin
+      
+  Seq:
+    image: ${SEQ_IMAGE}
+    container_name: SEQ
+    restart: always
+    environment:
+      - ACCEPT_EULA=${SEQ_ACCEPT_EULA}
+      - SEQ_FIRSTRUN_ADMINPASSWORD=${SEQ_FIRSTRUN_ADMINPASSWORD}
+    ports:
+      - ${SEQ_PORT}:5341
+      - ${SEQ_PORT_UI}:80
+    volumes:
+      - Seq:/data
+      
+  Redis:
+    image: ${REDIS_IMAGE}
+    container_name: RedisDB
+    restart: always
+    ports:
+      - ${REDIS_PORTS}:6379
+    healthcheck:
+      test: ["CMD", "redis-cli", "ping"]
+      interval: 5s
+      timeout: 5s
+      retries: 5
+        
+volumes:
+  PostgresDb:
+  PgAdmin:
+  Seq:
\ No newline at end of file
-- 
2.51.2

